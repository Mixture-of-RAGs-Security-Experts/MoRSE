import os
import re
import warnings
import json
import logging
import time
import pandas as pd
from tqdm import tqdm
from haystack.nodes import BM25Retriever, EntityExtractor
from langchain.docstore.document import Document
from langchain.document_loaders.generic import GenericLoader
from langchain.document_loaders.parsers import LanguageParser
from langchain.embeddings import HuggingFaceBgeEmbeddings
from langchain.retrievers import EnsembleRetriever, TFIDFRetriever
from langchain.vectorstores import FAISS
from langchain.text_splitter import Language

# Suppress warnings
warnings.filterwarnings("ignore")

class CodeRetrievalSystem:
    def __init__(self):
        self.cve_path = "cves"
        self.cve_df = pd.DataFrame()
        self.hf_bge_embeddings = HuggingFaceBgeEmbeddings(
            model_name="BAAI/bge-large-en",
            # model_kwargs={"device": "cuda:4"},
            encode_kwargs={"normalize_embeddings": True},
        )
        self.setup_logger = None
        (
            self.cve_retriever,
            self.metasploit_retriever,
            self.metasploit_df,
            self.exploit_retriever,
            self.df_exploit,
            self.ensemble_code_retriever,
        ) = self.set_up()

    def set_up(self):
        try:
            # Configure logging with date and time
            log_file = "Code_Retrieval_Log.txt"
            logging.basicConfig(
                filename=log_file,
                level=logging.INFO,
                format="%(asctime)s - %(levelname)s - %(message)s",
            )

            # Create a logger specific to the configuration
            self.setup_logger = logging.getLogger("SetupLogger")

            # Build retrievers and extractors
            (
                cve_retriever,
                metasploit_retriever,
                metasploit_df,
                exploit_retriever,
                df_exploit,
                ensemble_code_retriever,
            ) = self.build_retrievers()

            self.setup_logger.info("Setup completed successfully.")

            return (
                cve_retriever,
                metasploit_retriever,
                metasploit_df,
                exploit_retriever,
                df_exploit,
                ensemble_code_retriever,
            )

        except Exception as e:
            # If errors occur during setup, log them in the log file
            if self.setup_logger:
                self.setup_logger.error(f"An error occurred during setup: {e}")
            raise  # Re-raise the exception after logging

    def build_retrievers(self):
        """Builds and returns the various retrievers used in the system."""
        cve_retriever = self.build_cve_retriever()
        metasploit_retriever, metasploit_df, df = self.metasploit_database()
        exploit_retriever, df_exploit = self.exploit_db_database()
        ensemble_code_retriever = self.extracted_code_retriever()
        return (
            cve_retriever,
            metasploit_retriever,
            metasploit_df,
            exploit_retriever,
            df_exploit,
            ensemble_code_retriever,
        )

    def build_cve_retriever(self):
        """Builds the CVE retriever by loading and parsing CVE documents."""
        languages = [".json"]
        cves = []
        for language in tqdm(languages):
            cves.extend(self.cve_loader(language))

        document_list = []
        data = {
            "CVE": [],
            "Affected": [],
            "Descriptions": [],
            "Finder1": [],
            "Finder2": [],
        }

        for cve in tqdm(cves):
            try:
                content = json.loads(cve.page_content)
                cve_id = cve.metadata["source"].split("x/", 1)[1].split(".json")[0]

                affected = (
                    content["containers"]["cna"]["affected"][0]["product"]
                    if "affected" in content["containers"]["cna"]
                    else "n/a"
                )

                descriptions = (
                    content["containers"]["cna"]["descriptions"][0]["value"]
                    if "descriptions" in content["containers"]["cna"]
                    else "n/a"
                )

                finders = (
                    content["containers"]["cna"]["credits"][0]["value"]
                    if "credits" in content["containers"]["cna"]
                    and len(content["containers"]["cna"]["credits"]) > 0
                    else "n/a",
                    content["containers"]["cna"]["credits"][1]["value"]
                    if "credits" in content["containers"]["cna"]
                    and len(content["containers"]["cna"]["credits"]) > 1
                    else "n/a",
                )

                doc = Document(
                    page_content=cve_id,
                    metadata={
                        "cve": cve_id,
                        "Affected": affected,
                        "Descriptions": descriptions,
                        "Finder1": finders[0],
                        "Finder2": finders[1],
                    },
                )
                document_list.append(doc)
                data["CVE"].append(cve_id)
                data["Affected"].append(affected)
                data["Descriptions"].append(descriptions)
                data["Finder1"].append(finders[0])
                data["Finder2"].append(finders[1])

            except Exception as e:
                print(e)
                pass

        self.cve_df = pd.DataFrame(data)
        bm25 = BM25Retriever.from_documents(document_list)
        bm25.k = 1
        return bm25

    def cve_loader(self, suffix):
        """Loads CVE documents from the specified path and suffix."""
        python_loader = GenericLoader.from_filesystem(
            self.cve_path,
            glob="**/*",
            suffixes=[suffix],
            parser=LanguageParser(),
        )
        python_documents = python_loader.load()
        return python_documents

    def find_cve(self, text):
        """Finds CVE identifiers in the given text."""
        if "–" in text:
            text = text.replace("–", "-")

        cve_pattern = re.compile(r"CVE-\d{4}-\d{4,7}")
        matches = re.findall(cve_pattern, text)
        return matches

    def metasploit_database(self):
        """Builds the Metasploit retriever and dataframe."""
        repo_path = "METASPLOIT_DB/"

        def loader(suffix):
            python_loader = GenericLoader.from_filesystem(
                repo_path,
                glob="**/*",
                suffixes=[suffix],
                parser=LanguageParser(),
            )
            python_documents = python_loader.load()
            return python_documents

        documents = []
        language = ".rb"
        docs = loader(language)
        complete_contents = []
        for doc in tqdm(docs):
            metadata = doc.metadata
            complete_contents.append(doc.page_content)
            try:
                content = doc.page_content
                infos = content.split("info,", 1)[1].split(")")[0]
                document = Document(page_content=infos, metadata={"source": metadata})
                documents.append(document)
            except:
                pass

        data = []

        for doc in tqdm(docs, desc=f"Loading {language} documents"):
            metadata = doc.metadata
            content = doc.page_content
            data.append({"metadata": metadata, "content": content})

        df = pd.DataFrame(data)
        DB = FAISS.load_local("../Metasploit_Infos", self.hf_bge_embeddings)
        store = DB.docstore._dict
        metasploit_correspondence = []
        initialize_documents = []
        for key, value in store.items():
            for complete_content in complete_contents:
                if value.page_content in complete_content:
                    initialize_documents.append(value.page_content)
                    metasploit_correspondence.append(
                        {
                            "initialize": value.page_content,
                            "complete_content": complete_content,
                        }
                    )
        for doc in documents:
            for complete_content in complete_contents:
                if doc.page_content in complete_content:
                    metasploit_correspondence.append(
                        {
                            "initialize": doc.page_content,
                            "complete_content": complete_content,
                        }
                    )
        metasploit_df = pd.DataFrame(metasploit_correspondence)
        print(metasploit_df)
        faiss_retriever = DB.as_retriever(
            search_type="similarity_score_threshold",
            search_kwargs={"score_threshold": 0.70, "k": 3},
        )
        tfidf = TFIDFRetriever.from_documents(documents)
        tfidf.k = 3
        ensemble_metasploit_retriever = EnsembleRetriever(
            retrievers=[tfidf, faiss_retriever], weights=[0.5, 0.5]
        )
        return ensemble_metasploit_retriever, metasploit_df, df

    def exploit_db_database(self):
        """Builds the Exploit DB retriever and dataframe."""
        repo_path = "exploit_db_repo/"

        def loader(suffix):
            python_loader = GenericLoader.from_filesystem(
                repo_path,
                glob="**/*",
                suffixes=[suffix],
                parser=LanguageParser(language=Language.PYTHON),
            )
            python_documents = python_loader.load()
            return python_documents

        documents = []
        correspondence = []
        languages = [
            ".py",
            ".txt",
            ".c",
            ".cpp",
            ".rb",
            ".java",
            ".html",
            ".sh",
            ".pl",
            ".php",
            ".js",
            ".md",
        ]
        for language in tqdm(languages):
            docs = loader(language)
            for doc in docs:
                documents.append(doc.page_content[:600])
                correspondence.append(
                    {
                        "exploit_1000": doc.page_content[:600],
                        "exploit_full": doc.page_content,
                    }
                )

        df_exploit = pd.DataFrame(correspondence)
        tfidf = TFIDFRetriever.from_texts(documents)
        tfidf.k = 2

        return tfidf, df_exploit

    def extracted_code_retriever(self):
        """Builds the code retriever for extracted code snippets."""
        code_documents = self.get_code_documents()
        code_db = FAISS.load_local("../final_code_chunk_1", self.hf_bge_embeddings)
        code_retriever = code_db.as_retriever(
            search_type="similarity_score_threshold",
            search_kwargs={"score_threshold": 0.8},
        )
        store = code_db.docstore._dict
        docs = []
        for key, value in store.items():
            docs.append(value)
        bm25_retriever_code = BM25Retriever.from_documents(docs)
        bm25_retriever_code.k = 5
        ensemble_code_retriever = EnsembleRetriever(
            retrievers=[bm25_retriever_code, code_retriever], weights=[0.5, 0.5]
        )
        return ensemble_code_retriever

    def get_code_documents(self):
        """Loads code documents from specified paths."""
        source_path = "EXTRACT_CODE/"
        paths = [
            "exploit_collection_final_mistral",
            "fuzzing_collection_final_mistral",
            "other_collection_final_mistral",
            "windows_collection_final_mistral",
        ]
        real_documents = []
        for path in paths:
            path = source_path + path + "/"
            for file in os.listdir(path):
                if ".txt" in file:
                    file = path + file
                    with open(file, "r", encoding="utf-8") as f:
                        file_content = f.read()

                    # Separation of elements by '\n\n'
                    documents = file_content.split(
                        "\n\n\n------------------------------------------------\n\n\n"
                    )

                    # Remove any extra whitespace from each document
                    documents = [doc.strip() for doc in documents]
                    for doc in documents:
                        real_doc = Document(page_content=doc, metadata={"source": file})
                        real_documents.append(real_doc)
        return real_documents

    def retrieve_code_snippet_generic(self, query, word_to_filter, retriever, content_df):
        """Retrieves code snippets using the specified retriever and filters."""
        snippets = []
        if "CVE-" in word_to_filter:
            word_to_filter = word_to_filter.replace("CVE-", "")
        for doc in retriever.get_relevant_documents(query):
            if str(word_to_filter) in doc.page_content:
                page_content_full = content_df.loc[
                    content_df[
                        "initialize" if retriever == self.metasploit_retriever else "exploit_1000"
                    ] == doc.page_content,
                    "complete_content" if retriever == self.metasploit_retriever else "exploit_full",
                ].values[0]
                snippets.append(page_content_full)

        return "\n\n\n".join(snippets)

    def retrieve_code_snippet(self, query, word_to_filter):
        """Retrieves code snippets using the ensemble code retriever."""
        return self.retrieve_code_snippet_generic(
            query, word_to_filter, self.ensemble_code_retriever, None
        )

    def retrieve_code_snippet_metasploit(self, query, word_to_filter):
        """Retrieves code snippets from Metasploit using the Metasploit retriever."""
        return self.retrieve_code_snippet_generic(
            query, word_to_filter, self.metasploit_retriever, self.metasploit_df
        )

    def retrieve_code_snippet_exploit(self, query, word_to_filter):
        """Retrieves code snippets from Exploit DB using the Exploit retriever."""
        return self.retrieve_code_snippet_generic(
            query, word_to_filter, self.exploit_retriever, self.df_exploit
        )

    def retrieve(self, query, entities_extracted):
        """Retrieves relevant code snippets from various sources."""
        # METASPLOIT
        meta_context = self.retrieve_data(
            entities_extracted,
            "METASPLOIT",
            self.retrieve_code_snippet_metasploit,
            query,
        )

        # EXPLOIT DB
        exploit_context = self.retrieve_data(
            entities_extracted,
            "EXPLOIT",
            self.retrieve_code_snippet_exploit,
            query,
        )

        combined_context = {
            "METASPLOIT": meta_context,
            "EXPLOIT": exploit_context,
        }
        return combined_context

    def retrieve_data(self, entities_extracted, source, retrieve_function, query):
        """Retrieves data from the specified source using the given retrieval function."""
        start_time = time.time()
        context = None

        for entity in entities_extracted:
            try:
                entity_word = entity["word"]
                if "CVE" not in entity_word:
                    context = retrieve_function(query, entity_word)
            except TypeError as te:
                self.setup_logger.debug(f"Ignoring TypeError in {source}: {str(te)}")
            except Exception as e:
                self.setup_logger.error(f"Error retrieving data from {source}: {str(e)}")

            if "CVE" in str(entity):
                context = retrieve_function(query, entity)

        elapsed_time = time.time() - start_time
        print(context)
        print(f"Time {source} Retriever: {elapsed_time} seconds")
        self.setup_logger.info(f"Time {source} Retriever: {elapsed_time} seconds")

        return context

    def generate_context(self, query, entities_extracted):
        """Generates context by retrieving relevant code snippets based on the query."""
        try:
            self.setup_logger.info(f"Inserted Query >> {query}")

            # Filter out "CVE" from extracted entities
            entities_extracted = [
                element for element in entities_extracted if element != "CVE"
            ]

            # Find CVEs in the query
            cve_results = self.find_cve(query)

            if cve_results:
                self.setup_logger.info("CVEs found:")
                for cve in cve_results:
                    entities_extracted.append(cve)
                    self.setup_logger.info(cve)

                    # Retrieve relevant documents for the CVE
                    description = self.cve_df.loc[
                        self.cve_df["CVE"] == cve, "Descriptions"
                    ].values

                    cve_id = cve
                    self.setup_logger.info(description)
                    query = query.replace(cve, f"{cve_id} {description}")

            else:
                self.setup_logger.info("No CVEs found.")

            # Retrieve context using the modified query and extracted entities
            combined_context = self.retrieve(query, entities_extracted)
            return combined_context

        except Exception as e:
            self.setup_logger.error(f"An error occurred: {e}")
            pass


# Example usage:
'''
code_retrieval_system = CodeRetrievalSystem()
entity_extractor = EntityExtractor(model_name_or_path="dslim/bert-large-NER")
while True:
    query = input("\nInsert a query: ")
    entities_extracted = entity_extractor.extract(text=query)
    code_retrieval_system.generate_context(query, entities_extracted)
'''
